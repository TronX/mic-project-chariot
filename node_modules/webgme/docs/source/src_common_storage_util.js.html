<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/common/storage/util.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/common/storage/util.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*globals define*/
/*jshint node:true, browser: true*/
/**
 * @author lattmann / https://github.com/lattmann
 */

define([
    'common/storage/constants',
    'common/util/jsonPatcher',
    'q',
    'common/regexp',
    'common/util/key'
], function (CONSTANTS, jsonPatcher, Q, REGEXP, GENKEY) {
    'use strict';

    function _getRootHash(project, parameters) {
        var deferred = Q.defer();

        if (parameters.branchName) {
            Q.ninvoke(project, 'getBranchHash', parameters.branchName)
                .then(function (commitHash) {
                    parameters.commitHash = commitHash;
                    return Q.ninvoke(project, 'loadObject', commitHash);
                })
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.commitHash) {
            Q.ninvoke(project, 'loadObject', parameters.commitHash)
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.tagName) {
            Q.ninvoke(project, 'getAllTags')
                .then(function (tags) {
                    if (tags[parameters.tagName]) {
                        parameters.commitHash = tags[parameters.tagName];
                        return Q.ninvoke(project, 'loadObject', tags[parameters.tagName]);
                    } else {
                        throw new Error('Unknown tag name [' + parameters.tagName + ']');
                    }
                })
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.rootHash) {
            deferred.resolve(parameters.rootHash);
        } else {
            deferred.reject(new Error('No valid input was given to search for rootHash'));
        }

        return deferred.promise;
    }

    function _collectObjects(project, objectHashArray) {
        var deferred = Q.defer(),
            promises = [],
            objects = [],
            i;

        for (i = 0; i &lt; objectHashArray.length; i += 1) {
            promises.push(Q.ninvoke(project, 'loadObject', objectHashArray[i]));
        }

        Q.allSettled(promises)
            .then(function (results) {
                var error = null,
                    i;
                for (i = 0; i &lt; results.length; i += 1) {
                    if (results[i].state === 'fulfilled') {
                        objects.push(results[i].value);
                    } else {
                        error = error || results[i].reason || new Error('unable to load');
                    }
                }

                if (error) {
                    deferred.reject(error);
                } else {
                    deferred.resolve(objects);
                }
            });
        return deferred.promise;
    }

    function _collectObjectAndAssetHashes(project, rootHash) {
        var deferred = Q.defer(),
            objects = {},
            assets = {},
            queue = [rootHash],
            task,
            error = null,
            working = false,
            timerId;

        timerId = setInterval(function () {
            if (!working) {
                task = queue.shift();
                if (task === undefined) {
                    clearInterval(timerId);
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve({objects: Object.keys(objects), assets: Object.keys(assets)});
                    }
                    return;
                }

                if (!objects[task]) {
                    working = true;
                    project.loadObject(task, function (err, object) {
                        var key;

                        error = error || err;
                        if (!err &amp;&amp; object) {
                            objects[task] = true;
                            if (object) {
                                //now put every sub-object on top of the queue
                                for (key in object) {
                                    if (typeof object[key] === 'string' &amp;&amp; REGEXP.HASH.test(object[key])) {
                                        queue.push(object[key]);
                                    }
                                }

                                //looking for assets
                                if (object.atr) {
                                    for (key in object.atr) {
                                        //TODO why can't we inlcude BlobConfig???
                                        if (typeof object.atr[key] === 'string' &amp;&amp;
                                            REGEXP.BLOB_HASH.test(object.atr[key])) {
                                            assets[object.atr[key]] = true;
                                        }
                                    }
                                }
                            }
                        }
                        working = false;
                    });
                }

            }
        }, 1);

        return deferred.promise;
    }

    return {
        CONSTANTS: CONSTANTS,
        getProjectFullNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, CONSTANTS.PROJECT_DISPLAYED_NAME_SEP);
            }
        },
        getProjectDisplayedNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, ' ' + CONSTANTS.PROJECT_DISPLAYED_NAME_SEP + ' ');
            }
        },
        getProjectIdFromProjectFullName: function (projectFullName) {
            if (projectFullName) {
                return projectFullName.replace(CONSTANTS.PROJECT_DISPLAYED_NAME_SEP, CONSTANTS.PROJECT_ID_SEP);
            }
        },
        getProjectIdFromOwnerIdAndProjectName: function (userId, projectName) {
            return userId + CONSTANTS.PROJECT_ID_SEP + projectName;
        },
        getProjectNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.substring(projectId.indexOf(CONSTANTS.PROJECT_ID_SEP) + 1);
            }
        },
        getOwnerFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.substring(0, projectId.indexOf(CONSTANTS.PROJECT_ID_SEP));
            }
        },
        getHashTaggedHash: function (hash) {
            if (typeof hash === 'string') {
                return hash[0] === '#' ? hash : '#' + hash;
            }
            return hash;
        },
        getPatchObject: function (oldData, newData) {
            var patchObject = {
                type: 'patch',
                base: oldData[CONSTANTS.MONGO_ID],
                patch: jsonPatcher.create(oldData, newData)
            };
            patchObject[CONSTANTS.MONGO_ID] = newData[CONSTANTS.MONGO_ID];

            return patchObject;
        },
        coreObjectHasOldAndNewData: function (coreObj) {
            return !!(coreObj.oldHash &amp;&amp; coreObj.newHash &amp;&amp; coreObj.oldData &amp;&amp; coreObj.newData);
        },
        getChangedNodes: jsonPatcher.getChangedNodes,
        applyPatch: jsonPatcher.apply,
        checkHashConsistency: function (gmeConfig, dataObj, hash) {
            var result;

            if (gmeConfig.storage.keyType === 'rand160Bits') {
                // Random hashes should not be checked.
                result = true;
            } else if (gmeConfig.storage.disableHashChecks === true) {
                // Configured to not check.
                result = true;
            } else {
                dataObj[CONSTANTS.MONGO_ID] = '';
                result = hash === '#' + GENKEY(dataObj, gmeConfig);
            }

            return result;
        },

        /**
         * Extracts a serializable json representation of a project tree.
         * To specify starting point set one of the four options. If more than one is set the order of precedence is:
         * branchName, commitHash, tagName and rootHash.
         *
         * @param {ProjectInterface} project
         * @param {object} parameters - Specifies which project tree should be serialized:
         * @param {string} [parameters.rootHash] - The hash of the tree root.
         * @param {string} [parameters.commitHash] - The tree associated with the commitHash.
         * @param {string} [parameters.tagName] - The tree at the given tag.
         * @param {string} [parameters.branchName] - The tree at the given branch.
         * @param {function} callback
         */
        getProjectJson: function (project, parameters, callback) {
            var deferred = Q.defer(),
                rawJson;

            _getRootHash(project, parameters || {})
                .then(function (rootHash) {
                    return _collectObjectAndAssetHashes(project, rootHash);
                })
                .then(function (hashes) {
                    rawJson = {
                        rootHash: parameters.rootHash,
                        projectId: project.projectId,
                        branchName: parameters.branchName,
                        commitHash: parameters.commitHash,
                        hashes: hashes,
                        objects: null
                    };
                    return _collectObjects(project, hashes.objects);
                })
                .then(function (objects) {
                    rawJson.objects = objects;
                    deferred.resolve(rawJson);
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        },

        /**
         * Inserts a serialized project tree into the storage and associates it with a commitHash.
         *
         * @param {ProjectInterface} project
         * @param {object} [options]
         * @param {string} [options.commitMessage=%defaultCommitMessage%] information about the insertion
         * @param {function(Error, hashes)} callback
         */
        insertProjectJson: function (project, projectJson, options, callback) {
            var deferred = Q.defer(),
                toPersist = {},
                rootHash = projectJson.rootHash,
                defaultCommitMessage = 'Importing contents of [' +
                    projectJson.projectId + '@' + rootHash + ']',
                objects = projectJson.objects,
                i;

            for (i = 0; i &lt; objects.length; i += 1) {
                // we have to patch the object right before import, for smoother usage experience
                toPersist[objects[i]._id] = objects[i];
            }

            options = options || {};

            options.branch = options.branch || null;
            options.parentCommit = options.parentCommit || [];

            project.makeCommit(options.branch, options.parentCommit,
                rootHash, toPersist, options.commitMessage || defaultCommitMessage)
                .then(function (commitResult) {
                    deferred.resolve(commitResult);
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        }
    };
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="Bin_Apply.html">Bin:Apply</a></li><li><a href="Bin_Diff.html">Bin:Diff</a></li><li><a href="Bin_Export.html">Bin:Export</a></li><li><a href="Bin_Import.html">Bin:Import</a></li><li><a href="Bin_Merge.html">Bin:Merge</a></li><li><a href="Bin_ReassignRelids.html">Bin:ReassignRelids</a></li><li><a href="Bin_RunPlugin.html">Bin:RunPlugin</a></li><li><a href="Bin_StartServer.html">Bin:StartServer</a></li><li><a href="Bin_UserManager.html">Bin:UserManager</a></li><li><a href="CoreAddOns_ConstraintAddOn.html">CoreAddOns:ConstraintAddOn</a></li><li><a href="CoreAddOns_NotificationAddOn.html">CoreAddOns:NotificationAddOn</a></li><li><a href="CoreAddOns_TestAddOn.html">CoreAddOns:TestAddOn</a></li><li><a href="CorePlugins_AddOnGenerator.html">CorePlugins:AddOnGenerator</a></li><li><a href="CorePlugins_ConfigurationArtifact.html">CorePlugins:ConfigurationArtifact</a></li><li><a href="CorePlugins_ConstraintEvaluator.html">CorePlugins:ConstraintEvaluator</a></li><li><a href="CorePlugins_DecoratorGenerator.html">CorePlugins:DecoratorGenerator</a></li><li><a href="CorePlugins_ExecutorPlugin.html">CorePlugins:ExecutorPlugin</a></li><li><a href="CorePlugins_ImportV1.html">CorePlugins:ImportV1</a></li><li><a href="CorePlugins_LayoutGenerator.html">CorePlugins:LayoutGenerator</a></li><li><a href="CorePlugins_MergeExample.html">CorePlugins:MergeExample</a></li><li><a href="CorePlugins_MetaGMEParadigmImporter.html">CorePlugins:MetaGMEParadigmImporter</a></li><li><a href="CorePlugins_MinimalWorkingExample.html">CorePlugins:MinimalWorkingExample</a></li><li><a href="CorePlugins_PluginGenerator.html">CorePlugins:PluginGenerator</a></li><li><a href="CorePlugins_VisualizerGenerator.html">CorePlugins:VisualizerGenerator</a></li><li><a href="Executor_AddLabelJob.html">Executor:AddLabelJob</a></li><li><a href="Executor_NodeWorker.html">Executor:NodeWorker</a></li><li><a href="module-Core.html">Core</a></li><li><a href="module-EnsureDir.html">EnsureDir</a></li><li><a href="module-Storage.html">Storage</a></li><li><a href="Server.module_ConnectedWorker.html">ConnectedWorker</a></li><li><a href="Server.module_SimpleWorker.html">SimpleWorker</a></li><li><a href="Server_API.html">Server:API</a></li><li><a href="Server_GMEAuth.html">Server:GMEAuth</a></li><li><a href="Server_Logger.html">Server:Logger</a></li><li><a href="Server_SafeStorage.html">Server:SafeStorage</a></li><li><a href="Server_ServerWorkerManager.html">Server:ServerWorkerManager</a></li><li><a href="Server_StandAlone.html">Server:StandAlone</a></li><li><a href="Server_Storage.html">Server:Storage</a></li><li><a href="Server_Storage_Dynamo.html">Server:Storage:Dynamo</a></li><li><a href="Server_Storage_Memory.html">Server:Storage:Memory</a></li><li><a href="Server_Storage_Mongo.html">Server:Storage:Mongo</a></li><li><a href="Server_Storage_Neo4j.html">Server:Storage:Neo4j</a></li><li><a href="Server_Storage_Redis.html">Server:Storage:Redis</a></li><li><a href="Server_UserProject.html">Server:UserProject</a></li><li><a href="Server_WebSockets.html">Server:WebSockets</a></li><li><a href="Server_WorkerConstants.html">Server:WorkerConstants</a></li></ul><h3>Externals</h3><ul><li><a href="external-Promise.html">Promise</a></li></ul><h3>Classes</h3><ul><li><a href="AddOnBase.html">AddOnBase</a></li><li><a href="AddOnUpdateResult.html">AddOnUpdateResult</a></li><li><a href="Artifact.html">Artifact</a></li><li><a href="AuthorizerBase.html">AuthorizerBase</a></li><li><a href="BlobClient.html">BlobClient</a></li><li><a href="BlobMetadata.html">BlobMetadata</a></li><li><a href="BlobRunPluginClient.html">BlobRunPluginClient</a></li><li><a href="Core.html">Core</a></li><li><a href="ExecutorClient.html">ExecutorClient</a></li><li><a href="JobInfo.html">JobInfo</a></li><li><a href="OutputInfo.html">OutputInfo</a></li><li><a href="PluginBase.html">PluginBase</a></li><li><a href="PluginConfig.html">PluginConfig</a></li><li><a href="PluginHandler.html">PluginHandler</a></li><li><a href="PluginMessage.html">PluginMessage</a></li><li><a href="PluginNodeDescription.html">PluginNodeDescription</a></li><li><a href="PluginResult.html">PluginResult</a></li><li><a href="Project.html">Project</a></li><li><a href="ProjectInterface.html">ProjectInterface</a></li><li><a href="Server_GMEAuth-GMEAuth.html">GMEAuth</a></li><li><a href="Server_SafeStorage-SafeStorage.html">SafeStorage</a></li><li><a href="Server_Storage_Memory-Memory.html">Memory</a></li><li><a href="Server_UserProject-UserProject.html">UserProject</a></li><li><a href="WorkerRequests.html">WorkerRequests</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cleanUp">cleanUp</a></li><li><a href="global.html#getProjectJson">getProjectJson</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#insertProjectJson">insertProjectJson</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Nov 28 2016 13:13:32 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
