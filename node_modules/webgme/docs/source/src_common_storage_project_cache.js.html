<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/common/storage/project/cache.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/common/storage/project/cache.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*globals define*/
/*jshint browser: true, node:true*/
/**
 * This class (extracted functionality from cache implemented by mmaroti) caches objects associated
 * with a project.
 *
 * @author pmeijer / https://github.com/pmeijer
 * @author mmaroti / https://github.com/mmaroti
 */

define([
    'common/util/assert',
    'common/storage/constants',
    'common/storage/util'
], function (ASSERT, CONSTANTS, UTIL) {
    'use strict';
    function ProjectCache(storage, projectId, mainLogger, gmeConfig) {
        var self = this,
            missing = {},
            backup = {},
            cache = {},
            logger = mainLogger.fork('ProjectCache'),
            cacheSize = 0;

        logger.debug('ctor', projectId);

        this.queuedPersists = {};

        function cacheInsert(key, obj) {
            ASSERT(obj[CONSTANTS.MONGO_ID] === key);
            logger.debug('cacheInsert', key);

            //deepFreeze(obj);
            if (!cache[key]) {
                cache[key] = obj;

                if (++cacheSize >= gmeConfig.storage.cache) {
                    backup = cache;
                    cache = {};
                    cacheSize = 0;
                }
                return true;
            } else {
                return false;
            }
        }

        function getFromCache(hash) {
            var obj = cache[hash],
                commitId;

            if (typeof obj === 'undefined') {
                obj = backup[hash];

                if (typeof obj === 'undefined') {
                    for (commitId in self.queuedPersists) {
                        if (self.queuedPersists.hasOwnProperty(commitId) &amp;&amp; self.queuedPersists[commitId][hash]) {
                            obj = self.queuedPersists[commitId][hash];
                            break;
                        }
                    }
                }
            }

            return obj;
        }

        this.loadObject = function (key, callback) {
            var commitId;
            ASSERT(typeof key === 'string' &amp;&amp; typeof callback === 'function');
            logger.debug('loadObject', {metadata: key});

            var obj = cache[key];
            if (typeof obj === 'undefined') {
                obj = backup[key];
                if (typeof obj === 'undefined') {
                    for (commitId in self.queuedPersists) {
                        if (self.queuedPersists.hasOwnProperty(commitId) &amp;&amp; self.queuedPersists[commitId][key]) {
                            obj = self.queuedPersists[commitId][key];
                            break;
                        }
                    }
                    if (typeof obj === 'undefined') {
                        obj = missing[key];
                        if (typeof obj === 'undefined') {
                            obj = [callback];
                            missing[key] = obj;
                            logger.debug('object set to be loaded from storage');
                            storage.loadObject(projectId, key, function (err, obj2) {
                                ASSERT(typeof obj2 === 'object' || typeof obj2 === 'undefined');

                                if (obj.length !== 0) {
                                    ASSERT(missing[key] === obj);

                                    delete missing[key];
                                    if (!err &amp;&amp; obj2) {
                                        cacheInsert(key, obj2);
                                    }

                                    var cb;
                                    while ((cb = obj.pop())) {
                                        cb(err, obj2);
                                    }
                                }
                            });
                        } else {
                            logger.debug('object was already queued to be loaded');
                            obj.push(callback);
                        }
                        return;
                    } else {
                        logger.debug('object was erased from cache and backup but present in queuedPersists');
                        cacheInsert(key, obj);
                    }
                } else {
                    logger.debug('object was in backup');
                    cacheInsert(key, obj);
                }
            } else {
                logger.debug('object was in cache');
            }

            ASSERT(typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; obj[CONSTANTS.MONGO_ID] === key);
            callback(null, obj);
        };

        /**
         * Loads the necessary objects for the nodes corresponding to paths and inserts them in the cache.
         * If the rootKey is empty or does not exist - it won't attempt to load any nodes.
         * @param {string} rootKey
         * @param {string[]} paths
         * @param {function(err)} callback
         */
        this.loadPaths = function (rootKey, paths, callback) {
            logger.debug('loadPaths', {metadata: {rootKey: rootKey, paths: paths}});

            var cachedObjects = {},
                excludes = [],
                rootObj = getFromCache(rootKey),
                i = paths.length,
                j,
                pathArray,
                obj,
                pathsInfo = [],
                key;

            if (!rootKey) {
                logger.debug('rootKey empty:', rootKey);
                callback(null);
                return;
            }

            if (rootObj) {
                // The root was loaded, so for each requested path we start from the root
                // and work our way down to the containment chain and add each object that is
                // already in the cache to 'excludes'.

                excludes.push(rootKey);
                cachedObjects[rootKey] = rootObj;
                while (i--) {
                    pathArray = paths[i].split('/');
                    pathArray.shift();

                    obj = rootObj;
                    for (j = 0; j &lt; pathArray.length; j += 1) {
                        key = obj[pathArray[j]];
                        if (key) {
                            obj = getFromCache(key);
                            if (typeof obj !== 'undefined') {
                                excludes.push(key);
                                cachedObjects[key] = obj;
                            } else {
                                pathsInfo.push({
                                    parentHash: key,
                                    path: '/' + pathArray.slice(j + 1).join('/')
                                });
                                break;
                            }
                        } else {
                            // The given path does not exist anymore - break.
                            break;
                        }
                    }
                }
            } else {
                pathsInfo = paths.map(function (path) {
                    return {
                        parentHash: rootKey,
                        path: path
                    };
                });
            }

            if (pathsInfo.length === 0) {
                logger.debug('All given paths already loaded');
                callback(null);
                return;
            }

            logger.debug('loadPaths will request from server, pathsInfo:', pathsInfo);
            storage.loadPaths(projectId, pathsInfo, excludes, function (err, serverObjects) {
                var keys, i;
                if (!err &amp;&amp; serverObjects) {
                    // Insert every obtained object into the cache (that was not there before).
                    keys = Object.keys(serverObjects);
                    for (i = 0; i &lt; keys.length; i += 1) {
                        if (serverObjects[keys[i]] !== undefined) {
                            // When not going through a web-socket loadPaths returns keys with
                            // undefined values, therefore the extra check.
                            cacheInsert(keys[i], serverObjects[keys[i]]);
                        }
                    }

                    // Reinsert the cachedObjects.
                    keys = Object.keys(cachedObjects);
                    for (i = 0; i &lt; keys.length; i += 1) {
                        cacheInsert(keys[i], cachedObjects[keys[i]]);
                    }
                    callback(null);
                } else {
                    logger.error('loadingPaths failed', err || new Error('no object arrived from server'));
                    callback(err);
                }
            });
        };

        this.insertObject = function (obj, stackedObjects) {
            ASSERT(typeof obj === 'object' &amp;&amp; obj !== null);

            var key = obj[CONSTANTS.MONGO_ID];
            logger.debug('insertObject', {metadata: key});
            ASSERT(typeof key === 'string');

            if (cacheInsert(key, obj) === false) {
                // The storage on the server will return error if it's not the same..
                logger.debug('object inserted was already in cache');
            } else {
                var item = backup[key];

                if (typeof item !== 'undefined') {
                    // The storage on the server will return error if it's not the same..
                    logger.debug('object inserted was already in back-up');
                } else {
                    item = missing[key];
                    if (typeof item !== 'undefined') {
                        delete missing[key];

                        var cb;
                        while ((cb = item.pop())) {
                            cb(null, obj);
                        }
                    }
                }
            }
            if (stackedObjects) {
                stackedObjects[key] = obj;
            }
        };

        this.insertPatchObject = function (obj) {
            ASSERT(typeof obj === 'object' &amp;&amp; obj !== null);

            var base,
                patch,
                key = obj[CONSTANTS.MONGO_ID];

            if (obj.base &amp;&amp; typeof obj.patch === 'object' &amp;&amp; key) {
                base = getFromCache(obj.base);

                if (base) {
                    patch = UTIL.applyPatch(base, obj.patch);
                    if (patch.status === 'success') {
                        patch.result[CONSTANTS.MONGO_ID] = key;
                        this.insertObject(patch.result);
                    } else {
                        logger.error('patch application failed', patch);
                    }
                } else {
                    logger.debug('the base [' +
                        obj.base + '] is not available from the cache so the patch object is ignored');
                }
            } else {
                logger.error('invalid patch object format', obj);
            }
        };
    }

    return ProjectCache;
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="Bin_Apply.html">Bin:Apply</a></li><li><a href="Bin_Diff.html">Bin:Diff</a></li><li><a href="Bin_Export.html">Bin:Export</a></li><li><a href="Bin_Import.html">Bin:Import</a></li><li><a href="Bin_Merge.html">Bin:Merge</a></li><li><a href="Bin_ReassignRelids.html">Bin:ReassignRelids</a></li><li><a href="Bin_RunPlugin.html">Bin:RunPlugin</a></li><li><a href="Bin_StartServer.html">Bin:StartServer</a></li><li><a href="Bin_UserManager.html">Bin:UserManager</a></li><li><a href="CoreAddOns_ConstraintAddOn.html">CoreAddOns:ConstraintAddOn</a></li><li><a href="CoreAddOns_NotificationAddOn.html">CoreAddOns:NotificationAddOn</a></li><li><a href="CoreAddOns_TestAddOn.html">CoreAddOns:TestAddOn</a></li><li><a href="CorePlugins_AddOnGenerator.html">CorePlugins:AddOnGenerator</a></li><li><a href="CorePlugins_ConfigurationArtifact.html">CorePlugins:ConfigurationArtifact</a></li><li><a href="CorePlugins_ConstraintEvaluator.html">CorePlugins:ConstraintEvaluator</a></li><li><a href="CorePlugins_DecoratorGenerator.html">CorePlugins:DecoratorGenerator</a></li><li><a href="CorePlugins_ExecutorPlugin.html">CorePlugins:ExecutorPlugin</a></li><li><a href="CorePlugins_ImportV1.html">CorePlugins:ImportV1</a></li><li><a href="CorePlugins_LayoutGenerator.html">CorePlugins:LayoutGenerator</a></li><li><a href="CorePlugins_MergeExample.html">CorePlugins:MergeExample</a></li><li><a href="CorePlugins_MetaGMEParadigmImporter.html">CorePlugins:MetaGMEParadigmImporter</a></li><li><a href="CorePlugins_MinimalWorkingExample.html">CorePlugins:MinimalWorkingExample</a></li><li><a href="CorePlugins_PluginGenerator.html">CorePlugins:PluginGenerator</a></li><li><a href="CorePlugins_VisualizerGenerator.html">CorePlugins:VisualizerGenerator</a></li><li><a href="Executor_AddLabelJob.html">Executor:AddLabelJob</a></li><li><a href="Executor_NodeWorker.html">Executor:NodeWorker</a></li><li><a href="module-Core.html">Core</a></li><li><a href="module-EnsureDir.html">EnsureDir</a></li><li><a href="module-Storage.html">Storage</a></li><li><a href="Server.module_ConnectedWorker.html">ConnectedWorker</a></li><li><a href="Server.module_SimpleWorker.html">SimpleWorker</a></li><li><a href="Server_API.html">Server:API</a></li><li><a href="Server_GMEAuth.html">Server:GMEAuth</a></li><li><a href="Server_Logger.html">Server:Logger</a></li><li><a href="Server_SafeStorage.html">Server:SafeStorage</a></li><li><a href="Server_ServerWorkerManager.html">Server:ServerWorkerManager</a></li><li><a href="Server_StandAlone.html">Server:StandAlone</a></li><li><a href="Server_Storage.html">Server:Storage</a></li><li><a href="Server_Storage_Dynamo.html">Server:Storage:Dynamo</a></li><li><a href="Server_Storage_Memory.html">Server:Storage:Memory</a></li><li><a href="Server_Storage_Mongo.html">Server:Storage:Mongo</a></li><li><a href="Server_Storage_Neo4j.html">Server:Storage:Neo4j</a></li><li><a href="Server_Storage_Redis.html">Server:Storage:Redis</a></li><li><a href="Server_UserProject.html">Server:UserProject</a></li><li><a href="Server_WebSockets.html">Server:WebSockets</a></li><li><a href="Server_WorkerConstants.html">Server:WorkerConstants</a></li></ul><h3>Externals</h3><ul><li><a href="external-Promise.html">Promise</a></li></ul><h3>Classes</h3><ul><li><a href="AddOnBase.html">AddOnBase</a></li><li><a href="AddOnUpdateResult.html">AddOnUpdateResult</a></li><li><a href="Artifact.html">Artifact</a></li><li><a href="AuthorizerBase.html">AuthorizerBase</a></li><li><a href="BlobClient.html">BlobClient</a></li><li><a href="BlobMetadata.html">BlobMetadata</a></li><li><a href="BlobRunPluginClient.html">BlobRunPluginClient</a></li><li><a href="Core.html">Core</a></li><li><a href="ExecutorClient.html">ExecutorClient</a></li><li><a href="JobInfo.html">JobInfo</a></li><li><a href="OutputInfo.html">OutputInfo</a></li><li><a href="PluginBase.html">PluginBase</a></li><li><a href="PluginConfig.html">PluginConfig</a></li><li><a href="PluginHandler.html">PluginHandler</a></li><li><a href="PluginMessage.html">PluginMessage</a></li><li><a href="PluginNodeDescription.html">PluginNodeDescription</a></li><li><a href="PluginResult.html">PluginResult</a></li><li><a href="Project.html">Project</a></li><li><a href="ProjectInterface.html">ProjectInterface</a></li><li><a href="Server_GMEAuth-GMEAuth.html">GMEAuth</a></li><li><a href="Server_SafeStorage-SafeStorage.html">SafeStorage</a></li><li><a href="Server_Storage_Memory-Memory.html">Memory</a></li><li><a href="Server_UserProject-UserProject.html">UserProject</a></li><li><a href="WorkerRequests.html">WorkerRequests</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cleanUp">cleanUp</a></li><li><a href="global.html#getProjectJson">getProjectJson</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#insertProjectJson">insertProjectJson</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Nov 28 2016 13:13:32 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
