<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/addon/branchmonitor.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/addon/branchmonitor.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*globals requireJS*/
/*jshint node:true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */
'use strict';

var Q = require('q'),
    BlobClientClass = requireJS('blob/BlobClient'),
    Core = requireJS('common/core/coreQ');

/**
 * Monitors given branch and starts, stops and updates registered addOns.
 *
 * @param {string} webgmeToken
 * @param {EditorStorage} storage
 * @param {Project} project
 * @param {string} branchName
 * @param {object} gmeConfig
 * @param {object} mainLogger
 * @constructor
 * @ignore
 */
function BranchMonitor(webgmeToken, storage, project, branchName, mainLogger, gmeConfig) {
    var self = this,
        logger = mainLogger.fork('BranchMonitor:' + branchName),
        core = new Core(project, {globConf: gmeConfig, logger: logger.fork('core')}),
        startDeferred,
        stopDeferred;

    this.runningAddOns = [
        //{id: {string}, instance: {AddOnBase}}
    ];

    // State
    this.commitHash = '';
    this.rootHash = '';
    this.rootNode = null;
    this.commitMessage = '';

    this.stopRequested = false;
    this.startRequested = false;
    this.branchIsOpen = false;


    // Helper functions
    function getAddOn(id) {
        var addOnPath = 'addon/' + id + '/' + id + '/' + id,
            AddOn,
            error,
            addOn;

        logger.debug('requireJS addOn from path: ' + addOnPath);
        try {
            AddOn = requireJS(addOnPath);
        } catch (err) {
            error = err;
        }

        // This is weird, the second time requirejs simply returns with undefined.
        if (AddOn) {
            addOn = new AddOn(logger.fork(id), gmeConfig);
            return addOn;
        } else {
            return error || new Error('AddOn is not available from: ' + addOnPath);
        }
    }

    function getConfiguration() {
        var blobClient = new BlobClientClass({
            serverPort: gmeConfig.server.port,
            httpsecure: false, // N.B.: addons are running on the server only
            server: '127.0.0.1',
            webgmeToken: webgmeToken,
            logger: logger.fork('BlobClient')
        });

        return {
            core: core,
            project: project,
            branchName: branchName,
            blobClient: blobClient
        };
    }

    function loadNewRoot(commitData, callback) {
        var deferred = Q.defer();
        self.rootHash = commitData.commitObject.root;
        self.commitHash = commitData.commitObject._id;
        logger.debug('loadNewRoot [commit/rootHash]', self.commitHash, self.rootHash);

        core.loadRoot(self.rootHash, function (err, root) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }

            self.rootNode = root;
            deferred.resolve(root);
        });

        return deferred.promise.nodeify(callback);
    }

    function updateRunningAddOns(commitObj, callback) {
        var deferred = new Q.defer(),
            counter = 0,
            limit = self.runningAddOns.length;

        function getUpdateCallback(addOn, counter) {
            return function (err, addOnResult) {
                if (err) {
                    // TODO: How to handle this?
                    logger.error('AddOn [' + addOn.id + '] returned error at init/update', err);
                }

                if (addOnResult.commitMessage) {
                    self.commitMessage += addOnResult.commitMessage;
                    logger.debug('AddOn [' + addOn.id + '] added to commitMessage', self.commitMessage);
                }

                addOnResult.notifications.forEach(function (notification) {
                    // Do not wait/block for the notification result.
                    storage.webSocket.sendNotification(notification, function (err) {
                        if (err) {
                            logger.error('Failed sending notification', notification, err);
                        } else {
                            logger.debug('Sent notification', notification);
                        }
                    });
                });

                updateAddOn(self.runningAddOns[counter]);
            };
        }

        function updateAddOn(addOn) {
            if (counter === limit) {
                deferred.resolve();
                return;
            }
            counter += 1;
            if (addOn.instance.initialized === true) {
                logger.debug('updating addOn: ', addOn.id);
                addOn.instance._update(self.rootNode, commitObj, getUpdateCallback(addOn, counter));
            } else {
                addOn.instance.configure(getConfiguration());
                logger.debug('initializing addOn: ', addOn.id);
                addOn.instance._initialize(self.rootNode, commitObj, getUpdateCallback(addOn, counter));
            }
        }

        if (limit === 0) {
            logger.debug('There are no running addOns');
            deferred.resolve();
        } else {
            updateAddOn(self.runningAddOns[0]);
        }

        return deferred.promise.nodeify(callback);
    }

    function onUpdate(eventData, commitQueue, updateQueue, handlerCallback) {
        var commitData = eventData.commitData;

        if (eventData.local) {
            // This is when an addOn made changes and a commit was made below.
            logger.debug('AddOn made changes (local event data)');
            handlerCallback(null, self.stopRequested === false);
            return;
        }

        // loadNewRoot will set self.commitHash/rootHash/rootNode
        loadNewRoot(commitData)
            .then(function () {
                var runningAddOnsNew = [],
                    requiredAddOns = core.getRegistry(self.rootNode, 'usedAddOns'),
                    i,
                    j,
                    newAddOn,
                    wasRunning;

                if (typeof requiredAddOns === 'string') {
                    requiredAddOns = requiredAddOns.trim();
                    requiredAddOns = requiredAddOns ? requiredAddOns.split(' ') : [];
                } else {
                    requiredAddOns = [];
                }


                logger.debug('requiredAddOns:', requiredAddOns);

                for (i = 0; i &lt; requiredAddOns.length; i += 1) {
                    wasRunning = false;
                    for (j = 0; j &lt; self.runningAddOns.length; j += 1) {
                        //FIXME: This can raise an error that
                        if (self.runningAddOns[j].id === requiredAddOns[i]) {
                            runningAddOnsNew.push(self.runningAddOns[j]);
                            wasRunning = true;
                            break;
                        }
                    }
                    if (wasRunning === false) {
                        newAddOn = getAddOn(requiredAddOns[i]);
                        if (newAddOn instanceof Error) {
                            logger.error('Could not get addOn', newAddOn);
                        } else {
                            runningAddOnsNew.push({
                                id: requiredAddOns[i],
                                instance: newAddOn
                            });
                        }
                    }
                }

                self.runningAddOns = runningAddOnsNew;
                self.commitMessage = 'AddOns';

                return updateRunningAddOns(commitData.commitObject);
            })
            .then(function () {
                var persisted = core.persist(self.rootNode),
                    persistedObjects = Object.keys(persisted.objects);
                if (persistedObjects.length === 0) {
                    logger.debug('No changes made by addOns');
                } else {
                    // This will create an update event with local:true, see top of function.
                    logger.debug('Changes were made', self.commitMessage);
                    logger.debug('Number of persisted objects', persistedObjects.length);
                    project.makeCommit(branchName, [self.commitHash], persisted.rootHash,
                        persisted.objects, self.commitMessage,
                        function (err, result) {
                            if (err) {
                                logger.error('makeCommit', err);
                            } else {
                                logger.debug('makeCommit', result);
                            }
                        });
                }
                handlerCallback(null, self.stopRequested === false);
            })
            .catch(function (err) {
                logger.error('Fatal error', err);
                handlerCallback(err, false);
            });
    }

    function branchStatusHandler(branchStatus /*, commitQueue, updateQueue*/) {
        //TODO check how it should work
        logger.debug('New branchStatus', branchStatus);
    }

    // API functions
    /**
     * Opens up its branch and registers the onUpdate function.
     * @param [callback]
     * @returns {Promise}
     */
    this.start = function (callback) {
        if (self.startRequested === false) {
            startDeferred = Q.defer();
            self.startRequested = true;

            storage.openBranch(project.projectId, branchName, onUpdate, branchStatusHandler,
                function (err/*, latestCommitData*/) {
                    if (err) {
                        startDeferred.reject(err);
                        return;
                    }
                    self.branchIsOpen = true;
                    startDeferred.resolve();
                }
            );
        }

        return startDeferred.promise.nodeify(callback);
    };

    /**
     * Closes the open branch.
     * @param [callback]
     * @returns {Promise}
     */
    this.stop = function (callback) {
        if (self.stopRequested === false) {
            stopDeferred = Q.defer();
            self.stopRequested = true;

            storage.closeBranch(project.projectId, branchName, function (err) {
                self.branchIsOpen = false;
                if (err) {
                    stopDeferred.reject(err);
                } else {
                    stopDeferred.resolve();
                }
            });
        }

        return stopDeferred.promise.nodeify(callback);
    };

    this.queryAddOn = function (addOnId, commitHash, queryParams, callback) {
        var deferred = Q.defer();
        deferred.reject(new Error('queryAddOn not implemented yet!'));
        return deferred.promise.nodeify(callback);
    };
}


module.exports = BranchMonitor;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="Bin_Apply.html">Bin:Apply</a></li><li><a href="Bin_Diff.html">Bin:Diff</a></li><li><a href="Bin_Export.html">Bin:Export</a></li><li><a href="Bin_Import.html">Bin:Import</a></li><li><a href="Bin_Merge.html">Bin:Merge</a></li><li><a href="Bin_ReassignRelids.html">Bin:ReassignRelids</a></li><li><a href="Bin_RunPlugin.html">Bin:RunPlugin</a></li><li><a href="Bin_StartServer.html">Bin:StartServer</a></li><li><a href="Bin_UserManager.html">Bin:UserManager</a></li><li><a href="CoreAddOns_ConstraintAddOn.html">CoreAddOns:ConstraintAddOn</a></li><li><a href="CoreAddOns_NotificationAddOn.html">CoreAddOns:NotificationAddOn</a></li><li><a href="CoreAddOns_TestAddOn.html">CoreAddOns:TestAddOn</a></li><li><a href="CorePlugins_AddOnGenerator.html">CorePlugins:AddOnGenerator</a></li><li><a href="CorePlugins_ConfigurationArtifact.html">CorePlugins:ConfigurationArtifact</a></li><li><a href="CorePlugins_ConstraintEvaluator.html">CorePlugins:ConstraintEvaluator</a></li><li><a href="CorePlugins_DecoratorGenerator.html">CorePlugins:DecoratorGenerator</a></li><li><a href="CorePlugins_ExecutorPlugin.html">CorePlugins:ExecutorPlugin</a></li><li><a href="CorePlugins_ImportV1.html">CorePlugins:ImportV1</a></li><li><a href="CorePlugins_LayoutGenerator.html">CorePlugins:LayoutGenerator</a></li><li><a href="CorePlugins_MergeExample.html">CorePlugins:MergeExample</a></li><li><a href="CorePlugins_MetaGMEParadigmImporter.html">CorePlugins:MetaGMEParadigmImporter</a></li><li><a href="CorePlugins_MinimalWorkingExample.html">CorePlugins:MinimalWorkingExample</a></li><li><a href="CorePlugins_PluginGenerator.html">CorePlugins:PluginGenerator</a></li><li><a href="CorePlugins_VisualizerGenerator.html">CorePlugins:VisualizerGenerator</a></li><li><a href="Executor_AddLabelJob.html">Executor:AddLabelJob</a></li><li><a href="Executor_NodeWorker.html">Executor:NodeWorker</a></li><li><a href="module-Core.html">Core</a></li><li><a href="module-EnsureDir.html">EnsureDir</a></li><li><a href="module-Storage.html">Storage</a></li><li><a href="Server.module_ConnectedWorker.html">ConnectedWorker</a></li><li><a href="Server.module_SimpleWorker.html">SimpleWorker</a></li><li><a href="Server_API.html">Server:API</a></li><li><a href="Server_GMEAuth.html">Server:GMEAuth</a></li><li><a href="Server_Logger.html">Server:Logger</a></li><li><a href="Server_SafeStorage.html">Server:SafeStorage</a></li><li><a href="Server_ServerWorkerManager.html">Server:ServerWorkerManager</a></li><li><a href="Server_StandAlone.html">Server:StandAlone</a></li><li><a href="Server_Storage.html">Server:Storage</a></li><li><a href="Server_Storage_Dynamo.html">Server:Storage:Dynamo</a></li><li><a href="Server_Storage_Memory.html">Server:Storage:Memory</a></li><li><a href="Server_Storage_Mongo.html">Server:Storage:Mongo</a></li><li><a href="Server_Storage_Neo4j.html">Server:Storage:Neo4j</a></li><li><a href="Server_Storage_Redis.html">Server:Storage:Redis</a></li><li><a href="Server_UserProject.html">Server:UserProject</a></li><li><a href="Server_WebSockets.html">Server:WebSockets</a></li><li><a href="Server_WorkerConstants.html">Server:WorkerConstants</a></li></ul><h3>Externals</h3><ul><li><a href="external-Promise.html">Promise</a></li></ul><h3>Classes</h3><ul><li><a href="AddOnBase.html">AddOnBase</a></li><li><a href="AddOnUpdateResult.html">AddOnUpdateResult</a></li><li><a href="Artifact.html">Artifact</a></li><li><a href="AuthorizerBase.html">AuthorizerBase</a></li><li><a href="BlobClient.html">BlobClient</a></li><li><a href="BlobMetadata.html">BlobMetadata</a></li><li><a href="BlobRunPluginClient.html">BlobRunPluginClient</a></li><li><a href="Core.html">Core</a></li><li><a href="ExecutorClient.html">ExecutorClient</a></li><li><a href="JobInfo.html">JobInfo</a></li><li><a href="OutputInfo.html">OutputInfo</a></li><li><a href="PluginBase.html">PluginBase</a></li><li><a href="PluginConfig.html">PluginConfig</a></li><li><a href="PluginHandler.html">PluginHandler</a></li><li><a href="PluginMessage.html">PluginMessage</a></li><li><a href="PluginNodeDescription.html">PluginNodeDescription</a></li><li><a href="PluginResult.html">PluginResult</a></li><li><a href="Project.html">Project</a></li><li><a href="ProjectInterface.html">ProjectInterface</a></li><li><a href="Server_GMEAuth-GMEAuth.html">GMEAuth</a></li><li><a href="Server_SafeStorage-SafeStorage.html">SafeStorage</a></li><li><a href="Server_Storage_Memory-Memory.html">Memory</a></li><li><a href="Server_UserProject-UserProject.html">UserProject</a></li><li><a href="WorkerRequests.html">WorkerRequests</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cleanUp">cleanUp</a></li><li><a href="global.html#getProjectJson">getProjectJson</a></li><li><a href="global.html#getStats">getStats</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#insertProjectJson">insertProjectJson</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Mon Nov 28 2016 13:13:32 GMT-0600 (Central Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
