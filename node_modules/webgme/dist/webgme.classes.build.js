// define global GME variable
var GME = GME || {};

// property to access GME class definitions
GME.classes = GME.classes || {};

// property to access build in dependencies
GME.utils = GME.utils || {};

(function(){/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.20 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function (global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.20',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                      /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function (value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function () {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function (part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function (scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function (name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                                         normalize(name, parentName, applyMap) :
                                         name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                     '_unnormalized' + (unnormalizedCounter += 1) :
                     '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                        prefix + '!' + normalizedName :
                        normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                    (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function (id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                each(globalDefQueue, function(queueItem) {
                    var id = queueItem[0];
                    if (typeof id === 'string') {
                        context.defQueueMap[id] = true;
                    }
                    defQueue.push(queueItem);
                });
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function (mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function (mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function (mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function () {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function (depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function (mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function (mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function () {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function (map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function (depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function (err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function (i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function () {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function () {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function () {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function () {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    // Only fetch if not already in the defQueue.
                    if (!hasProp(context.defQueueMap, id)) {
                        this.fetch();
                    }
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function () {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function (plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function (name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                      this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function (value) {
                                this.init([], function () { return value; }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function (err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function (value) {
                        this.init([], function () { return value; }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function (err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function (mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function (text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                             'fromText eval for ' + id +
                                            ' failed: ' + e,
                                             e,
                                             [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function () {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function (depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap,
                                               (this.map.isDefine ? this.map : this.map.parentMap),
                                               false,
                                               !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function (depExports) {
                            if (this.undefed) {
                                return;
                            }
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        } else if (this.events.error) {
                            // No direct errback on this module, but something
                            // else is listening for errors, so be sure to
                            // propagate the error correctly.
                            on(depMap, 'error', bind(this, function(err) {
                                this.emit('error', err);
                            }));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function (name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function (name, evt) {
                each(this.events[name], function (cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                        args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
            context.defQueueMap = {};
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            defQueueMap: {},
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function (cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function (value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function (value, prop) {
                        each(value, function (v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function (value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function (pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                     .replace(currDirRegExp, '')
                                     .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function (mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id, null, true);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function (value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function (relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                        id +
                                        '" has not been loaded yet for context: ' +
                                        contextName +
                                        (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function () {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function (moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                                                relMap && relMap.id, true), ext,  true);
                    },

                    defined: function (id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function (id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function (id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        mod.undefed = true;
                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });
                        delete context.defQueueMap[id];

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function (depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function (moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }
                context.defQueueMap = {};

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                             'No define call for ' + moduleName,
                                             null,
                                             [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function (moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                                        ((url.indexOf('?') === -1 ? '?' : '&') +
                                         config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function (id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function (name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function (evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function (evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function (deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function (config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
        setTimeout(fn, 4);
    } : function (fn) { fn(); };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function (prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function () {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function (config, moduleName, url) {
        var node = config.xhtml ?
                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function (context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);
            if (config.onNodeCreated) {
                config.onNodeCreated(node, config, moduleName, url);
            }

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                    !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                                'importScripts failed for ' +
                                    moduleName + ' at ' + url,
                                e,
                                [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function (script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function (script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/')  + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function (name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function (match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        if (context) {
            context.defQueue.push([name, deps, callback]);
            context.defQueueMap[name] = true;
        } else {
            globalDefQueue.push([name, deps, callback]);
        }
    };

    define.amd = {
        jQuery: true
    };

    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function (text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("../node_modules/requirejs/require", function(){});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('debug',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.debug = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":2}],2:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],3:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":1}]},{},[3])(3)
});
/*globals define, debug*/
/*jshint node:true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('js/logger',['debug'], function (_debug) {
    'use strict';
    // Separate namespaces using ',' a leading '-' will disable the namespace.
    // Each part takes a regex.
    //      ex: localStorage.debug = '*,-socket\.io*,-engine\.io*'
    //      will log all but socket.io and engine.io
    function createLogger(name, options) {
        var log = typeof debug === 'undefined' ? _debug(name) : debug(name),
            level,
            levels = {
                silly: 0,
                input: 1,
                verbose: 2,
                prompt: 3,
                debug: 4,
                info: 5,
                data: 6,
                help: 7,
                warn: 8,
                error: 9
            };
        if (!options) {
            throw new Error('options required in logger');
        }
        if (options.hasOwnProperty('level') === false) {
            throw new Error('options.level required in logger');
        }
        level = levels[options.level];
        if (typeof level === 'undefined') {
            level = levels.info;
        }

        log.debug = function () {
            if (log.enabled && level <= levels.debug) {
                if (console.debug) {
                    log.log = console.debug.bind(console);
                } else {
                    log.log = console.log.bind(console);
                }
                log.apply(this, arguments);
            }
        };
        log.info = function () {
            if (log.enabled && level <= levels.info) {
                log.log = console.info.bind(console);
                log.apply(this, arguments);
            }
        };
        log.warn = function () {
            if (log.enabled && level <= levels.warn) {
                log.log = console.warn.bind(console);
                log.apply(this, arguments);
            }
        };
        log.error = function () {
            if (log.enabled && level <= levels.error) {
                log.log = console.error.bind(console);
                log.apply(this, arguments);
            } else {
                console.error.apply(console, arguments);
            }
        };

        log.fork = function (forkName, useForkName) {
            forkName = useForkName ? forkName : name + ':' + forkName;
            return createLogger(forkName, options);
        };

        log.forkWithOptions = function (_name, _options) {
            return createLogger(_name, _options);
        };

        return log;
    }

    function createWithGmeConfig(name, gmeConfig) {
        return createLogger(name, gmeConfig.client.log);
    }

    return {
        create: createLogger,
        createWithGmeConfig: createWithGmeConfig
    };
});
/*globals define*/
/*jshint node:true, browser: true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 * @module Storage
 */

/**
 * @typedef {string} CommitHash - Unique SHA-1 hash for commit object.
 * @example
 * '#5496cf226542fcceccf89056f0d27564abc88c99'
 */

/**
 * @typedef {object} CommitResult
 * @prop {module:Storage~CommitHash} hash - The commitHash for the commit.
 * @prop {string} status - 'SYNCED', 'FORKED', 'CANCELED', undefined
 *
 * @example
 * {
 *   status: 'SYNCED',
 *   hash: '#someHash'
 * }
 * @example
 * {
 *   hash: '<hash from makeCommit with no branch provided>'
 * }
 */

/**
 * @typedef {object} CommitObject
 * @prop {module:Storage~CommitHash} _id - Hash of the commit object, a.k.a commitHash.
 * @prop {module:Core~ObjectHash} root - Hash of the associated root object, a.k.a. rootHash.
 * @prop {module:Storage~CommitHash[]} parents - Commits from where this commit evolved.
 * @prop {number} time - When the commit object was created (new Date()).getTime().
 * @prop {string} message - Commit message.
 * @prop {string[]} updater - Commit message.
 * @prop {string} type - 'commit'
 *
 * @example
 * {
 *   _id: '#5496cf226542fcceccf89056f0d27564abc88c99',
 *   root: '#04009ecd1e68117cd3e9d39c87aadd9ed1ee5cb3',
 *   parents: ['#87d9fd309ec6a5d84776d7731ce1f1ab2790aac2']
 *   updater: ['guest'],
 *   time: 1430169614741,
 *   message: "createChildren({\"/1008889918/1998840078\":\"/1182870936/737997118/1736829087/1966323860\"})",
 *   type: 'commit'
 * }
 */

/**
 * @typedef {object} PatchObject
 * @prop {module:Core~ObjectHash} _id - Hash of the expected result object.
 * @prop {module:Core~ObjectHash} base - Hash of the base object where the patch should be applied.
 * @prop {string} type - 'patch'.
 * @prop {object} patch - The patch instructions (based on [RFC6902]{@link http://tools.ietf.org/html/rfc6902}).
 *
 * @example
 * {
 *   _id: '#5496cf226542fcceccf89056f0d27564abc88c99',
 *   base: '#04009ecd1e68117cd3e9d39c87aadd9ed1ee5cb3',
 *   type: 'patch',
 *   patch: [{op: 'add', path: '/atr/new', value: 'value'}]
 * }
 */

define('common/storage/constants',[], function () {
    'use strict';

    return {
        //Version
        VERSION: '1.1.0',
        // Database related
        MONGO_ID: '_id',
        COMMIT_TYPE: 'commit',
        PROJECT_INFO_ID: '*info*',
        EMPTY_PROJECT_DATA: 'empty',
        PROJECT_ID_SEP: '+',
        PROJECT_DISPLAYED_NAME_SEP: '/',

        // Socket IO
        DATABASE_ROOM: 'database',
        ROOM_DIVIDER: '%',
        CONNECTED: 'CONNECTED',
        DISCONNECTED: 'DISCONNECTED',
        RECONNECTED: 'RECONNECTED',
        INCOMPATIBLE_CONNECTION: 'INCOMPATIBLE_CONNECTION',
        CONNECTION_ERROR: 'CONNECTION_ERROR',

        // Branch commit status - this is the status returned after setting the hash of a branch
        SYNCED: 'SYNCED', // The commitData was inserted in the database and the branchHash updated.
        FORKED: 'FORKED', // The commitData was inserted in the database, but the branchHash NOT updated.
        CANCELED: 'CANCELED', // The commitData was never inserted to the database.
        MERGED: 'MERGED', // The commit was initially forked, but successfully merged.

        BRANCH_STATUS: {
            SYNC: 'SYNC',
            AHEAD_SYNC: 'AHEAD_SYNC',
            AHEAD_NOT_SYNC: 'AHEAD_NOT_SYNC',
            PULLING: 'PULLING',
            MERGING: 'MERGING',
            ERROR: 'ERROR'
        },

        // Events
        JWT_ABOUT_TO_EXPIRE: 'JWT_ABOUT_TO_EXPIRE',
        JWT_EXPIRED: 'JWT_EXPIRED',

        PROJECT_DELETED: 'PROJECT_DELETED',
        PROJECT_CREATED: 'PROJECT_CREATED',

        BRANCH_DELETED: 'BRANCH_DELETED',
        BRANCH_CREATED: 'BRANCH_CREATED',
        BRANCH_HASH_UPDATED: 'BRANCH_HASH_UPDATED',
        TAG_DELETED: 'TAG_DELETED',
        TAG_CREATED: 'TAG_CREATED',
        COMMIT: 'COMMIT',

        BRANCH_UPDATED: 'BRANCH_UPDATED',

        NOTIFICATION: 'NOTIFICATION',
        // Types of notifications
        BRANCH_ROOM_SOCKETS: 'BRANCH_ROOM_SOCKETS',
        PLUGIN_NOTIFICATION: 'PLUGIN_NOTIFICATION',
        ADD_ON_NOTIFICATION: 'ADD_ON_NOTIFICATION',
        CLIENT_STATE_NOTIFICATION: 'CLIENT_STATE_NOTIFICATION'
    };
});

// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define('q',definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {


var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

/*globals define*/
/*jshint browser: true, node:true*/
/**
 * Provides watching-functionality of the database and specific projects.
 * Keeps a state of the registered watchers.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/watchers',['common/storage/constants', 'q'], function (CONSTANTS, Q) {
    'use strict';

    function StorageWatcher(webSocket, logger, gmeConfig) {
        // watcher counters determining when to join/leave a room on the sever
        this.watchers = {
            database: 0,
            projects: {}
        };
        this.webSocket = webSocket;
        this.logger = this.logger || logger.fork('storage');
        this.gmeConfig = gmeConfig;
        this.logger.debug('StorageWatcher ctor');
        this.connected = false;
    }

    StorageWatcher.prototype.watchDatabase = function (eventHandler, callback) {
        var deferred = Q.defer();
        this.logger.debug('watchDatabase - handler added');
        this.webSocket.addEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);
        this.webSocket.addEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);
        this.watchers.database += 1;
        this.logger.debug('Nbr of database watchers:', this.watchers.database);

        if (this.watchers.database === 1) {
            this.logger.debug('First watcher will enter database room.');
            this.webSocket.watchDatabase({join: true}, function (err) {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve();
                }
            });
        } else {
            deferred.resolve();
        }

        return deferred.promise.nodeify(callback);
    };

    StorageWatcher.prototype.unwatchDatabase = function (eventHandler, callback) {
        var deferred = Q.defer();

        this.logger.debug('unwatchDatabase - handler will be removed');
        this.logger.debug('Nbr of database watchers (before removal):', this.watchers.database);
        this.webSocket.removeEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);
        this.webSocket.removeEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);
        this.watchers.database -= 1;

        if (this.watchers.database === 0) {
            this.logger.debug('No more watchers will exit database room.');
            if (this.connected) {
                this.webSocket.watchDatabase({join: false}, function (err) {
                    if (err) {
                        deferred.reject(err);
                    } else {
                        deferred.resolve();
                    }
                });
            } else {
                deferred.resolve();
            }
        } else if (this.watchers.database < 0) {
            this.logger.error('Number of database watchers became negative!');
            deferred.reject(new Error('Number of database watchers became negative!'));
        } else {
            deferred.resolve();
        }

        return deferred.promise.nodeify(callback);
    };

    StorageWatcher.prototype.watchProject = function (projectId, eventHandler, callback) {
        var deferred = Q.defer();

        this.logger.debug('watchProject - handler added for project', projectId);
        this.webSocket.addEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);
        this.webSocket.addEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);
        this.webSocket.addEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);

        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?
        this.watchers.projects[projectId] + 1 : 1;
        this.logger.debug('Nbr of watchers for project:', projectId, this.watchers.projects[projectId]);
        if (this.watchers.projects[projectId] === 1) {
            this.logger.debug('First watcher will enter project room:', projectId);
            this.webSocket.watchProject({projectId: projectId, join: true}, function (err) {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve();
                }
            });
        } else {
            deferred.resolve();
        }

        return deferred.promise.nodeify(callback);
    };

    StorageWatcher.prototype.unwatchProject = function (projectId, eventHandler, callback) {
        var deferred = Q.defer();

        this.logger.debug('unwatchProject - handler will be removed', projectId);
        this.logger.debug('Nbr of database watchers (before removal):', projectId,
            this.watchers.projects[projectId]);
        this.webSocket.removeEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);
        this.webSocket.removeEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);
        this.webSocket.removeEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);

        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?
        this.watchers.projects[projectId] - 1 : -1;
        if (this.watchers.projects[projectId] === 0) {
            this.logger.debug('No more watchers will exit project room:', projectId);
            delete this.watchers.projects[projectId];
            if (this.connected) {
                this.webSocket.watchProject({projectId: projectId, join: false}, function (err) {
                    if (err) {
                        deferred.reject(err);
                    } else {
                        deferred.resolve();
                    }
                });
            } else {
                deferred.resolve();
            }
        } else if (this.watchers.projects[projectId] < 0) {
            this.logger.error('Number of project watchers became negative!:', projectId);
            deferred.reject(new Error('Number of project watchers became negative!'));
        } else {
            deferred.resolve();
        }

        return deferred.promise.nodeify(callback);
    };

    StorageWatcher.prototype._rejoinWatcherRooms = function (callback) {
        var projectId,
            promises = [];

        this.logger.debug('rejoinWatcherRooms');
        if (this.watchers.database > 0) {
            this.logger.debug('Rejoining database room.');
            promises.push(Q.ninvoke(this.webSocket, 'watchDatabase', {join: true}));
        }

        for (projectId in this.watchers.projects) {
            if (this.watchers.projects.hasOwnProperty(projectId) && this.watchers.projects[projectId] > 0) {
                this.logger.debug('Rejoining project room', projectId, this.watchers.projects[projectId]);
                promises.push(Q.ninvoke(this.webSocket, 'watchProject', {projectId: projectId, join: true}));
            }
        }

        return Q.all(promises).nodeify(callback);
    };

    return StorageWatcher;
});
/*globals define*/
/*jshint browser: true, node:true*/
/**
 * TODO: Come up with an appropriate name for this.
 * TODO: Proper implementation needed, e.g. error handling.
 *
 * Provides REST-like functionality of the database.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/simpleapi',['common/storage/storageclasses/watchers'], function (StorageWatcher) {
    'use strict';

    /**
     *
     * @param webSocket
     * @param logger
     * @param gmeConfig
     * @constructor
     * @class
     */
    function StorageSimpleAPI(webSocket, logger, gmeConfig) {
        // watcher counters determining when to join/leave a room on the sever
        this.logger = this.logger || logger.fork('storage');
        StorageWatcher.call(this, webSocket, logger, gmeConfig);
        this.webSocket = webSocket;
        this.gmeConfig = gmeConfig;
        this.logger.debug('StorageSimpleAPI ctor');
    }

    StorageSimpleAPI.prototype = Object.create(StorageWatcher.prototype);
    StorageSimpleAPI.prototype.constructor = StorageSimpleAPI;

    /**
     * Callback for getProjects.
     *
     * @callback StorageSimpleAPI~getProjectsCallback
     * @param {string} err - error string.
     * @param {{object[]} projects - All projects in the database.
     * @example
     * // projects is of the form
     * // [{ name: 'projectId', read: true, write: false, delete: false} ]
     */

    /**
     * Retrieves all the access info for all projects.
     *
     * @param {StorageSimpleAPI~getProjectsCallback} callback
     */
    StorageSimpleAPI.prototype.getProjects = function (options, callback) {
        this.logger.debug('invoking getProjects', {metadata: options});
        this.webSocket.getProjects(options, callback);
    };

    /**
     * Callback for getProjectsAndBranches.
     *
     * @callback StorageSimpleAPI~getProjectsAndBranches
     * @param {string} err - error string.
     * @param {{object[]} projectsWithBranches - Projects the user has at least read-access to.
     * @example
     * // projectsWithBranches is of the form
     * // [{
     * //    name: 'projectId',
     * //    read: true, //will always be true
     * //    write: false,
     * //    delete: false
     * //    branches: {
     * //      master: '#validHash',
     * //      b1: '#validHashtoo'
     * //    }
     * // }]
     */


    StorageSimpleAPI.prototype.getBranches = function (projectId, callback) {
        var data = {
            projectId: projectId
        };
        this.logger.debug('invoking getBranches', {metadata: data});
        this.webSocket.getBranches(data, callback);
    };

    StorageSimpleAPI.prototype.getCommits = function (projectId, before, number, callback) {
        var data = {
            projectId: projectId,
            before: before,
            number: number
        };
        this.logger.debug('invoking getCommits', {metadata: data});
        this.webSocket.getCommits(data, callback);
    };

    StorageSimpleAPI.prototype.getHistory = function (projectId, start, number, callback) {
        var data = {
            projectId: projectId,
            start: start,
            number: number
        };
        this.logger.debug('invoking getHistory', {metadata: data});
        this.webSocket.getHistory(data, callback);
    };

    StorageSimpleAPI.prototype.squashCommits = function (projectId, fromCommit, toCommitOrBranch, msg, callback) {
        var data = {
            projectId: projectId,
            fromCommit: fromCommit,
            toCommitOrBranch: toCommitOrBranch,
            message: msg
        };
        this.logger.debug('invoking squashCommits', {metadata: data});
        this.webSocket.squashCommits(data, callback);
    };

    StorageSimpleAPI.prototype.getTags = function (projectId, callback) {
        var data = {
            projectId: projectId
        };
        this.logger.debug('invoking getTags', {metadata: data});
        this.webSocket.getTags(data, callback);
    };

    StorageSimpleAPI.prototype.getBranchHash = function (projectId, branchName, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName
        };
        this.logger.debug('invoking getBranchHash', {metadata: data});
        this.webSocket.getBranchHash(data, callback);
    };

    StorageSimpleAPI.prototype.getLatestCommitData = function (projectId, branchName, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName
        };
        this.logger.debug('invoking getLatestCommitData', {metadata: data});
        this.webSocket.getLatestCommitData(data, callback);
    };

    StorageSimpleAPI.prototype.getCommonAncestorCommit = function (projectId, commitA, commitB, callback) {
        var data = {
            commitA: commitA,
            commitB: commitB,
            projectId: projectId
        };
        this.logger.debug('invoking getCommonAncestorCommit', {metadata: data});
        this.webSocket.getCommonAncestorCommit(data, callback);
    };

    // Setters
    StorageSimpleAPI.prototype.createProject = function (projectName, ownerId, callback) {
        var self = this,
            data = {
                projectName: projectName,
                ownerId: ownerId
            };

        if (callback === undefined && typeof ownerId === 'function') {
            callback = ownerId;
            data.ownerId = undefined;
        }

        this.logger.debug('invoking createProject', {metadata: data});

        this.webSocket.createProject(data, function (err, projectId) {
            if (err) {
                self.logger.error('cannot create project ', projectName, err);
                callback(err);
                return;
            }
            self.logger.debug('Project created, projectId', projectId);

            callback(err, projectId);
        });
    };

    StorageSimpleAPI.prototype.deleteProject = function (projectId, callback) {
        var data = {
            projectId: projectId
        };
        this.logger.debug('invoking deleteProject', {metadata: data});
        this.webSocket.deleteProject(data, callback);
    };

    StorageSimpleAPI.prototype.transferProject = function (projectId, newOwnerId, callback) {
        var data = {
            projectId: projectId,
            newOwnerId: newOwnerId
        };
        this.logger.debug('invoking transferProject', {metadata: data});
        this.webSocket.transferProject(data, callback);
    };

    StorageSimpleAPI.prototype.duplicateProject = function (projectId, projectName, ownerId, callback) {
        var data = {
            projectId: projectId,
            projectName: projectName,
            ownerId: ownerId
        };

        if (callback === undefined && typeof ownerId === 'function') {
            callback = ownerId;
            data.ownerId = undefined;
        }

        this.logger.debug('invoking duplicateProject', {metadata: data});
        this.webSocket.duplicateProject(data, callback);
    };

    StorageSimpleAPI.prototype.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName,
            newHash: newHash,
            oldHash: oldHash
        };
        this.logger.debug('invoking setBranchHash', {metadata: data});
        this.webSocket.setBranchHash(data, callback);
    };

    StorageSimpleAPI.prototype.createBranch = function (projectId, branchName, newHash, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName,
            newHash: newHash,
            oldHash: ''
        };
        this.logger.debug('invoking createBranch', {metadata: data});
        this.webSocket.setBranchHash(data, callback);
    };

    StorageSimpleAPI.prototype.deleteBranch = function (projectId, branchName, oldHash, callback) {
        var data = {
            projectId: projectId,
            branchName: branchName,
            newHash: '',
            oldHash: oldHash
        };
        this.logger.debug('invoking deleteBranch', {metadata: data});
        this.webSocket.setBranchHash(data, callback);
    };

    StorageSimpleAPI.prototype.createTag = function (projectId, tagName, commitHash, callback) {
        var data = {
            projectId: projectId,
            tagName: tagName,
            commitHash: commitHash
        };
        this.logger.debug('invoking createTag', {metadata: data});
        this.webSocket.createTag(data, callback);
    };

    StorageSimpleAPI.prototype.deleteTag = function (projectId, tagName, callback) {
        var data = {
            projectId: projectId,
            tagName: tagName
        };
        this.logger.debug('invoking deleteTag', {metadata: data});
        this.webSocket.deleteTag(data, callback);
    };

    //temporary simple request and result functions
    StorageSimpleAPI.prototype.simpleRequest = function (parameters, callback) {
        this.logger.debug('invoking simpleRequest', {metadata: parameters});
        this.webSocket.simpleRequest(parameters, callback);
    };

    StorageSimpleAPI.prototype.simpleQuery = function (workerId, parameters, callback) {
        this.logger.debug('invoking simpleQuery; workerId, parameters', workerId, {metadata: parameters});
        this.webSocket.simpleQuery(workerId, parameters, callback);
    };

    StorageSimpleAPI.prototype.sendNotification = function (data, callback) {
        this.logger.debug('invoking sendNotification; ', {metadata: data});
        this.webSocket.sendNotification(data, callback);
    };

    return StorageSimpleAPI;
});
/*globals define*/
/*jshint browser: true, node:true*/
/**
 * Provides functionality (used by the project-cache) for loading objects.
 *
 * To avoid multiple round-trips to the server the loadObject requests are put in a bucket
 * that is loaded when the bucket is full (gmeConfig.storage.loadBucketSize) or when a
 * timeout is triggered (gmeConfig.storage.loadBucketTimer).
 *
 * N.B. when used directly, the user need to make sure that the same object (by hash) is not loaded within in the
 * same bucket, (see the project-cache for example).
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/objectloaders',['common/storage/storageclasses/simpleapi'], function (SimpleAPI) {
    'use strict';

    function StorageObjectLoaders(webSocket, logger, gmeConfig) {
        // watcher counters determining when to join/leave a room on the sever
        this.logger = this.logger || logger.fork('storage');
        SimpleAPI.call(this, webSocket, logger, gmeConfig);
        this.webSocket = webSocket;
        this.gmeConfig = gmeConfig;
        // Bucket for loading objects
        this.loadBucket = [];
        this.loadBucketSize = 0;
        this.loadBucketTimer = null;
        this.logger.debug('StorageObjectLoaders ctor');
    }

    StorageObjectLoaders.prototype = Object.create(SimpleAPI.prototype);
    StorageObjectLoaders.prototype.constructor = StorageObjectLoaders;

    // Getters
    StorageObjectLoaders.prototype.loadObject = function (projectId, hash, callback) {
        var self = this;
        this.logger.debug('loadObject', projectId, hash);

        self.loadBucket.push({projectId: projectId, hash: hash, cb: callback});
        self.loadBucketSize += 1;

        function resetBucketAndLoadObjects() {
            var myBucket = self.loadBucket;
            self.loadBucket = [];
            self.loadBucketTimer = null;
            self.loadBucketSize = 0;
            self.loadObjects(projectId, myBucket);
        }

        if (self.loadBucketSize === 1) {
            self.logger.debug('loadBucket was empty starting timer [ms]', self.gmeConfig.storage.loadBucketTimer);
            self.loadBucketTimer = setTimeout(function () {
                self.logger.debug('loadBucketTimer triggered, bucketSize:', self.loadBucketSize);
                resetBucketAndLoadObjects();
            }, self.gmeConfig.storage.loadBucketTimer);
        }

        if (self.loadBucketSize === self.gmeConfig.storage.loadBucketSize) {
            self.logger.debug('loadBuckSize reached will loadObjects, bucketSize:', self.loadBucketSize);
            clearTimeout(self.loadBucketTimer);
            resetBucketAndLoadObjects();
        }
    };

    StorageObjectLoaders.prototype.loadObjects = function (projectId, hashedObjects) {
        var self = this,
            hashes = {},
            data,
            i;
        for (i = 0; i < hashedObjects.length; i++) {
            hashes[hashedObjects[i].hash] = true;
        }
        hashes = Object.keys(hashes);
        data = {
            hashes: hashes,
            projectId: projectId
        };

        this.webSocket.loadObjects(data, function (err, result) {
            //if (err) {
            //    throw new Error(err);
            //}
            self.logger.debug('loadObjects returned', {metadata: result});
            for (i = 0; i < hashedObjects.length; i++) {
                if (err) {
                    hashedObjects[i].cb(err);
                } else if (typeof result[hashedObjects[i].hash] === 'string') {
                    self.logger.error(result[hashedObjects[i].hash]);
                    hashedObjects[i].cb(new Error(result[hashedObjects[i].hash]));
                } else {
                    hashedObjects[i].cb(err, result[hashedObjects[i].hash]);
                }
            }
        });
    };

    StorageObjectLoaders.prototype.loadPaths = function (projectId, pathsInfo, excludes, callback) {
        var data = {
            projectId: projectId,
            pathsInfo: pathsInfo,
            excludes: excludes
        };

        this.webSocket.loadPaths(data, callback);
    };

    return StorageObjectLoaders;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */


define('common/util/assert',[],function () {
    'use strict';

    var assert = function (cond, msg) {
        if (!cond) {
            var error = new Error(msg || 'ASSERT failed');

            if (typeof TESTING === 'undefined') {
                console.log('Throwing', error.stack);
                console.log();
            }

            throw error;
        }
    };

    return assert;
});

//jshint ignore: start
/* 2012 David Chambers <dc@hashify.me>  */
define('common/util/canon',[], function() {
    var CANON = {},
        keys, map, nativeMap, pad,
        __slice = [].slice,
        __hasProp = {}.hasOwnProperty;


    CANON.stringify = (function() {
        var canonicalize;
        canonicalize = function(value) {
            var pair, _ref;
            switch (Object.prototype.toString.call(value)) {
                case '[object Array]':
                    return ['Array'].concat(__slice.call(map(value, canonicalize)));
                case '[object Date]':
                    return ['Date'].concat(isFinite(+value) ? value.getUTCFullYear() + '-' + pad(value.getUTCMonth() + 1) + '-' + pad(value.getUTCDate()) + 'T' + pad(value.getUTCHours()) + ':' + pad(value.getUTCMinutes()) + ':' + pad(value.getUTCSeconds()) + '.' + pad(value.getUTCMilliseconds(), 3) + 'Z' : null);
                case '[object Function]':
                    throw new TypeError('functions cannot be serialized');
                    break;
                case '[object Number]':
                    if (isFinite(value)) {
                        return value;
                    } else {
                        return ['Number', "" + value];
                    }
                    break;
                case '[object Object]':
                    pair = function(key) {
                        return [key, canonicalize(value[key])];
                    };
                    return (_ref = ['Object']).concat.apply(_ref, map(keys(value).sort(), pair));
                case '[object RegExp]':
                    return ['RegExp', "" + value];
                case '[object Undefined]':
                    return ['Undefined'];
                default:
                    return value;
            }
        };
        return function(value) {
            return JSON.stringify(canonicalize(value));
        };
    })();

    CANON.parse = (function() {
        var canonicalize;
        canonicalize = function(value) {
            var element, elements, idx, object, what, _i, _ref;
            if (Object.prototype.toString.call(value) !== '[object Array]') {
                return value;
            }
            what = value[0], elements = 2 <= value.length ? __slice.call(value, 1) : [];
            element = elements[0];
            switch (what) {
                case 'Array':
                    return map(elements, canonicalize);
                case 'Date':
                    return new Date(element);
                case 'Number':
                    return +element;
                case 'Object':
                    object = {};
                    for (idx = _i = 0, _ref = elements.length; _i < _ref; idx = _i += 2) {
                        object[elements[idx]] = canonicalize(elements[idx + 1]);
                    }
                    return object;
                case 'RegExp':
                    return (function(func, args, ctor) {
                        ctor.prototype = func.prototype;
                        var child = new ctor, result = func.apply(child, args);
                        return Object(result) === result ? result : child;
                    })(RegExp, /^[/](.+)[/]([gimy]*)$/.exec(element).slice(1), function(){});
                case 'Undefined':
                    return void 0;
                default:
                    throw new Error('invalid input');
            }
        };
        return function(string) {
            return canonicalize(JSON.parse(string));
        };
    })();

    nativeMap = Array.prototype.map;

    map = function(array, iterator) {
        var el, _i, _len, _results;
        if (nativeMap && array.map === nativeMap) {
            return array.map(iterator);
        } else {
            _results = [];
            for (_i = 0, _len = array.length; _i < _len; _i++) {
                el = array[_i];
                _results.push(iterator(el));
            }
            return _results;
        }
    };

    keys = Object.keys || function(object) {
        var key, _results;
        _results = [];
        for (key in object) {
            if (!__hasProp.call(object, key)) continue;
            _results.push(key);
        }
        return _results;
    };

    pad = function(n, min) {
        if (min == null) {
            min = 2;
        }
        return ("" + (1000 + n)).substr(4 - min);
    };

    return CANON;

});

//  Chance.js 1.0.3
//  http://chancejs.com
//  (c) 2013 Victor Quinn
//  Chance may be freely distributed or modified under the MIT license.

(function () {

    // Constants
    var MAX_INT = 9007199254740992;
    var MIN_INT = -MAX_INT;
    var NUMBERS = '0123456789';
    var CHARS_LOWER = 'abcdefghijklmnopqrstuvwxyz';
    var CHARS_UPPER = CHARS_LOWER.toUpperCase();
    var HEX_POOL  = NUMBERS + "abcdef";

    // Cached array helpers
    var slice = Array.prototype.slice;

    // Constructor
    function Chance (seed) {
        if (!(this instanceof Chance)) {
            return seed == null ? new Chance() : new Chance(seed);
        }

        // if user has provided a function, use that as the generator
        if (typeof seed === 'function') {
            this.random = seed;
            return this;
        }

        if (arguments.length) {
            // set a starting value of zero so we can add to it
            this.seed = 0;
        }

        // otherwise, leave this.seed blank so that MT will receive a blank

        for (var i = 0; i < arguments.length; i++) {
            var seedling = 0;
            if (Object.prototype.toString.call(arguments[i]) === '[object String]') {
                for (var j = 0; j < arguments[i].length; j++) {
                    // create a numeric hash for each argument, add to seedling
                    var hash = 0;
                    for (var k = 0; k < arguments[i].length; k++) {
                        hash = arguments[i].charCodeAt(k) + (hash << 6) + (hash << 16) - hash;
                    }
                    seedling += hash;
                }
            } else {
                seedling = arguments[i];
            }
            this.seed += (arguments.length - i) * seedling;
        }

        // If no generator function was provided, use our MT
        this.mt = this.mersenne_twister(this.seed);
        this.bimd5 = this.blueimp_md5();
        this.random = function () {
            return this.mt.random(this.seed);
        };

        return this;
    }

    Chance.prototype.VERSION = "1.0.3";

    // Random helper functions
    function initOptions(options, defaults) {
        options || (options = {});

        if (defaults) {
            for (var i in defaults) {
                if (typeof options[i] === 'undefined') {
                    options[i] = defaults[i];
                }
            }
        }

        return options;
    }

    function testRange(test, errorMessage) {
        if (test) {
            throw new RangeError(errorMessage);
        }
    }

    /**
     * Encode the input string with Base64.
     */
    var base64 = function() {
        throw new Error('No Base64 encoder available.');
    };

    // Select proper Base64 encoder.
    (function determineBase64Encoder() {
        if (typeof btoa === 'function') {
            base64 = btoa;
        } else if (typeof Buffer === 'function') {
            base64 = function(input) {
                return new Buffer(input).toString('base64');
            };
        }
    })();

    // -- Basics --

    /**
     *  Return a random bool, either true or false
     *
     *  @param {Object} [options={ likelihood: 50 }] alter the likelihood of
     *    receiving a true or false value back.
     *  @throws {RangeError} if the likelihood is out of bounds
     *  @returns {Bool} either true or false
     */
    Chance.prototype.bool = function (options) {
        // likelihood of success (true)
        options = initOptions(options, {likelihood : 50});

        // Note, we could get some minor perf optimizations by checking range
        // prior to initializing defaults, but that makes code a bit messier
        // and the check more complicated as we have to check existence of
        // the object then existence of the key before checking constraints.
        // Since the options initialization should be minor computationally,
        // decision made for code cleanliness intentionally. This is mentioned
        // here as it's the first occurrence, will not be mentioned again.
        testRange(
            options.likelihood < 0 || options.likelihood > 100,
            "Chance: Likelihood accepts values from 0 to 100."
        );

        return this.random() * 100 < options.likelihood;
    };

    /**
     *  Return a random character.
     *
     *  @param {Object} [options={}] can specify a character pool, only alpha,
     *    only symbols, and casing (lower or upper)
     *  @returns {String} a single random character
     *  @throws {RangeError} Can only specify alpha or symbols, not both
     */
    Chance.prototype.character = function (options) {
        options = initOptions(options);
        testRange(
            options.alpha && options.symbols,
            "Chance: Cannot specify both alpha and symbols."
        );

        var symbols = "!@#$%^&*()[]",
            letters, pool;

        if (options.casing === 'lower') {
            letters = CHARS_LOWER;
        } else if (options.casing === 'upper') {
            letters = CHARS_UPPER;
        } else {
            letters = CHARS_LOWER + CHARS_UPPER;
        }

        if (options.pool) {
            pool = options.pool;
        } else if (options.alpha) {
            pool = letters;
        } else if (options.symbols) {
            pool = symbols;
        } else {
            pool = letters + NUMBERS + symbols;
        }

        return pool.charAt(this.natural({max: (pool.length - 1)}));
    };

    // Note, wanted to use "float" or "double" but those are both JS reserved words.

    // Note, fixed means N OR LESS digits after the decimal. This because
    // It could be 14.9000 but in JavaScript, when this is cast as a number,
    // the trailing zeroes are dropped. Left to the consumer if trailing zeroes are
    // needed
    /**
     *  Return a random floating point number
     *
     *  @param {Object} [options={}] can specify a fixed precision, min, max
     *  @returns {Number} a single floating point number
     *  @throws {RangeError} Can only specify fixed or precision, not both. Also
     *    min cannot be greater than max
     */
    Chance.prototype.floating = function (options) {
        options = initOptions(options, {fixed : 4});
        testRange(
            options.fixed && options.precision,
            "Chance: Cannot specify both fixed and precision."
        );

        var num;
        var fixed = Math.pow(10, options.fixed);

        var max = MAX_INT / fixed;
        var min = -max;

        testRange(
            options.min && options.fixed && options.min < min,
            "Chance: Min specified is out of range with fixed. Min should be, at least, " + min
        );
        testRange(
            options.max && options.fixed && options.max > max,
            "Chance: Max specified is out of range with fixed. Max should be, at most, " + max
        );

        options = initOptions(options, { min : min, max : max });

        // Todo - Make this work!
        // options.precision = (typeof options.precision !== "undefined") ? options.precision : false;

        num = this.integer({min: options.min * fixed, max: options.max * fixed});
        var num_fixed = (num / fixed).toFixed(options.fixed);

        return parseFloat(num_fixed);
    };

    /**
     *  Return a random integer
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.integer({min: 1, max: 3});
     *  would return either 1, 2, or 3.
     *
     *  @param {Object} [options={}] can specify a min and/or max
     *  @returns {Number} a single random integer number
     *  @throws {RangeError} min cannot be greater than max
     */
    Chance.prototype.integer = function (options) {
        // 9007199254740992 (2^53) is the max integer number in JavaScript
        // See: http://vq.io/132sa2j
        options = initOptions(options, {min: MIN_INT, max: MAX_INT});
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
    };

    /**
     *  Return a random natural
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.natural({min: 1, max: 3});
     *  would return either 1, 2, or 3.
     *
     *  @param {Object} [options={}] can specify a min and/or max
     *  @returns {Number} a single random integer number
     *  @throws {RangeError} min cannot be greater than max
     */
    Chance.prototype.natural = function (options) {
        options = initOptions(options, {min: 0, max: MAX_INT});
        testRange(options.min < 0, "Chance: Min cannot be less than zero.");
        return this.integer(options);
    };

    /**
     *  Return a random string
     *
     *  @param {Object} [options={}] can specify a length
     *  @returns {String} a string of random length
     *  @throws {RangeError} length cannot be less than zero
     */
    Chance.prototype.string = function (options) {
        options = initOptions(options, { length: this.natural({min: 5, max: 20}) });
        testRange(options.length < 0, "Chance: Length cannot be less than zero.");
        var length = options.length,
            text = this.n(this.character, length, options);

        return text.join("");
    };

    // -- End Basics --

    // -- Helpers --

    Chance.prototype.capitalize = function (word) {
        return word.charAt(0).toUpperCase() + word.substr(1);
    };

    Chance.prototype.mixin = function (obj) {
        for (var func_name in obj) {
            Chance.prototype[func_name] = obj[func_name];
        }
        return this;
    };

    /**
     *  Given a function that generates something random and a number of items to generate,
     *    return an array of items where none repeat.
     *
     *  @param {Function} fn the function that generates something random
     *  @param {Number} num number of terms to generate
     *  @param {Object} options any options to pass on to the generator function
     *  @returns {Array} an array of length `num` with every item generated by `fn` and unique
     *
     *  There can be more parameters after these. All additional parameters are provided to the given function
     */
    Chance.prototype.unique = function(fn, num, options) {
        testRange(
            typeof fn !== "function",
            "Chance: The first argument must be a function."
        );

        var comparator = function(arr, val) { return arr.indexOf(val) !== -1; };

        if (options) {
            comparator = options.comparator || comparator;
        }

        var arr = [], count = 0, result, MAX_DUPLICATES = num * 50, params = slice.call(arguments, 2);

        while (arr.length < num) {
            var clonedParams = JSON.parse(JSON.stringify(params));
            result = fn.apply(this, clonedParams);
            if (!comparator(arr, result)) {
                arr.push(result);
                // reset count when unique found
                count = 0;
            }

            if (++count > MAX_DUPLICATES) {
                throw new RangeError("Chance: num is likely too large for sample set");
            }
        }
        return arr;
    };

    /**
     *  Gives an array of n random terms
     *
     *  @param {Function} fn the function that generates something random
     *  @param {Number} n number of terms to generate
     *  @returns {Array} an array of length `n` with items generated by `fn`
     *
     *  There can be more parameters after these. All additional parameters are provided to the given function
     */
    Chance.prototype.n = function(fn, n) {
        testRange(
            typeof fn !== "function",
            "Chance: The first argument must be a function."
        );

        if (typeof n === 'undefined') {
            n = 1;
        }
        var i = n, arr = [], params = slice.call(arguments, 2);

        // Providing a negative count should result in a noop.
        i = Math.max( 0, i );

        for (null; i--; null) {
            arr.push(fn.apply(this, params));
        }

        return arr;
    };

    // H/T to SO for this one: http://vq.io/OtUrZ5
    Chance.prototype.pad = function (number, width, pad) {
        // Default pad to 0 if none provided
        pad = pad || '0';
        // Convert number to a string
        number = number + '';
        return number.length >= width ? number : new Array(width - number.length + 1).join(pad) + number;
    };

    // DEPRECATED on 2015-10-01
    Chance.prototype.pick = function (arr, count) {
        if (arr.length === 0) {
            throw new RangeError("Chance: Cannot pick() from an empty array");
        }
        if (!count || count === 1) {
            return arr[this.natural({max: arr.length - 1})];
        } else {
            return this.shuffle(arr).slice(0, count);
        }
    };

    // Given an array, returns a single random element
    Chance.prototype.pickone = function (arr) {
        if (arr.length === 0) {
          throw new RangeError("Chance: Cannot pickone() from an empty array");
        }
        return arr[this.natural({max: arr.length - 1})];
    };

    // Given an array, returns a random set with 'count' elements
    Chance.prototype.pickset = function (arr, count) {
        if (count === 0) {
            return [];
        }
        if (arr.length === 0) {
            throw new RangeError("Chance: Cannot pickset() from an empty array");
        }
        if (count < 0) {
            throw new RangeError("Chance: count must be positive number");
        }
        if (!count || count === 1) {
            return [ this.pickone(arr) ];
        } else {
            return this.shuffle(arr).slice(0, count);
        }
    };

    Chance.prototype.shuffle = function (arr) {
        var old_array = arr.slice(0),
            new_array = [],
            j = 0,
            length = Number(old_array.length);

        for (var i = 0; i < length; i++) {
            // Pick a random index from the array
            j = this.natural({max: old_array.length - 1});
            // Add it to the new array
            new_array[i] = old_array[j];
            // Remove that element from the original array
            old_array.splice(j, 1);
        }

        return new_array;
    };

    // Returns a single item from an array with relative weighting of odds
    Chance.prototype.weighted = function (arr, weights, trim) {
        if (arr.length !== weights.length) {
            throw new RangeError("Chance: length of array and weights must match");
        }

        // scan weights array and sum valid entries
        var sum = 0;
        var val;
        for (var weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
            val = weights[weightIndex];
            if (val > 0) {
                sum += val;
            }
        }

        if (sum === 0) {
            throw new RangeError("Chance: no valid entries in array weights");
        }

        // select a value within range
        var selected = this.random() * sum;

        // find array entry corresponding to selected value
        var total = 0;
        var lastGoodIdx = -1;
        var chosenIdx;
        for (weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
            val = weights[weightIndex];
            total += val;
            if (val > 0) {
                if (selected <= total) {
                    chosenIdx = weightIndex;
                    break;
                }
                lastGoodIdx = weightIndex;
            }

            // handle any possible rounding error comparison to ensure something is picked
            if (weightIndex === (weights.length - 1)) {
                chosenIdx = lastGoodIdx;
            }
        }

        var chosen = arr[chosenIdx];
        trim = (typeof trim === 'undefined') ? false : trim;
        if (trim) {
            arr.splice(chosenIdx, 1);
            weights.splice(chosenIdx, 1);
        }

        return chosen;
    };

    // -- End Helpers --

    // -- Text --

    Chance.prototype.paragraph = function (options) {
        options = initOptions(options);

        var sentences = options.sentences || this.natural({min: 3, max: 7}),
            sentence_array = this.n(this.sentence, sentences);

        return sentence_array.join(' ');
    };

    // Could get smarter about this than generating random words and
    // chaining them together. Such as: http://vq.io/1a5ceOh
    Chance.prototype.sentence = function (options) {
        options = initOptions(options);

        var words = options.words || this.natural({min: 12, max: 18}),
            punctuation = options.punctuation,
            text, word_array = this.n(this.word, words);

        text = word_array.join(' ');
        
        // Capitalize first letter of sentence
        text = this.capitalize(text);
        
        // Make sure punctuation has a usable value
        if (punctuation !== false && !/^[\.\?;!:]$/.test(punctuation)) {
            punctuation = '.';
        }
        
        // Add punctuation mark
        if (punctuation) {
            text += punctuation;
        }

        return text;
    };

    Chance.prototype.syllable = function (options) {
        options = initOptions(options);

        var length = options.length || this.natural({min: 2, max: 3}),
            consonants = 'bcdfghjklmnprstvwz', // consonants except hard to speak ones
            vowels = 'aeiou', // vowels
            all = consonants + vowels, // all
            text = '',
            chr;

        // I'm sure there's a more elegant way to do this, but this works
        // decently well.
        for (var i = 0; i < length; i++) {
            if (i === 0) {
                // First character can be anything
                chr = this.character({pool: all});
            } else if (consonants.indexOf(chr) === -1) {
                // Last character was a vowel, now we want a consonant
                chr = this.character({pool: consonants});
            } else {
                // Last character was a consonant, now we want a vowel
                chr = this.character({pool: vowels});
            }

            text += chr;
        }

        if (options.capitalize) {
            text = this.capitalize(text);
        }

        return text;
    };

    Chance.prototype.word = function (options) {
        options = initOptions(options);

        testRange(
            options.syllables && options.length,
            "Chance: Cannot specify both syllables AND length."
        );

        var syllables = options.syllables || this.natural({min: 1, max: 3}),
            text = '';

        if (options.length) {
            // Either bound word by length
            do {
                text += this.syllable();
            } while (text.length < options.length);
            text = text.substring(0, options.length);
        } else {
            // Or by number of syllables
            for (var i = 0; i < syllables; i++) {
                text += this.syllable();
            }
        }

        if (options.capitalize) {
            text = this.capitalize(text);
        }

        return text;
    };

    // -- End Text --

    // -- Person --

    Chance.prototype.age = function (options) {
        options = initOptions(options);
        var ageRange;

        switch (options.type) {
            case 'child':
                ageRange = {min: 1, max: 12};
                break;
            case 'teen':
                ageRange = {min: 13, max: 19};
                break;
            case 'adult':
                ageRange = {min: 18, max: 65};
                break;
            case 'senior':
                ageRange = {min: 65, max: 100};
                break;
            case 'all':
                ageRange = {min: 1, max: 100};
                break;
            default:
                ageRange = {min: 18, max: 65};
                break;
        }

        return this.natural(ageRange);
    };

    Chance.prototype.birthday = function (options) {
        options = initOptions(options, {
            year: (new Date().getFullYear() - this.age(options))
        });

        return this.date(options);
    };

    // CPF; ID to identify taxpayers in Brazil
    Chance.prototype.cpf = function () {
        var n = this.n(this.natural, 9, { max: 9 });
        var d1 = n[8]*2+n[7]*3+n[6]*4+n[5]*5+n[4]*6+n[3]*7+n[2]*8+n[1]*9+n[0]*10;
        d1 = 11 - (d1 % 11);
        if (d1>=10) {
            d1 = 0;
        }
        var d2 = d1*2+n[8]*3+n[7]*4+n[6]*5+n[5]*6+n[4]*7+n[3]*8+n[2]*9+n[1]*10+n[0]*11;
        d2 = 11 - (d2 % 11);
        if (d2>=10) {
            d2 = 0;
        }
        return ''+n[0]+n[1]+n[2]+'.'+n[3]+n[4]+n[5]+'.'+n[6]+n[7]+n[8]+'-'+d1+d2;
    };

    // CNPJ: ID to identify companies in Brazil
    Chance.prototype.cnpj = function () {
        var n = this.n(this.natural, 12, { max: 12 });
        var d1 = n[11]*2+n[10]*3+n[9]*4+n[8]*5+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
        d1 = 11 - (d1 % 11);
        if (d1<2) {
            d1 = 0;
        }
        var d2 = d1*2+n[11]*3+n[10]*4+n[9]*5+n[8]*6+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
        d2 = 11 - (d2 % 11);
        if (d2<2) {
            d2 = 0;
        }
        return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/'+n[8]+n[9]+n[10]+n[11]+'-'+d1+d2;
    };

    Chance.prototype.first = function (options) {
        options = initOptions(options, {gender: this.gender(), nationality: 'en'});
        return this.pick(this.get("firstNames")[options.gender.toLowerCase()][options.nationality.toLowerCase()]);
    };

    Chance.prototype.gender = function () {
        return this.pick(['Male', 'Female']);
    };

    Chance.prototype.last = function (options) {
        options = initOptions(options, {nationality: 'en'});
        return this.pick(this.get("lastNames")[options.nationality.toLowerCase()]);
    };
    
    Chance.prototype.israelId=function(){
        var x=this.string({pool: '0123456789',length:8});
        var y=0;
        for (var i=0;i<x.length;i++){
            var thisDigit=  x[i] *  (i/2===parseInt(i/2) ? 1 : 2);
            thisDigit=this.pad(thisDigit,2).toString();
            thisDigit=parseInt(thisDigit[0]) + parseInt(thisDigit[1]);
            y=y+thisDigit;
        }
        x=x+(10-parseInt(y.toString().slice(-1))).toString().slice(-1);
        return x;
    };

    Chance.prototype.mrz = function (options) {
        var checkDigit = function (input) {
            var alpha = "<ABCDEFGHIJKLMNOPQRSTUVWXYXZ".split(''),
                multipliers = [ 7, 3, 1 ],
                runningTotal = 0;

            if (typeof input !== 'string') {
                input = input.toString();
            }

            input.split('').forEach(function(character, idx) {
                var pos = alpha.indexOf(character);

                if(pos !== -1) {
                    character = pos === 0 ? 0 : pos + 9;
                } else {
                    character = parseInt(character, 10);
                }
                character *= multipliers[idx % multipliers.length];
                runningTotal += character;
            });
            return runningTotal % 10;
        };
        var generate = function (opts) {
            var pad = function (length) {
                return new Array(length + 1).join('<');
            };
            var number = [ 'P<',
                           opts.issuer,
                           opts.last.toUpperCase(),
                           '<<',
                           opts.first.toUpperCase(),
                           pad(39 - (opts.last.length + opts.first.length + 2)),
                           opts.passportNumber,
                           checkDigit(opts.passportNumber),
                           opts.nationality,
                           opts.dob,
                           checkDigit(opts.dob),
                           opts.gender,
                           opts.expiry,
                           checkDigit(opts.expiry),
                           pad(14),
                           checkDigit(pad(14)) ].join('');

            return number +
                (checkDigit(number.substr(44, 10) +
                            number.substr(57, 7) +
                            number.substr(65, 7)));
        };

        var that = this;

        options = initOptions(options, {
            first: this.first(),
            last: this.last(),
            passportNumber: this.integer({min: 100000000, max: 999999999}),
            dob: (function () {
                var date = that.birthday({type: 'adult'});
                return [date.getFullYear().toString().substr(2),
                        that.pad(date.getMonth() + 1, 2),
                        that.pad(date.getDate(), 2)].join('');
            }()),
            expiry: (function () {
                var date = new Date();
                return [(date.getFullYear() + 5).toString().substr(2),
                        that.pad(date.getMonth() + 1, 2),
                        that.pad(date.getDate(), 2)].join('');
            }()),
            gender: this.gender() === 'Female' ? 'F': 'M',
            issuer: 'GBR',
            nationality: 'GBR'
        });
        return generate (options);
    };

    Chance.prototype.name = function (options) {
        options = initOptions(options);

        var first = this.first(options),
            last = this.last(options),
            name;

        if (options.middle) {
            name = first + ' ' + this.first(options) + ' ' + last;
        } else if (options.middle_initial) {
            name = first + ' ' + this.character({alpha: true, casing: 'upper'}) + '. ' + last;
        } else {
            name = first + ' ' + last;
        }

        if (options.prefix) {
            name = this.prefix(options) + ' ' + name;
        }

        if (options.suffix) {
            name = name + ' ' + this.suffix(options);
        }

        return name;
    };

    // Return the list of available name prefixes based on supplied gender.
    // @todo introduce internationalization
    Chance.prototype.name_prefixes = function (gender) {
        gender = gender || "all";
        gender = gender.toLowerCase();

        var prefixes = [
            { name: 'Doctor', abbreviation: 'Dr.' }
        ];

        if (gender === "male" || gender === "all") {
            prefixes.push({ name: 'Mister', abbreviation: 'Mr.' });
        }

        if (gender === "female" || gender === "all") {
            prefixes.push({ name: 'Miss', abbreviation: 'Miss' });
            prefixes.push({ name: 'Misses', abbreviation: 'Mrs.' });
        }

        return prefixes;
    };

    // Alias for name_prefix
    Chance.prototype.prefix = function (options) {
        return this.name_prefix(options);
    };

    Chance.prototype.name_prefix = function (options) {
        options = initOptions(options, { gender: "all" });
        return options.full ?
            this.pick(this.name_prefixes(options.gender)).name :
            this.pick(this.name_prefixes(options.gender)).abbreviation;
    };

    Chance.prototype.ssn = function (options) {
        options = initOptions(options, {ssnFour: false, dashes: true});
        var ssn_pool = "1234567890",
            ssn,
            dash = options.dashes ? '-' : '';

        if(!options.ssnFour) {
            ssn = this.string({pool: ssn_pool, length: 3}) + dash +
            this.string({pool: ssn_pool, length: 2}) + dash +
            this.string({pool: ssn_pool, length: 4});
        } else {
            ssn = this.string({pool: ssn_pool, length: 4});
        }
        return ssn;
    };

    // Return the list of available name suffixes
    // @todo introduce internationalization
    Chance.prototype.name_suffixes = function () {
        var suffixes = [
            { name: 'Doctor of Osteopathic Medicine', abbreviation: 'D.O.' },
            { name: 'Doctor of Philosophy', abbreviation: 'Ph.D.' },
            { name: 'Esquire', abbreviation: 'Esq.' },
            { name: 'Junior', abbreviation: 'Jr.' },
            { name: 'Juris Doctor', abbreviation: 'J.D.' },
            { name: 'Master of Arts', abbreviation: 'M.A.' },
            { name: 'Master of Business Administration', abbreviation: 'M.B.A.' },
            { name: 'Master of Science', abbreviation: 'M.S.' },
            { name: 'Medical Doctor', abbreviation: 'M.D.' },
            { name: 'Senior', abbreviation: 'Sr.' },
            { name: 'The Third', abbreviation: 'III' },
            { name: 'The Fourth', abbreviation: 'IV' },
            { name: 'Bachelor of Engineering', abbreviation: 'B.E' },
            { name: 'Bachelor of Technology', abbreviation: 'B.TECH' }
        ];
        return suffixes;
    };

    // Alias for name_suffix
    Chance.prototype.suffix = function (options) {
        return this.name_suffix(options);
    };

    Chance.prototype.name_suffix = function (options) {
        options = initOptions(options);
        return options.full ?
            this.pick(this.name_suffixes()).name :
            this.pick(this.name_suffixes()).abbreviation;
    };

    Chance.prototype.nationalities = function () {
        return this.get("nationalities");
    };

    // Generate random nationality based on json list
    Chance.prototype.nationality = function () {
        var nationality = this.pick(this.nationalities());
        return nationality.name;
    };

    // -- End Person --

    // -- Mobile --
    // Android GCM Registration ID
    Chance.prototype.android_id = function () {
        return "APA91" + this.string({ pool: "0123456789abcefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_", length: 178 });
    };

    // Apple Push Token
    Chance.prototype.apple_token = function () {
        return this.string({ pool: "abcdef1234567890", length: 64 });
    };

    // Windows Phone 8 ANID2
    Chance.prototype.wp8_anid2 = function () {
        return base64( this.hash( { length : 32 } ) );
    };

    // Windows Phone 7 ANID
    Chance.prototype.wp7_anid = function () {
        return 'A=' + this.guid().replace(/-/g, '').toUpperCase() + '&E=' + this.hash({ length:3 }) + '&W=' + this.integer({ min:0, max:9 });
    };

    // BlackBerry Device PIN
    Chance.prototype.bb_pin = function () {
        return this.hash({ length: 8 });
    };

    // -- End Mobile --

    // -- Web --
    Chance.prototype.avatar = function (options) {
        var url = null;
        var URL_BASE = '//www.gravatar.com/avatar/';
        var PROTOCOLS = {
            http: 'http',
            https: 'https'
        };
        var FILE_TYPES = {
            bmp: 'bmp',
            gif: 'gif',
            jpg: 'jpg',
            png: 'png'
        };
        var FALLBACKS = {
            '404': '404', // Return 404 if not found
            mm: 'mm', // Mystery man
            identicon: 'identicon', // Geometric pattern based on hash
            monsterid: 'monsterid', // A generated monster icon
            wavatar: 'wavatar', // A generated face
            retro: 'retro', // 8-bit icon
            blank: 'blank' // A transparent png
        };
        var RATINGS = {
            g: 'g',
            pg: 'pg',
            r: 'r',
            x: 'x'
        };
        var opts = {
            protocol: null,
            email: null,
            fileExtension: null,
            size: null,
            fallback: null,
            rating: null
        };

        if (!options) {
            // Set to a random email
            opts.email = this.email();
            options = {};
        }
        else if (typeof options === 'string') {
            opts.email = options;
            options = {};
        }
        else if (typeof options !== 'object') {
            return null;
        }
        else if (options.constructor === 'Array') {
            return null;
        }

        opts = initOptions(options, opts);

        if (!opts.email) {
            // Set to a random email
            opts.email = this.email();
        }

        // Safe checking for params
        opts.protocol = PROTOCOLS[opts.protocol] ? opts.protocol + ':' : '';
        opts.size = parseInt(opts.size, 0) ? opts.size : '';
        opts.rating = RATINGS[opts.rating] ? opts.rating : '';
        opts.fallback = FALLBACKS[opts.fallback] ? opts.fallback : '';
        opts.fileExtension = FILE_TYPES[opts.fileExtension] ? opts.fileExtension : '';

        url =
            opts.protocol +
            URL_BASE +
            this.bimd5.md5(opts.email) +
            (opts.fileExtension ? '.' + opts.fileExtension : '') +
            (opts.size || opts.rating || opts.fallback ? '?' : '') +
            (opts.size ? '&s=' + opts.size.toString() : '') +
            (opts.rating ? '&r=' + opts.rating : '') +
            (opts.fallback ? '&d=' + opts.fallback : '')
            ;

        return url;
    };

    /**
     * #Description:
     * ===============================================
     * Generate random color value base on color type:
     * -> hex
     * -> rgb
     * -> rgba
     * -> 0x
     * -> named color
     *
     * #Examples: 
     * ===============================================
     * * Geerate random hex color
     * chance.color() => '#79c157' / 'rgb(110,52,164)' / '0x67ae0b' / '#e2e2e2' / '#29CFA7'
     * 
     * * Generate Hex based color value
     * chance.color({format: 'hex'})    => '#d67118'
     *
     * * Generate simple rgb value
     * chance.color({format: 'rgb'})    => 'rgb(110,52,164)'
     *
     * * Generate Ox based color value
     * chance.color({format: '0x'})     => '0x67ae0b' 
     *
     * * Generate graiscale based value
     * chance.color({grayscale: true})  => '#e2e2e2'
     *
     * * Return valide color name
     * chance.color({format: 'name'})   => 'red'
     * 
     * * Make color uppercase
     * chance.color({casing: 'upper'})  => '#29CFA7'
     *
     * @param  [object] options
     * @return [string] color value
     */
    Chance.prototype.color = function (options) {

        function gray(value, delimiter) {
            return [value, value, value].join(delimiter || '');
        }

        function rgb(hasAlpha) {

            var rgbValue    = (hasAlpha)    ? 'rgba' : 'rgb'; 
            var alphaChanal = (hasAlpha)    ? (',' + this.floating({min:0, max:1})) : "";
            var colorValue  = (isGrayscale) ? (gray(this.natural({max: 255}), ',')) : (this.natural({max: 255}) + ',' + this.natural({max: 255}) + ',' + this.natural({max: 255}));

            return rgbValue + '(' + colorValue + alphaChanal + ')';
        }

        function hex(start, end, withHash) {

            var simbol = (withHash) ? "#" : "";
            var expression  = (isGrayscale ? gray(this.hash({length: start})) : this.hash({length: end})); 
            return simbol + expression;
        }

        options = initOptions(options, {
            format: this.pick(['hex', 'shorthex', 'rgb', 'rgba', '0x', 'name']),
            grayscale: false,
            casing: 'lower'
        });

        var isGrayscale = options.grayscale;
        var colorValue;

        if (options.format === 'hex') {
            colorValue =  hex.call(this, 2, 6, true);
        }
        else if (options.format === 'shorthex') {
            colorValue = hex.call(this, 1, 3, true);
        } 
        else if (options.format === 'rgb') {
            colorValue = rgb.call(this, false);
        } 
        else if (options.format === 'rgba') {
            colorValue = rgb.call(this, true);
        } 
        else if (options.format === '0x') {
            colorValue = '0x' + hex.call(this, 2, 6);
        } 
        else if(options.format === 'name') {
            return this.pick(this.get("colorNames"));
        }
        else {
            throw new RangeError('Invalid format provided. Please provide one of "hex", "shorthex", "rgb", "rgba", "0x" or "name".');
        }

        if (options.casing === 'upper' ) {
            colorValue = colorValue.toUpperCase();
        }

        return colorValue;
    };

    Chance.prototype.domain = function (options) {
        options = initOptions(options);
        return this.word() + '.' + (options.tld || this.tld());
    };

    Chance.prototype.email = function (options) {
        options = initOptions(options);
        return this.word({length: options.length}) + '@' + (options.domain || this.domain());
    };

    Chance.prototype.fbid = function () {
        return parseInt('10000' + this.natural({max: 100000000000}), 10);
    };

    Chance.prototype.google_analytics = function () {
        var account = this.pad(this.natural({max: 999999}), 6);
        var property = this.pad(this.natural({max: 99}), 2);

        return 'UA-' + account + '-' + property;
    };

    Chance.prototype.hashtag = function () {
        return '#' + this.word();
    };

    Chance.prototype.ip = function () {
        // Todo: This could return some reserved IPs. See http://vq.io/137dgYy
        // this should probably be updated to account for that rare as it may be
        return this.natural({min: 1, max: 254}) + '.' +
               this.natural({max: 255}) + '.' +
               this.natural({max: 255}) + '.' +
               this.natural({min: 1, max: 254});
    };

    Chance.prototype.ipv6 = function () {
        var ip_addr = this.n(this.hash, 8, {length: 4});

        return ip_addr.join(":");
    };

    Chance.prototype.klout = function () {
        return this.natural({min: 1, max: 99});
    };

    Chance.prototype.semver = function (options) {
        options = initOptions(options, { include_prerelease: true });

        var range = this.pickone(["^", "~", "<", ">", "<=", ">=", "="]);
        if (options.range) {
            range = options.range;
        }

        var prerelease = "";
        if (options.include_prerelease) {
            prerelease = this.weighted(["", "-dev", "-beta", "-alpha"], [50, 10, 5, 1]);
        }
        return range + this.rpg('3d10').join('.') + prerelease;
    };

    Chance.prototype.tlds = function () {
        return ['com', 'org', 'edu', 'gov', 'co.uk', 'net', 'io', 'ac', 'ad', 'ae', 'af', 'ag', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'as', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bm', 'bn', 'bo', 'bq', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'cr', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'ee', 'eg', 'eh', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mk', 'ml', 'mm', 'mn', 'mo', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'nc', 'ne', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'ss', 'st', 'su', 'sv', 'sx', 'sy', 'sz', 'tc', 'td', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'ye', 'yt', 'za', 'zm', 'zw'];
    };

    Chance.prototype.tld = function () {
        return this.pick(this.tlds());
    };

    Chance.prototype.twitter = function () {
        return '@' + this.word();
    };

    Chance.prototype.url = function (options) {
        options = initOptions(options, { protocol: "http", domain: this.domain(options), domain_prefix: "", path: this.word(), extensions: []});

        var extension = options.extensions.length > 0 ? "." + this.pick(options.extensions) : "";
        var domain = options.domain_prefix ? options.domain_prefix + "." + options.domain : options.domain;

        return options.protocol + "://" + domain + "/" + options.path + extension;
    };

    // -- End Web --

    // -- Location --

    Chance.prototype.address = function (options) {
        options = initOptions(options);
        return this.natural({min: 5, max: 2000}) + ' ' + this.street(options);
    };

    Chance.prototype.altitude = function (options) {
        options = initOptions(options, {fixed: 5, min: 0, max: 8848});
        return this.floating({
            min: options.min,
            max: options.max,
            fixed: options.fixed
        });
    };

    Chance.prototype.areacode = function (options) {
        options = initOptions(options, {parens : true});
        // Don't want area codes to start with 1, or have a 9 as the second digit
        var areacode = this.natural({min: 2, max: 9}).toString() +
                this.natural({min: 0, max: 8}).toString() +
                this.natural({min: 0, max: 9}).toString();

        return options.parens ? '(' + areacode + ')' : areacode;
    };

    Chance.prototype.city = function () {
        return this.capitalize(this.word({syllables: 3}));
    };

    Chance.prototype.coordinates = function (options) {
        return this.latitude(options) + ', ' + this.longitude(options);
    };

    Chance.prototype.countries = function () {
        return this.get("countries");
    };

    Chance.prototype.country = function (options) {
        options = initOptions(options);
        var country = this.pick(this.countries());
        return options.full ? country.name : country.abbreviation;
    };

    Chance.prototype.depth = function (options) {
        options = initOptions(options, {fixed: 5, min: -10994, max: 0});
        return this.floating({
            min: options.min,
            max: options.max,
            fixed: options.fixed
        });
    };

    Chance.prototype.geohash = function (options) {
        options = initOptions(options, { length: 7 });
        return this.string({ length: options.length, pool: '0123456789bcdefghjkmnpqrstuvwxyz' });
    };

    Chance.prototype.geojson = function (options) {
        return this.latitude(options) + ', ' + this.longitude(options) + ', ' + this.altitude(options);
    };

    Chance.prototype.latitude = function (options) {
        options = initOptions(options, {fixed: 5, min: -90, max: 90});
        return this.floating({min: options.min, max: options.max, fixed: options.fixed});
    };

    Chance.prototype.longitude = function (options) {
        options = initOptions(options, {fixed: 5, min: -180, max: 180});
        return this.floating({min: options.min, max: options.max, fixed: options.fixed});
    };

    Chance.prototype.phone = function (options) {
        var self = this,
            numPick,
            ukNum = function (parts) {
                var section = [];
                //fills the section part of the phone number with random numbers.
                parts.sections.forEach(function(n) {
                    section.push(self.string({ pool: '0123456789', length: n}));
                });
                return parts.area + section.join(' ');
            };
        options = initOptions(options, {
            formatted: true,
            country: 'us',
            mobile: false
        });
        if (!options.formatted) {
            options.parens = false;
        }
        var phone;
        switch (options.country) {
            case 'fr':
                if (!options.mobile) {
                    numPick = this.pick([
                        // Valid zone and dpartement codes.
                        '01' + this.pick(['30', '34', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '53', '55', '56', '58', '60', '64', '69', '70', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83']) + self.string({ pool: '0123456789', length: 6}),
                        '02' + this.pick(['14', '18', '22', '23', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '40', '41', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '56', '57', '61', '62', '69', '72', '76', '77', '78', '85', '90', '96', '97', '98', '99']) + self.string({ pool: '0123456789', length: 6}),
                        '03' + this.pick(['10', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '39', '44', '45', '51', '52', '54', '55', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90']) + self.string({ pool: '0123456789', length: 6}),
                        '04' + this.pick(['11', '13', '15', '20', '22', '26', '27', '30', '32', '34', '37', '42', '43', '44', '50', '56', '57', '63', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '88', '89', '90', '91', '92', '93', '94', '95', '97', '98']) + self.string({ pool: '0123456789', length: 6}),
                        '05' + this.pick(['08', '16', '17', '19', '24', '31', '32', '33', '34', '35', '40', '45', '46', '47', '49', '53', '55', '56', '57', '58', '59', '61', '62', '63', '64', '65', '67', '79', '81', '82', '86', '87', '90', '94']) + self.string({ pool: '0123456789', length: 6}),
                        '09' + self.string({ pool: '0123456789', length: 8}),
                    ]);
                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
                } else {
                    numPick = this.pick(['06', '07']) + self.string({ pool: '0123456789', length: 8});
                    phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
                }
                break;
            case 'uk':
                if (!options.mobile) {
                    numPick = this.pick([
                        //valid area codes of major cities/counties followed by random numbers in required format.
                        { area: '01' + this.character({ pool: '234569' }) + '1 ', sections: [3,4] },
                        { area: '020 ' + this.character({ pool: '378' }), sections: [3,4] },
                        { area: '023 ' + this.character({ pool: '89' }), sections: [3,4] },
                        { area: '024 7', sections: [3,4] },
                        { area: '028 ' + this.pick(['25','28','37','71','82','90','92','95']), sections: [2,4] },
                        { area: '012' + this.pick(['04','08','54','76','97','98']) + ' ', sections: [5] },
                        { area: '013' + this.pick(['63','64','84','86']) + ' ', sections: [5] },
                        { area: '014' + this.pick(['04','20','60','61','80','88']) + ' ', sections: [5] },
                        { area: '015' + this.pick(['24','27','62','66']) + ' ', sections: [5] },
                        { area: '016' + this.pick(['06','29','35','47','59','95']) + ' ', sections: [5] },
                        { area: '017' + this.pick(['26','44','50','68']) + ' ', sections: [5] },
                        { area: '018' + this.pick(['27','37','84','97']) + ' ', sections: [5] },
                        { area: '019' + this.pick(['00','05','35','46','49','63','95']) + ' ', sections: [5] }
                    ]);
                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '', 'g');
                } else {
                    numPick = this.pick([
                        { area: '07' + this.pick(['4','5','7','8','9']), sections: [2,6] },
                        { area: '07624 ', sections: [6] }
                    ]);
                    phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '');
                }
                break;
            case 'us':
                var areacode = this.areacode(options).toString();
                var exchange = this.natural({ min: 2, max: 9 }).toString() +
                    this.natural({ min: 0, max: 9 }).toString() +
                    this.natural({ min: 0, max: 9 }).toString();
                var subscriber = this.natural({ min: 1000, max: 9999 }).toString(); // this could be random [0-9]{4}
                phone = options.formatted ? areacode + ' ' + exchange + '-' + subscriber : areacode + exchange + subscriber;
        }
        return phone;
    };

    Chance.prototype.postal = function () {
        // Postal District
        var pd = this.character({pool: "XVTSRPNKLMHJGECBA"});
        // Forward Sortation Area (FSA)
        var fsa = pd + this.natural({max: 9}) + this.character({alpha: true, casing: "upper"});
        // Local Delivery Unut (LDU)
        var ldu = this.natural({max: 9}) + this.character({alpha: true, casing: "upper"}) + this.natural({max: 9});

        return fsa + " " + ldu;
    };

    Chance.prototype.provinces = function (options) {
        options = initOptions(options, { country: 'ca' });
        return this.get("provinces")[options.country.toLowerCase()];
    };

    Chance.prototype.province = function (options) {
        return (options && options.full) ?
            this.pick(this.provinces(options)).name :
            this.pick(this.provinces(options)).abbreviation;
    };

    Chance.prototype.state = function (options) {
        return (options && options.full) ?
            this.pick(this.states(options)).name :
            this.pick(this.states(options)).abbreviation;
    };

    Chance.prototype.states = function (options) {
        options = initOptions(options, { country: 'us', us_states_and_dc: true } );

        var states;

        switch (options.country.toLowerCase()) {
            case 'us':
                var us_states_and_dc = this.get("us_states_and_dc"),
                    territories = this.get("territories"),
                    armed_forces = this.get("armed_forces");

                states = [];

                if (options.us_states_and_dc) {
                    states = states.concat(us_states_and_dc);
                }
                if (options.territories) {
                    states = states.concat(territories);
                }
                if (options.armed_forces) {
                    states = states.concat(armed_forces);
                }
                break;
            case 'it':
                states = this.get("country_regions")[options.country.toLowerCase()];
        }

        return states;
    };

    Chance.prototype.street = function (options) {
        options = initOptions(options, { country: 'us', syllables: 2 });
        var     street;

        switch (options.country.toLowerCase()) {
            case 'us':
                street = this.word({ syllables: options.syllables });
                street = this.capitalize(street);
                street += ' ';
                street += options.short_suffix ?
                    this.street_suffix(options).abbreviation :
                    this.street_suffix(options).name;
                break;
            case 'it':
                street = this.word({ syllables: options.syllables });
                street = this.capitalize(street);
                street = (options.short_suffix ?
                    this.street_suffix(options).abbreviation :
                    this.street_suffix(options).name) + " " + street;
                break;
        }
        return street;
    };

    Chance.prototype.street_suffix = function (options) {
        options = initOptions(options, { country: 'us' });
        return this.pick(this.street_suffixes(options));
    };

    Chance.prototype.street_suffixes = function (options) {
        options = initOptions(options, { country: 'us' });
        // These are the most common suffixes.
        return this.get("street_suffixes")[options.country.toLowerCase()];
    };

    // Note: only returning US zip codes, internationalization will be a whole
    // other beast to tackle at some point.
    Chance.prototype.zip = function (options) {
        var zip = this.n(this.natural, 5, {max: 9});

        if (options && options.plusfour === true) {
            zip.push('-');
            zip = zip.concat(this.n(this.natural, 4, {max: 9}));
        }

        return zip.join("");
    };

    // -- End Location --

    // -- Time

    Chance.prototype.ampm = function () {
        return this.bool() ? 'am' : 'pm';
    };

    Chance.prototype.date = function (options) {
        var date_string, date;

        // If interval is specified we ignore preset
        if(options && (options.min || options.max)) {
            options = initOptions(options, {
                american: true,
                string: false
            });
            var min = typeof options.min !== "undefined" ? options.min.getTime() : 1;
            // 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. http://es5.github.io/#x15.9.1.1
            var max = typeof options.max !== "undefined" ? options.max.getTime() : 8640000000000000;

            date = new Date(this.natural({min: min, max: max}));
        } else {
            var m = this.month({raw: true});
            var daysInMonth = m.days;

            if(options && options.month) {
                // Mod 12 to allow months outside range of 0-11 (not encouraged, but also not prevented).
                daysInMonth = this.get('months')[((options.month % 12) + 12) % 12].days;
            }

            options = initOptions(options, {
                year: parseInt(this.year(), 10),
                // Necessary to subtract 1 because Date() 0-indexes month but not day or year
                // for some reason.
                month: m.numeric - 1,
                day: this.natural({min: 1, max: daysInMonth}),
                hour: this.hour(),
                minute: this.minute(),
                second: this.second(),
                millisecond: this.millisecond(),
                american: true,
                string: false
            });

            date = new Date(options.year, options.month, options.day, options.hour, options.minute, options.second, options.millisecond);
        }

        if (options.american) {
            // Adding 1 to the month is necessary because Date() 0-indexes
            // months but not day for some odd reason.
            date_string = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
        } else {
            date_string = date.getDate() + '/' + (date.getMonth() + 1) + '/' + date.getFullYear();
        }

        return options.string ? date_string : date;
    };

    Chance.prototype.hammertime = function (options) {
        return this.date(options).getTime();
    };

    Chance.prototype.hour = function (options) {
        options = initOptions(options, {
            min: options && options.twentyfour ? 0 : 1,
            max: options && options.twentyfour ? 23 : 12
        });

        testRange(options.min < 0, "Chance: Min cannot be less than 0.");
        testRange(options.twentyfour && options.max > 23, "Chance: Max cannot be greater than 23 for twentyfour option.");
        testRange(!options.twentyfour && options.max > 12, "Chance: Max cannot be greater than 12.");
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        return this.natural({min: options.min, max: options.max});
    };

    Chance.prototype.millisecond = function () {
        return this.natural({max: 999});
    };

    Chance.prototype.minute = Chance.prototype.second = function (options) {
        options = initOptions(options, {min: 0, max: 59});

        testRange(options.min < 0, "Chance: Min cannot be less than 0.");
        testRange(options.max > 59, "Chance: Max cannot be greater than 59.");
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        return this.natural({min: options.min, max: options.max});
    };

    Chance.prototype.month = function (options) {
        options = initOptions(options, {min: 1, max: 12});

        testRange(options.min < 1, "Chance: Min cannot be less than 1.");
        testRange(options.max > 12, "Chance: Max cannot be greater than 12.");
        testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

        var month = this.pick(this.months().slice(options.min - 1, options.max));
        return options.raw ? month : month.name;
    };

    Chance.prototype.months = function () {
        return this.get("months");
    };

    Chance.prototype.second = function () {
        return this.natural({max: 59});
    };

    Chance.prototype.timestamp = function () {
        return this.natural({min: 1, max: parseInt(new Date().getTime() / 1000, 10)});
    };

    Chance.prototype.weekday = function (options) {
        options = initOptions(options, {weekday_only: false});
        var weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
        if (!options.weekday_only) {
            weekdays.push("Saturday");
            weekdays.push("Sunday");
        }
        return this.pickone(weekdays);
    };

    Chance.prototype.year = function (options) {
        // Default to current year as min if none specified
        options = initOptions(options, {min: new Date().getFullYear()});

        // Default to one century after current year as max if none specified
        options.max = (typeof options.max !== "undefined") ? options.max : options.min + 100;

        return this.natural(options).toString();
    };

    // -- End Time

    // -- Finance --

    Chance.prototype.cc = function (options) {
        options = initOptions(options);

        var type, number, to_generate;

        type = (options.type) ?
                    this.cc_type({ name: options.type, raw: true }) :
                    this.cc_type({ raw: true });

        number = type.prefix.split("");
        to_generate = type.length - type.prefix.length - 1;

        // Generates n - 1 digits
        number = number.concat(this.n(this.integer, to_generate, {min: 0, max: 9}));

        // Generates the last digit according to Luhn algorithm
        number.push(this.luhn_calculate(number.join("")));

        return number.join("");
    };

    Chance.prototype.cc_types = function () {
        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
        return this.get("cc_types");
    };

    Chance.prototype.cc_type = function (options) {
        options = initOptions(options);
        var types = this.cc_types(),
            type = null;

        if (options.name) {
            for (var i = 0; i < types.length; i++) {
                // Accept either name or short_name to specify card type
                if (types[i].name === options.name || types[i].short_name === options.name) {
                    type = types[i];
                    break;
                }
            }
            if (type === null) {
                throw new RangeError("Credit card type '" + options.name + "'' is not supported");
            }
        } else {
            type = this.pick(types);
        }

        return options.raw ? type : type.name;
    };

    //return all world currency by ISO 4217
    Chance.prototype.currency_types = function () {
        return this.get("currency_types");
    };

    //return random world currency by ISO 4217
    Chance.prototype.currency = function () {
        return this.pick(this.currency_types());
    };

    //Return random correct currency exchange pair (e.g. EUR/USD) or array of currency code
    Chance.prototype.currency_pair = function (returnAsString) {
        var currencies = this.unique(this.currency, 2, {
            comparator: function(arr, val) {

                return arr.reduce(function(acc, item) {
                    // If a match has been found, short circuit check and just return
                    return acc || (item.code === val.code);
                }, false);
            }
        });

        if (returnAsString) {
            return currencies[0].code + '/' + currencies[1].code;
        } else {
            return currencies;
        }
    };

    Chance.prototype.dollar = function (options) {
        // By default, a somewhat more sane max for dollar than all available numbers
        options = initOptions(options, {max : 10000, min : 0});

        var dollar = this.floating({min: options.min, max: options.max, fixed: 2}).toString(),
            cents = dollar.split('.')[1];

        if (cents === undefined) {
            dollar += '.00';
        } else if (cents.length < 2) {
            dollar = dollar + '0';
        }

        if (dollar < 0) {
            return '-$' + dollar.replace('-', '');
        } else {
            return '$' + dollar;
        }
    };

    Chance.prototype.euro = function (options) {
        return Number(this.dollar(options).replace("$", "")).toLocaleString() + "";
    };

    Chance.prototype.exp = function (options) {
        options = initOptions(options);
        var exp = {};

        exp.year = this.exp_year();

        // If the year is this year, need to ensure month is greater than the
        // current month or this expiration will not be valid
        if (exp.year === (new Date().getFullYear()).toString()) {
            exp.month = this.exp_month({future: true});
        } else {
            exp.month = this.exp_month();
        }

        return options.raw ? exp : exp.month + '/' + exp.year;
    };

    Chance.prototype.exp_month = function (options) {
        options = initOptions(options);
        var month, month_int,
            // Date object months are 0 indexed
            curMonth = new Date().getMonth() + 1;

        if (options.future && (curMonth !== 12)) {
            do {
                month = this.month({raw: true}).numeric;
                month_int = parseInt(month, 10);
            } while (month_int <= curMonth);
        } else {
            month = this.month({raw: true}).numeric;
        }

        return month;
    };

    Chance.prototype.exp_year = function () {
        var curMonth = new Date().getMonth() + 1,
            curYear = new Date().getFullYear();

        return this.year({min: ((curMonth === 12) ? (curYear + 1) : curYear), max: (curYear + 10)});
    };

    Chance.prototype.vat = function (options) {
        options = initOptions(options, { country: 'it' });
        switch (options.country.toLowerCase()) {
            case 'it':
                return this.it_vat();
        }
    };

    // -- End Finance

    // -- Regional

    Chance.prototype.it_vat = function () {
        var it_vat = this.natural({min: 1, max: 1800000});

        it_vat = this.pad(it_vat, 7) + this.pad(this.pick(this.provinces({ country: 'it' })).code, 3);
        return it_vat + this.luhn_calculate(it_vat);
    };

    /*
     * this generator is written following the official algorithm
     * all data can be passed explicitely or randomized by calling chance.cf() without options
     * the code does not check that the input data is valid (it goes beyond the scope of the generator)
     *
     * @param  [Object] options = { first: first name,
     *                              last: last name,
     *                              gender: female|male,
                                    birthday: JavaScript date object,
                                    city: string(4), 1 letter + 3 numbers
                                   }
     * @return [string] codice fiscale
     *
    */
    Chance.prototype.cf = function (options) {
        options = options || {};
        var gender = !!options.gender ? options.gender : this.gender(),
            first = !!options.first ? options.first : this.first( { gender: gender, nationality: 'it'} ),
            last = !!options.last ? options.last : this.last( { nationality: 'it'} ),
            birthday = !!options.birthday ? options.birthday : this.birthday(),
            city = !!options.city ? options.city : this.pickone(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'L', 'M', 'Z']) + this.pad(this.natural({max:999}), 3),
            cf = [],
            name_generator = function(name, isLast) {
                var temp,
                    return_value = [];

                if (name.length < 3) {
                    return_value = name.split("").concat("XXX".split("")).splice(0,3);
                }
                else {
                    temp = name.toUpperCase().split('').map(function(c){
                        return ("BCDFGHJKLMNPRSTVWZ".indexOf(c) !== -1) ? c : undefined;
                    }).join('');
                    if (temp.length > 3) {
                        if (isLast) {
                            temp = temp.substr(0,3);
                        } else {                        
                            temp = temp[0] + temp.substr(2,2);
                        }
                    }
                    if (temp.length < 3) {
                        return_value = temp;
                        temp = name.toUpperCase().split('').map(function(c){
                            return ("AEIOU".indexOf(c) !== -1) ? c : undefined;
                        }).join('').substr(0, 3 - return_value.length);
                    }
                    return_value = return_value + temp;
                }

                return return_value;
            },
            date_generator = function(birthday, gender, that) {
                var lettermonths = ['A', 'B', 'C', 'D', 'E', 'H', 'L', 'M', 'P', 'R', 'S', 'T'];

                return  birthday.getFullYear().toString().substr(2) + 
                        lettermonths[birthday.getMonth()] +
                        that.pad(birthday.getDate() + ((gender.toLowerCase() === "female") ? 40 : 0), 2);
            },
            checkdigit_generator = function(cf) {
                var range1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    range2 = "ABCDEFGHIJABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    evens  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                    odds   = "BAKPLCQDREVOSFTGUHMINJWZYX",
                    digit  = 0;


                for(var i = 0; i < 15; i++) {
                    if (i % 2 !== 0) {
                        digit += evens.indexOf(range2[range1.indexOf(cf[i])]);
                    }
                    else {
                        digit +=  odds.indexOf(range2[range1.indexOf(cf[i])]);
                    }
                }
                return evens[digit % 26];
            };

        cf = cf.concat(name_generator(last, true), name_generator(first), date_generator(birthday, gender, this), city.toUpperCase().split("")).join("");
        cf += checkdigit_generator(cf.toUpperCase(), this);

        return cf.toUpperCase();
    };

    Chance.prototype.pl_pesel = function () {
        var number = this.natural({min: 1, max: 9999999999});
        var arr = this.pad(number, 10).split('');
        for (var i = 0; i < arr.length; i++) {
            arr[i] = parseInt(arr[i]);
        }

        var controlNumber = (1 * arr[0] + 3 * arr[1] + 7 * arr[2] + 9 * arr[3] + 1 * arr[4] + 3 * arr[5] + 7 * arr[6] + 9 * arr[7] + 1 * arr[8] + 3 * arr[9]) % 10;
        if(controlNumber !== 0) {
            controlNumber = 10 - controlNumber;
        }

        return arr.join('') + controlNumber;
    };

    Chance.prototype.pl_nip = function () {
        var number = this.natural({min: 1, max: 999999999});
        var arr = this.pad(number, 9).split('');
        for (var i = 0; i < arr.length; i++) {
            arr[i] = parseInt(arr[i]);
        }

        var controlNumber = (6 * arr[0] + 5 * arr[1] + 7 * arr[2] + 2 * arr[3] + 3 * arr[4] + 4 * arr[5] + 5 * arr[6] + 6 * arr[7] + 7 * arr[8]) % 11;
        if(controlNumber === 10) {
            return this.pl_nip();
        }

        return arr.join('') + controlNumber;
    };

    Chance.prototype.pl_regon = function () {
        var number = this.natural({min: 1, max: 99999999});
        var arr = this.pad(number, 8).split('');
        for (var i = 0; i < arr.length; i++) {
            arr[i] = parseInt(arr[i]);
        }

        var controlNumber = (8 * arr[0] + 9 * arr[1] + 2 * arr[2] + 3 * arr[3] + 4 * arr[4] + 5 * arr[5] + 6 * arr[6] + 7 * arr[7]) % 11;
        if(controlNumber === 10) {
            controlNumber = 0;
        }

        return arr.join('') + controlNumber;
    };

    // -- End Regional

    // -- Miscellaneous --

    // Dice - For all the board game geeks out there, myself included ;)
    function diceFn (range) {
        return function () {
            return this.natural(range);
        };
    }
    Chance.prototype.d4 = diceFn({min: 1, max: 4});
    Chance.prototype.d6 = diceFn({min: 1, max: 6});
    Chance.prototype.d8 = diceFn({min: 1, max: 8});
    Chance.prototype.d10 = diceFn({min: 1, max: 10});
    Chance.prototype.d12 = diceFn({min: 1, max: 12});
    Chance.prototype.d20 = diceFn({min: 1, max: 20});
    Chance.prototype.d30 = diceFn({min: 1, max: 30});
    Chance.prototype.d100 = diceFn({min: 1, max: 100});

    Chance.prototype.rpg = function (thrown, options) {
        options = initOptions(options);
        if (!thrown) {
            throw new RangeError("A type of die roll must be included");
        } else {
            var bits = thrown.toLowerCase().split("d"),
                rolls = [];

            if (bits.length !== 2 || !parseInt(bits[0], 10) || !parseInt(bits[1], 10)) {
                throw new Error("Invalid format provided. Please provide #d# where the first # is the number of dice to roll, the second # is the max of each die");
            }
            for (var i = bits[0]; i > 0; i--) {
                rolls[i - 1] = this.natural({min: 1, max: bits[1]});
            }
            return (typeof options.sum !== 'undefined' && options.sum) ? rolls.reduce(function (p, c) { return p + c; }) : rolls;
        }
    };

    // Guid
    Chance.prototype.guid = function (options) {
        options = initOptions(options, { version: 5 });

        var guid_pool = "abcdef1234567890",
            variant_pool = "ab89",
            guid = this.string({ pool: guid_pool, length: 8 }) + '-' +
                   this.string({ pool: guid_pool, length: 4 }) + '-' +
                   // The Version
                   options.version +
                   this.string({ pool: guid_pool, length: 3 }) + '-' +
                   // The Variant
                   this.string({ pool: variant_pool, length: 1 }) +
                   this.string({ pool: guid_pool, length: 3 }) + '-' +
                   this.string({ pool: guid_pool, length: 12 });
        return guid;
    };

    // Hash
    Chance.prototype.hash = function (options) {
        options = initOptions(options, {length : 40, casing: 'lower'});
        var pool = options.casing === 'upper' ? HEX_POOL.toUpperCase() : HEX_POOL;
        return this.string({pool: pool, length: options.length});
    };

    Chance.prototype.luhn_check = function (num) {
        var str = num.toString();
        var checkDigit = +str.substring(str.length - 1);
        return checkDigit === this.luhn_calculate(+str.substring(0, str.length - 1));
    };

    Chance.prototype.luhn_calculate = function (num) {
        var digits = num.toString().split("").reverse();
        var sum = 0;
        var digit;

        for (var i = 0, l = digits.length; l > i; ++i) {
            digit = +digits[i];
            if (i % 2 === 0) {
                digit *= 2;
                if (digit > 9) {
                    digit -= 9;
                }
            }
            sum += digit;
        }
        return (sum * 9) % 10;
    };

    // MD5 Hash
    Chance.prototype.md5 = function(options) {
        var opts = { str: '', key: null, raw: false };

        if (!options) {
            opts.str = this.string();
            options = {};
        }
        else if (typeof options === 'string') {
            opts.str = options;
            options = {};
        }
        else if (typeof options !== 'object') {
            return null;
        }
        else if(options.constructor === 'Array') {
            return null;
        }

        opts = initOptions(options, opts);

        if(!opts.str){
            throw new Error('A parameter is required to return an md5 hash.');
        }

        return this.bimd5.md5(opts.str, opts.key, opts.raw);
    };

    /**
     * #Description:
     * =====================================================
     * Generate random file name with extention
     *
     * The argument provide extention type 
     * -> raster 
     * -> vector
     * -> 3d
     * -> document
     *
     * If noting is provided the function return random file name with random 
     * extention type of any kind
     *
     * The user can validate the file name length range 
     * If noting provided the generated file name is radom
     *
     * #Extention Pool :
     * * Currently the supported extentions are 
     *  -> some of the most popular raster image extentions
     *  -> some of the most popular vector image extentions
     *  -> some of the most popular 3d image extentions
     *  -> some of the most popular document extentions
     * 
     * #Examples :
     * =====================================================
     *
     * Return random file name with random extention. The file extention
     * is provided by a predifined collection of extentions. More abouth the extention
     * pool can be fond in #Extention Pool section
     * 
     * chance.file()                        
     * => dsfsdhjf.xml
     *
     * In order to generate a file name with sspecific length, specify the 
     * length property and integer value. The extention is going to be random
     *  
     * chance.file({length : 10})           
     * => asrtineqos.pdf
     *
     * In order to geerate file with extention form some of the predifined groups
     * of the extention pool just specify the extenton pool category in fileType property
     *  
     * chance.file({fileType : 'raster'})   
     * => dshgssds.psd
     *
     * You can provide specific extention for your files
     * chance.file({extention : 'html'})    
     * => djfsd.html
     *
     * Or you could pass custom collection of extentons bt array or by object
     * chance.file({extentions : [...]})    
     * => dhgsdsd.psd
     *  
     * chance.file({extentions : { key : [...], key : [...]}})
     * => djsfksdjsd.xml
     * 
     * @param  [collection] options 
     * @return [string]
     * 
     */
    Chance.prototype.file = function(options) {
        
        var fileOptions = options || {};
        var poolCollectionKey = "fileExtension";
        var typeRange   = Object.keys(this.get("fileExtension"));//['raster', 'vector', '3d', 'document'];
        var fileName;
        var fileExtention;

        // Generate random file name 
        fileName = this.word({length : fileOptions.length});

        // Generate file by specific extention provided by the user
        if(fileOptions.extention) {

            fileExtention = fileOptions.extention;
            return (fileName + '.' + fileExtention);
        }

        // Generate file by specific axtention collection
        if(fileOptions.extentions) {

            if(Array.isArray(fileOptions.extentions)) {

                fileExtention = this.pickone(fileOptions.extentions);
                return (fileName + '.' + fileExtention);
            }
            else if(fileOptions.extentions.constructor === Object) {
                
                var extentionObjectCollection = fileOptions.extentions;
                var keys = Object.keys(extentionObjectCollection);

                fileExtention = this.pickone(extentionObjectCollection[this.pickone(keys)]);
                return (fileName + '.' + fileExtention);
            }

            throw new Error("Expect collection of type Array or Object to be passed as an argument ");
        } 

        // Generate file extention based on specific file type
        if(fileOptions.fileType) {

            var fileType = fileOptions.fileType;
            if(typeRange.indexOf(fileType) !== -1) {

                fileExtention = this.pickone(this.get(poolCollectionKey)[fileType]);
                return (fileName + '.' + fileExtention);
            }

            throw new Error("Expect file type value to be 'raster', 'vector', '3d' or 'document' ");
        }

        // Generate random file name if no extenton options are passed
        fileExtention = this.pickone(this.get(poolCollectionKey)[this.pickone(typeRange)]);
        return (fileName + '.' + fileExtention);
    };     

    var data = {

        firstNames: {
            "male": {
                "en": ["James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Charles", "Thomas", "Christopher", "Daniel", "Matthew", "George", "Donald", "Anthony", "Paul", "Mark", "Edward", "Steven", "Kenneth", "Andrew", "Brian", "Joshua", "Kevin", "Ronald", "Timothy", "Jason", "Jeffrey", "Frank", "Gary", "Ryan", "Nicholas", "Eric", "Stephen", "Jacob", "Larry", "Jonathan", "Scott", "Raymond", "Justin", "Brandon", "Gregory", "Samuel", "Benjamin", "Patrick", "Jack", "Henry", "Walter", "Dennis", "Jerry", "Alexander", "Peter", "Tyler", "Douglas", "Harold", "Aaron", "Jose", "Adam", "Arthur", "Zachary", "Carl", "Nathan", "Albert", "Kyle", "Lawrence", "Joe", "Willie", "Gerald", "Roger", "Keith", "Jeremy", "Terry", "Harry", "Ralph", "Sean", "Jesse", "Roy", "Louis", "Billy", "Austin", "Bruce", "Eugene", "Christian", "Bryan", "Wayne", "Russell", "Howard", "Fred", "Ethan", "Jordan", "Philip", "Alan", "Juan", "Randy", "Vincent", "Bobby", "Dylan", "Johnny", "Phillip", "Victor", "Clarence", "Ernest", "Martin", "Craig", "Stanley", "Shawn", "Travis", "Bradley", "Leonard", "Earl", "Gabriel", "Jimmy", "Francis", "Todd", "Noah", "Danny", "Dale", "Cody", "Carlos", "Allen", "Frederick", "Logan", "Curtis", "Alex", "Joel", "Luis", "Norman", "Marvin", "Glenn", "Tony", "Nathaniel", "Rodney", "Melvin", "Alfred", "Steve", "Cameron", "Chad", "Edwin", "Caleb", "Evan", "Antonio", "Lee", "Herbert", "Jeffery", "Isaac", "Derek", "Ricky", "Marcus", "Theodore", "Elijah", "Luke", "Jesus", "Eddie", "Troy", "Mike", "Dustin", "Ray", "Adrian", "Bernard", "Leroy", "Angel", "Randall", "Wesley", "Ian", "Jared", "Mason", "Hunter", "Calvin", "Oscar", "Clifford", "Jay", "Shane", "Ronnie", "Barry", "Lucas", "Corey", "Manuel", "Leo", "Tommy", "Warren", "Jackson", "Isaiah", "Connor", "Don", "Dean", "Jon", "Julian", "Miguel", "Bill", "Lloyd", "Charlie", "Mitchell", "Leon", "Jerome", "Darrell", "Jeremiah", "Alvin", "Brett", "Seth", "Floyd", "Jim", "Blake", "Micheal", "Gordon", "Trevor", "Lewis", "Erik", "Edgar", "Vernon", "Devin", "Gavin", "Jayden", "Chris", "Clyde", "Tom", "Derrick", "Mario", "Brent", "Marc", "Herman", "Chase", "Dominic", "Ricardo", "Franklin", "Maurice", "Max", "Aiden", "Owen", "Lester", "Gilbert", "Elmer", "Gene", "Francisco", "Glen", "Cory", "Garrett", "Clayton", "Sam", "Jorge", "Chester", "Alejandro", "Jeff", "Harvey", "Milton", "Cole", "Ivan", "Andre", "Duane", "Landon"],
                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0163
                "it": ["Adolfo", "Alberto", "Aldo", "Alessandro", "Alessio", "Alfredo", "Alvaro", "Andrea", "Angelo", "Angiolo", "Antonino", "Antonio", "Attilio", "Benito", "Bernardo", "Bruno", "Carlo", "Cesare", "Christian", "Claudio", "Corrado", "Cosimo", "Cristian", "Cristiano", "Daniele", "Dario", "David", "Davide", "Diego", "Dino", "Domenico", "Duccio", "Edoardo", "Elia", "Elio", "Emanuele", "Emiliano", "Emilio", "Enrico", "Enzo", "Ettore", "Fabio", "Fabrizio", "Federico", "Ferdinando", "Fernando", "Filippo", "Francesco", "Franco", "Gabriele", "Giacomo", "Giampaolo", "Giampiero", "Giancarlo", "Gianfranco", "Gianluca", "Gianmarco", "Gianni", "Gino", "Giorgio", "Giovanni", "Giuliano", "Giulio", "Giuseppe", "Graziano", "Gregorio", "Guido", "Iacopo", "Jacopo", "Lapo", "Leonardo", "Lorenzo", "Luca", "Luciano", "Luigi", "Manuel", "Marcello", "Marco", "Marino", "Mario", "Massimiliano", "Massimo", "Matteo", "Mattia", "Maurizio", "Mauro", "Michele", "Mirko", "Mohamed", "Nello", "Neri", "Niccol", "Nicola", "Osvaldo", "Otello", "Paolo", "Pier Luigi", "Piero", "Pietro", "Raffaele", "Remo", "Renato", "Renzo", "Riccardo", "Roberto", "Rolando", "Romano", "Salvatore", "Samuele", "Sandro", "Sergio", "Silvano", "Simone", "Stefano", "Thomas", "Tommaso", "Ubaldo", "Ugo", "Umberto", "Valerio", "Valter", "Vasco", "Vincenzo", "Vittorio"]
            },
            "female": {
                "en": ["Mary", "Emma", "Elizabeth", "Minnie", "Margaret", "Ida", "Alice", "Bertha", "Sarah", "Annie", "Clara", "Ella", "Florence", "Cora", "Martha", "Laura", "Nellie", "Grace", "Carrie", "Maude", "Mabel", "Bessie", "Jennie", "Gertrude", "Julia", "Hattie", "Edith", "Mattie", "Rose", "Catherine", "Lillian", "Ada", "Lillie", "Helen", "Jessie", "Louise", "Ethel", "Lula", "Myrtle", "Eva", "Frances", "Lena", "Lucy", "Edna", "Maggie", "Pearl", "Daisy", "Fannie", "Josephine", "Dora", "Rosa", "Katherine", "Agnes", "Marie", "Nora", "May", "Mamie", "Blanche", "Stella", "Ellen", "Nancy", "Effie", "Sallie", "Nettie", "Della", "Lizzie", "Flora", "Susie", "Maud", "Mae", "Etta", "Harriet", "Sadie", "Caroline", "Katie", "Lydia", "Elsie", "Kate", "Susan", "Mollie", "Alma", "Addie", "Georgia", "Eliza", "Lulu", "Nannie", "Lottie", "Amanda", "Belle", "Charlotte", "Rebecca", "Ruth", "Viola", "Olive", "Amelia", "Hannah", "Jane", "Virginia", "Emily", "Matilda", "Irene", "Kathryn", "Esther", "Willie", "Henrietta", "Ollie", "Amy", "Rachel", "Sara", "Estella", "Theresa", "Augusta", "Ora", "Pauline", "Josie", "Lola", "Sophia", "Leona", "Anne", "Mildred", "Ann", "Beulah", "Callie", "Lou", "Delia", "Eleanor", "Barbara", "Iva", "Louisa", "Maria", "Mayme", "Evelyn", "Estelle", "Nina", "Betty", "Marion", "Bettie", "Dorothy", "Luella", "Inez", "Lela", "Rosie", "Allie", "Millie", "Janie", "Cornelia", "Victoria", "Ruby", "Winifred", "Alta", "Celia", "Christine", "Beatrice", "Birdie", "Harriett", "Mable", "Myra", "Sophie", "Tillie", "Isabel", "Sylvia", "Carolyn", "Isabelle", "Leila", "Sally", "Ina", "Essie", "Bertie", "Nell", "Alberta", "Katharine", "Lora", "Rena", "Mina", "Rhoda", "Mathilda", "Abbie", "Eula", "Dollie", "Hettie", "Eunice", "Fanny", "Ola", "Lenora", "Adelaide", "Christina", "Lelia", "Nelle", "Sue", "Johanna", "Lilly", "Lucinda", "Minerva", "Lettie", "Roxie", "Cynthia", "Helena", "Hilda", "Hulda", "Bernice", "Genevieve", "Jean", "Cordelia", "Marian", "Francis", "Jeanette", "Adeline", "Gussie", "Leah", "Lois", "Lura", "Mittie", "Hallie", "Isabella", "Olga", "Phoebe", "Teresa", "Hester", "Lida", "Lina", "Winnie", "Claudia", "Marguerite", "Vera", "Cecelia", "Bess", "Emilie", "John", "Rosetta", "Verna", "Myrtie", "Cecilia", "Elva", "Olivia", "Ophelia", "Georgie", "Elnora", "Violet", "Adele", "Lily", "Linnie", "Loretta", "Madge", "Polly", "Virgie", "Eugenia", "Lucile", "Lucille", "Mabelle", "Rosalie"],
                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0162
                "it": ["Ada", "Adriana", "Alessandra", "Alessia", "Alice", "Angela", "Anna", "Anna Maria", "Annalisa", "Annita", "Annunziata", "Antonella", "Arianna", "Asia", "Assunta", "Aurora", "Barbara", "Beatrice", "Benedetta", "Bianca", "Bruna", "Camilla", "Carla", "Carlotta", "Carmela", "Carolina", "Caterina", "Catia", "Cecilia", "Chiara", "Cinzia", "Clara", "Claudia", "Costanza", "Cristina", "Daniela", "Debora", "Diletta", "Dina", "Donatella", "Elena", "Eleonora", "Elisa", "Elisabetta", "Emanuela", "Emma", "Eva", "Federica", "Fernanda", "Fiorella", "Fiorenza", "Flora", "Franca", "Francesca", "Gabriella", "Gaia", "Gemma", "Giada", "Gianna", "Gina", "Ginevra", "Giorgia", "Giovanna", "Giulia", "Giuliana", "Giuseppa", "Giuseppina", "Grazia", "Graziella", "Greta", "Ida", "Ilaria", "Ines", "Iolanda", "Irene", "Irma", "Isabella", "Jessica", "Laura", "Leda", "Letizia", "Licia", "Lidia", "Liliana", "Lina", "Linda", "Lisa", "Livia", "Loretta", "Luana", "Lucia", "Luciana", "Lucrezia", "Luisa", "Manuela", "Mara", "Marcella", "Margherita", "Maria", "Maria Cristina", "Maria Grazia", "Maria Luisa", "Maria Pia", "Maria Teresa", "Marina", "Marisa", "Marta", "Martina", "Marzia", "Matilde", "Melissa", "Michela", "Milena", "Mirella", "Monica", "Natalina", "Nella", "Nicoletta", "Noemi", "Olga", "Paola", "Patrizia", "Piera", "Pierina", "Raffaella", "Rebecca", "Renata", "Rina", "Rita", "Roberta", "Rosa", "Rosanna", "Rossana", "Rossella", "Sabrina", "Sandra", "Sara", "Serena", "Silvana", "Silvia", "Simona", "Simonetta", "Sofia", "Sonia", "Stefania", "Susanna", "Teresa", "Tina", "Tiziana", "Tosca", "Valentina", "Valeria", "Vanda", "Vanessa", "Vanna", "Vera", "Veronica", "Vilma", "Viola", "Virginia", "Vittoria"]
            }
        },

        lastNames: {
            "en": ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King', 'Wright', 'Lopez', 'Hill', 'Scott', 'Green', 'Adams', 'Baker', 'Gonzalez', 'Nelson', 'Carter', 'Mitchell', 'Perez', 'Roberts', 'Turner', 'Phillips', 'Campbell', 'Parker', 'Evans', 'Edwards', 'Collins', 'Stewart', 'Sanchez', 'Morris', 'Rogers', 'Reed', 'Cook', 'Morgan', 'Bell', 'Murphy', 'Bailey', 'Rivera', 'Cooper', 'Richardson', 'Cox', 'Howard', 'Ward', 'Torres', 'Peterson', 'Gray', 'Ramirez', 'James', 'Watson', 'Brooks', 'Kelly', 'Sanders', 'Price', 'Bennett', 'Wood', 'Barnes', 'Ross', 'Henderson', 'Coleman', 'Jenkins', 'Perry', 'Powell', 'Long', 'Patterson', 'Hughes', 'Flores', 'Washington', 'Butler', 'Simmons', 'Foster', 'Gonzales', 'Bryant', 'Alexander', 'Russell', 'Griffin', 'Diaz', 'Hayes', 'Myers', 'Ford', 'Hamilton', 'Graham', 'Sullivan', 'Wallace', 'Woods', 'Cole', 'West', 'Jordan', 'Owens', 'Reynolds', 'Fisher', 'Ellis', 'Harrison', 'Gibson', 'McDonald', 'Cruz', 'Marshall', 'Ortiz', 'Gomez', 'Murray', 'Freeman', 'Wells', 'Webb', 'Simpson', 'Stevens', 'Tucker', 'Porter', 'Hunter', 'Hicks', 'Crawford', 'Henry', 'Boyd', 'Mason', 'Morales', 'Kennedy', 'Warren', 'Dixon', 'Ramos', 'Reyes', 'Burns', 'Gordon', 'Shaw', 'Holmes', 'Rice', 'Robertson', 'Hunt', 'Black', 'Daniels', 'Palmer', 'Mills', 'Nichols', 'Grant', 'Knight', 'Ferguson', 'Rose', 'Stone', 'Hawkins', 'Dunn', 'Perkins', 'Hudson', 'Spencer', 'Gardner', 'Stephens', 'Payne', 'Pierce', 'Berry', 'Matthews', 'Arnold', 'Wagner', 'Willis', 'Ray', 'Watkins', 'Olson', 'Carroll', 'Duncan', 'Snyder', 'Hart', 'Cunningham', 'Bradley', 'Lane', 'Andrews', 'Ruiz', 'Harper', 'Fox', 'Riley', 'Armstrong', 'Carpenter', 'Weaver', 'Greene', 'Lawrence', 'Elliott', 'Chavez', 'Sims', 'Austin', 'Peters', 'Kelley', 'Franklin', 'Lawson', 'Fields', 'Gutierrez', 'Ryan', 'Schmidt', 'Carr', 'Vasquez', 'Castillo', 'Wheeler', 'Chapman', 'Oliver', 'Montgomery', 'Richards', 'Williamson', 'Johnston', 'Banks', 'Meyer', 'Bishop', 'McCoy', 'Howell', 'Alvarez', 'Morrison', 'Hansen', 'Fernandez', 'Garza', 'Harvey', 'Little', 'Burton', 'Stanley', 'Nguyen', 'George', 'Jacobs', 'Reid', 'Kim', 'Fuller', 'Lynch', 'Dean', 'Gilbert', 'Garrett', 'Romero', 'Welch', 'Larson', 'Frazier', 'Burke', 'Hanson', 'Day', 'Mendoza', 'Moreno', 'Bowman', 'Medina', 'Fowler', 'Brewer', 'Hoffman', 'Carlson', 'Silva', 'Pearson', 'Holland', 'Douglas', 'Fleming', 'Jensen', 'Vargas', 'Byrd', 'Davidson', 'Hopkins', 'May', 'Terry', 'Herrera', 'Wade', 'Soto', 'Walters', 'Curtis', 'Neal', 'Caldwell', 'Lowe', 'Jennings', 'Barnett', 'Graves', 'Jimenez', 'Horton', 'Shelton', 'Barrett', 'Obrien', 'Castro', 'Sutton', 'Gregory', 'McKinney', 'Lucas', 'Miles', 'Craig', 'Rodriquez', 'Chambers', 'Holt', 'Lambert', 'Fletcher', 'Watts', 'Bates', 'Hale', 'Rhodes', 'Pena', 'Beck', 'Newman', 'Haynes', 'McDaniel', 'Mendez', 'Bush', 'Vaughn', 'Parks', 'Dawson', 'Santiago', 'Norris', 'Hardy', 'Love', 'Steele', 'Curry', 'Powers', 'Schultz', 'Barker', 'Guzman', 'Page', 'Munoz', 'Ball', 'Keller', 'Chandler', 'Weber', 'Leonard', 'Walsh', 'Lyons', 'Ramsey', 'Wolfe', 'Schneider', 'Mullins', 'Benson', 'Sharp', 'Bowen', 'Daniel', 'Barber', 'Cummings', 'Hines', 'Baldwin', 'Griffith', 'Valdez', 'Hubbard', 'Salazar', 'Reeves', 'Warner', 'Stevenson', 'Burgess', 'Santos', 'Tate', 'Cross', 'Garner', 'Mann', 'Mack', 'Moss', 'Thornton', 'Dennis', 'McGee', 'Farmer', 'Delgado', 'Aguilar', 'Vega', 'Glover', 'Manning', 'Cohen', 'Harmon', 'Rodgers', 'Robbins', 'Newton', 'Todd', 'Blair', 'Higgins', 'Ingram', 'Reese', 'Cannon', 'Strickland', 'Townsend', 'Potter', 'Goodwin', 'Walton', 'Rowe', 'Hampton', 'Ortega', 'Patton', 'Swanson', 'Joseph', 'Francis', 'Goodman', 'Maldonado', 'Yates', 'Becker', 'Erickson', 'Hodges', 'Rios', 'Conner', 'Adkins', 'Webster', 'Norman', 'Malone', 'Hammond', 'Flowers', 'Cobb', 'Moody', 'Quinn', 'Blake', 'Maxwell', 'Pope', 'Floyd', 'Osborne', 'Paul', 'McCarthy', 'Guerrero', 'Lindsey', 'Estrada', 'Sandoval', 'Gibbs', 'Tyler', 'Gross', 'Fitzgerald', 'Stokes', 'Doyle', 'Sherman', 'Saunders', 'Wise', 'Colon', 'Gill', 'Alvarado', 'Greer', 'Padilla', 'Simon', 'Waters', 'Nunez', 'Ballard', 'Schwartz', 'McBride', 'Houston', 'Christensen', 'Klein', 'Pratt', 'Briggs', 'Parsons', 'McLaughlin', 'Zimmerman', 'French', 'Buchanan', 'Moran', 'Copeland', 'Roy', 'Pittman', 'Brady', 'McCormick', 'Holloway', 'Brock', 'Poole', 'Frank', 'Logan', 'Owen', 'Bass', 'Marsh', 'Drake', 'Wong', 'Jefferson', 'Park', 'Morton', 'Abbott', 'Sparks', 'Patrick', 'Norton', 'Huff', 'Clayton', 'Massey', 'Lloyd', 'Figueroa', 'Carson', 'Bowers', 'Roberson', 'Barton', 'Tran', 'Lamb', 'Harrington', 'Casey', 'Boone', 'Cortez', 'Clarke', 'Mathis', 'Singleton', 'Wilkins', 'Cain', 'Bryan', 'Underwood', 'Hogan', 'McKenzie', 'Collier', 'Luna', 'Phelps', 'McGuire', 'Allison', 'Bridges', 'Wilkerson', 'Nash', 'Summers', 'Atkins'],
                // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0164 (first 1000)
            "it": ["Acciai", "Aglietti", "Agostini", "Agresti", "Ahmed", "Aiazzi", "Albanese", "Alberti", "Alessi", "Alfani", "Alinari", "Alterini", "Amato", "Ammannati", "Ancillotti", "Andrei", "Andreini", "Andreoni", "Angeli", "Anichini", "Antonelli", "Antonini", "Arena", "Ariani", "Arnetoli", "Arrighi", "Baccani", "Baccetti", "Bacci", "Bacherini", "Badii", "Baggiani", "Baglioni", "Bagni", "Bagnoli", "Baldassini", "Baldi", "Baldini", "Ballerini", "Balli", "Ballini", "Balloni", "Bambi", "Banchi", "Bandinelli", "Bandini", "Bani", "Barbetti", "Barbieri", "Barchielli", "Bardazzi", "Bardelli", "Bardi", "Barducci", "Bargellini", "Bargiacchi", "Barni", "Baroncelli", "Baroncini", "Barone", "Baroni", "Baronti", "Bartalesi", "Bartoletti", "Bartoli", "Bartolini", "Bartoloni", "Bartolozzi", "Basagni", "Basile", "Bassi", "Batacchi", "Battaglia", "Battaglini", "Bausi", "Becagli", "Becattini", "Becchi", "Becucci", "Bellandi", "Bellesi", "Belli", "Bellini", "Bellucci", "Bencini", "Benedetti", "Benelli", "Beni", "Benini", "Bensi", "Benucci", "Benvenuti", "Berlincioni", "Bernacchioni", "Bernardi", "Bernardini", "Berni", "Bernini", "Bertelli", "Berti", "Bertini", "Bessi", "Betti", "Bettini", "Biagi", "Biagini", "Biagioni", "Biagiotti", "Biancalani", "Bianchi", "Bianchini", "Bianco", "Biffoli", "Bigazzi", "Bigi", "Biliotti", "Billi", "Binazzi", "Bindi", "Bini", "Biondi", "Bizzarri", "Bocci", "Bogani", "Bolognesi", "Bonaiuti", "Bonanni", "Bonciani", "Boncinelli", "Bondi", "Bonechi", "Bongini", "Boni", "Bonini", "Borchi", "Boretti", "Borghi", "Borghini", "Borgioli", "Borri", "Borselli", "Boschi", "Bottai", "Bracci", "Braccini", "Brandi", "Braschi", "Bravi", "Brazzini", "Breschi", "Brilli", "Brizzi", "Brogelli", "Brogi", "Brogioni", "Brunelli", "Brunetti", "Bruni", "Bruno", "Brunori", "Bruschi", "Bucci", "Bucciarelli", "Buccioni", "Bucelli", "Bulli", "Burberi", "Burchi", "Burgassi", "Burroni", "Bussotti", "Buti", "Caciolli", "Caiani", "Calabrese", "Calamai", "Calamandrei", "Caldini", "Calo'", "Calonaci", "Calosi", "Calvelli", "Cambi", "Camiciottoli", "Cammelli", "Cammilli", "Campolmi", "Cantini", "Capanni", "Capecchi", "Caponi", "Cappelletti", "Cappelli", "Cappellini", "Cappugi", "Capretti", "Caputo", "Carbone", "Carboni", "Cardini", "Carlesi", "Carletti", "Carli", "Caroti", "Carotti", "Carrai", "Carraresi", "Carta", "Caruso", "Casalini", "Casati", "Caselli", "Casini", "Castagnoli", "Castellani", "Castelli", "Castellucci", "Catalano", "Catarzi", "Catelani", "Cavaciocchi", "Cavallaro", "Cavallini", "Cavicchi", "Cavini", "Ceccarelli", "Ceccatelli", "Ceccherelli", "Ceccherini", "Cecchi", "Cecchini", "Cecconi", "Cei", "Cellai", "Celli", "Cellini", "Cencetti", "Ceni", "Cenni", "Cerbai", "Cesari", "Ceseri", "Checcacci", "Checchi", "Checcucci", "Cheli", "Chellini", "Chen", "Cheng", "Cherici", "Cherubini", "Chiaramonti", "Chiarantini", "Chiarelli", "Chiari", "Chiarini", "Chiarugi", "Chiavacci", "Chiesi", "Chimenti", "Chini", "Chirici", "Chiti", "Ciabatti", "Ciampi", "Cianchi", "Cianfanelli", "Cianferoni", "Ciani", "Ciapetti", "Ciappi", "Ciardi", "Ciatti", "Cicali", "Ciccone", "Cinelli", "Cini", "Ciobanu", "Ciolli", "Cioni", "Cipriani", "Cirillo", "Cirri", "Ciucchi", "Ciuffi", "Ciulli", "Ciullini", "Clemente", "Cocchi", "Cognome", "Coli", "Collini", "Colombo", "Colzi", "Comparini", "Conforti", "Consigli", "Conte", "Conti", "Contini", "Coppini", "Coppola", "Corsi", "Corsini", "Corti", "Cortini", "Cosi", "Costa", "Costantini", "Costantino", "Cozzi", "Cresci", "Crescioli", "Cresti", "Crini", "Curradi", "D'Agostino", "D'Alessandro", "D'Amico", "D'Angelo", "Daddi", "Dainelli", "Dallai", "Danti", "Davitti", "De Angelis", "De Luca", "De Marco", "De Rosa", "De Santis", "De Simone", "De Vita", "Degl'Innocenti", "Degli Innocenti", "Dei", "Del Lungo", "Del Re", "Di Marco", "Di Stefano", "Dini", "Diop", "Dobre", "Dolfi", "Donati", "Dondoli", "Dong", "Donnini", "Ducci", "Dumitru", "Ermini", "Esposito", "Evangelisti", "Fabbri", "Fabbrini", "Fabbrizzi", "Fabbroni", "Fabbrucci", "Fabiani", "Facchini", "Faggi", "Fagioli", "Failli", "Faini", "Falciani", "Falcini", "Falcone", "Fallani", "Falorni", "Falsini", "Falugiani", "Fancelli", "Fanelli", "Fanetti", "Fanfani", "Fani", "Fantappie'", "Fantechi", "Fanti", "Fantini", "Fantoni", "Farina", "Fattori", "Favilli", "Fedi", "Fei", "Ferrante", "Ferrara", "Ferrari", "Ferraro", "Ferretti", "Ferri", "Ferrini", "Ferroni", "Fiaschi", "Fibbi", "Fiesoli", "Filippi", "Filippini", "Fini", "Fioravanti", "Fiore", "Fiorentini", "Fiorini", "Fissi", "Focardi", "Foggi", "Fontana", "Fontanelli", "Fontani", "Forconi", "Formigli", "Forte", "Forti", "Fortini", "Fossati", "Fossi", "Francalanci", "Franceschi", "Franceschini", "Franchi", "Franchini", "Franci", "Francini", "Francioni", "Franco", "Frassineti", "Frati", "Fratini", "Frilli", "Frizzi", "Frosali", "Frosini", "Frullini", "Fusco", "Fusi", "Gabbrielli", "Gabellini", "Gagliardi", "Galanti", "Galardi", "Galeotti", "Galletti", "Galli", "Gallo", "Gallori", "Gambacciani", "Gargani", "Garofalo", "Garuglieri", "Gashi", "Gasperini", "Gatti", "Gelli", "Gensini", "Gentile", "Gentili", "Geri", "Gerini", "Gheri", "Ghini", "Giachetti", "Giachi", "Giacomelli", "Gianassi", "Giani", "Giannelli", "Giannetti", "Gianni", "Giannini", "Giannoni", "Giannotti", "Giannozzi", "Gigli", "Giordano", "Giorgetti", "Giorgi", "Giovacchini", "Giovannelli", "Giovannetti", "Giovannini", "Giovannoni", "Giuliani", "Giunti", "Giuntini", "Giusti", "Gonnelli", "Goretti", "Gori", "Gradi", "Gramigni", "Grassi", "Grasso", "Graziani", "Grazzini", "Greco", "Grifoni", "Grillo", "Grimaldi", "Grossi", "Gualtieri", "Guarducci", "Guarino", "Guarnieri", "Guasti", "Guerra", "Guerri", "Guerrini", "Guidi", "Guidotti", "He", "Hoxha", "Hu", "Huang", "Iandelli", "Ignesti", "Innocenti", "Jin", "La Rosa", "Lai", "Landi", "Landini", "Lanini", "Lapi", "Lapini", "Lari", "Lascialfari", "Lastrucci", "Latini", "Lazzeri", "Lazzerini", "Lelli", "Lenzi", "Leonardi", "Leoncini", "Leone", "Leoni", "Lepri", "Li", "Liao", "Lin", "Linari", "Lippi", "Lisi", "Livi", "Lombardi", "Lombardini", "Lombardo", "Longo", "Lopez", "Lorenzi", "Lorenzini", "Lorini", "Lotti", "Lu", "Lucchesi", "Lucherini", "Lunghi", "Lupi", "Madiai", "Maestrini", "Maffei", "Maggi", "Maggini", "Magherini", "Magini", "Magnani", "Magnelli", "Magni", "Magnolfi", "Magrini", "Malavolti", "Malevolti", "Manca", "Mancini", "Manetti", "Manfredi", "Mangani", "Mannelli", "Manni", "Mannini", "Mannucci", "Manuelli", "Manzini", "Marcelli", "Marchese", "Marchetti", "Marchi", "Marchiani", "Marchionni", "Marconi", "Marcucci", "Margheri", "Mari", "Mariani", "Marilli", "Marinai", "Marinari", "Marinelli", "Marini", "Marino", "Mariotti", "Marsili", "Martelli", "Martinelli", "Martini", "Martino", "Marzi", "Masi", "Masini", "Masoni", "Massai", "Materassi", "Mattei", "Matteini", "Matteucci", "Matteuzzi", "Mattioli", "Mattolini", "Matucci", "Mauro", "Mazzanti", "Mazzei", "Mazzetti", "Mazzi", "Mazzini", "Mazzocchi", "Mazzoli", "Mazzoni", "Mazzuoli", "Meacci", "Mecocci", "Meini", "Melani", "Mele", "Meli", "Mengoni", "Menichetti", "Meoni", "Merlini", "Messeri", "Messina", "Meucci", "Miccinesi", "Miceli", "Micheli", "Michelini", "Michelozzi", "Migliori", "Migliorini", "Milani", "Miniati", "Misuri", "Monaco", "Montagnani", "Montagni", "Montanari", "Montelatici", "Monti", "Montigiani", "Montini", "Morandi", "Morandini", "Morelli", "Moretti", "Morganti", "Mori", "Morini", "Moroni", "Morozzi", "Mugnai", "Mugnaini", "Mustafa", "Naldi", "Naldini", "Nannelli", "Nanni", "Nannini", "Nannucci", "Nardi", "Nardini", "Nardoni", "Natali", "Ndiaye", "Nencetti", "Nencini", "Nencioni", "Neri", "Nesi", "Nesti", "Niccolai", "Niccoli", "Niccolini", "Nigi", "Nistri", "Nocentini", "Noferini", "Novelli", "Nucci", "Nuti", "Nutini", "Oliva", "Olivieri", "Olmi", "Orlandi", "Orlandini", "Orlando", "Orsini", "Ortolani", "Ottanelli", "Pacciani", "Pace", "Paci", "Pacini", "Pagani", "Pagano", "Paggetti", "Pagliai", "Pagni", "Pagnini", "Paladini", "Palagi", "Palchetti", "Palloni", "Palmieri", "Palumbo", "Pampaloni", "Pancani", "Pandolfi", "Pandolfini", "Panerai", "Panichi", "Paoletti", "Paoli", "Paolini", "Papi", "Papini", "Papucci", "Parenti", "Parigi", "Parisi", "Parri", "Parrini", "Pasquini", "Passeri", "Pecchioli", "Pecorini", "Pellegrini", "Pepi", "Perini", "Perrone", "Peruzzi", "Pesci", "Pestelli", "Petri", "Petrini", "Petrucci", "Pettini", "Pezzati", "Pezzatini", "Piani", "Piazza", "Piazzesi", "Piazzini", "Piccardi", "Picchi", "Piccini", "Piccioli", "Pieraccini", "Pieraccioni", "Pieralli", "Pierattini", "Pieri", "Pierini", "Pieroni", "Pietrini", "Pini", "Pinna", "Pinto", "Pinzani", "Pinzauti", "Piras", "Pisani", "Pistolesi", "Poggesi", "Poggi", "Poggiali", "Poggiolini", "Poli", "Pollastri", "Porciani", "Pozzi", "Pratellesi", "Pratesi", "Prosperi", "Pruneti", "Pucci", "Puccini", "Puccioni", "Pugi", "Pugliese", "Puliti", "Querci", "Quercioli", "Raddi", "Radu", "Raffaelli", "Ragazzini", "Ranfagni", "Ranieri", "Rastrelli", "Raugei", "Raveggi", "Renai", "Renzi", "Rettori", "Ricci", "Ricciardi", "Ridi", "Ridolfi", "Rigacci", "Righi", "Righini", "Rinaldi", "Risaliti", "Ristori", "Rizzo", "Rocchi", "Rocchini", "Rogai", "Romagnoli", "Romanelli", "Romani", "Romano", "Romei", "Romeo", "Romiti", "Romoli", "Romolini", "Rontini", "Rosati", "Roselli", "Rosi", "Rossetti", "Rossi", "Rossini", "Rovai", "Ruggeri", "Ruggiero", "Russo", "Sabatini", "Saccardi", "Sacchetti", "Sacchi", "Sacco", "Salerno", "Salimbeni", "Salucci", "Salvadori", "Salvestrini", "Salvi", "Salvini", "Sanesi", "Sani", "Sanna", "Santi", "Santini", "Santoni", "Santoro", "Santucci", "Sardi", "Sarri", "Sarti", "Sassi", "Sbolci", "Scali", "Scarpelli", "Scarselli", "Scopetani", "Secci", "Selvi", "Senatori", "Senesi", "Serafini", "Sereni", "Serra", "Sestini", "Sguanci", "Sieni", "Signorini", "Silvestri", "Simoncini", "Simonetti", "Simoni", "Singh", "Sodi", "Soldi", "Somigli", "Sorbi", "Sorelli", "Sorrentino", "Sottili", "Spina", "Spinelli", "Staccioli", "Staderini", "Stefanelli", "Stefani", "Stefanini", "Stella", "Susini", "Tacchi", "Tacconi", "Taddei", "Tagliaferri", "Tamburini", "Tanganelli", "Tani", "Tanini", "Tapinassi", "Tarchi", "Tarchiani", "Targioni", "Tassi", "Tassini", "Tempesti", "Terzani", "Tesi", "Testa", "Testi", "Tilli", "Tinti", "Tirinnanzi", "Toccafondi", "Tofanari", "Tofani", "Tognaccini", "Tonelli", "Tonini", "Torelli", "Torrini", "Tosi", "Toti", "Tozzi", "Trambusti", "Trapani", "Tucci", "Turchi", "Ugolini", "Ulivi", "Valente", "Valenti", "Valentini", "Vangelisti", "Vanni", "Vannini", "Vannoni", "Vannozzi", "Vannucchi", "Vannucci", "Ventura", "Venturi", "Venturini", "Vestri", "Vettori", "Vichi", "Viciani", "Vieri", "Vigiani", "Vignoli", "Vignolini", "Vignozzi", "Villani", "Vinci", "Visani", "Vitale", "Vitali", "Viti", "Viviani", "Vivoli", "Volpe", "Volpi", "Wang", "Wu", "Xu", "Yang", "Ye", "Zagli", "Zani", "Zanieri", "Zanobini", "Zecchi", "Zetti", "Zhang", "Zheng", "Zhou", "Zhu", "Zingoni", "Zini", "Zoppi"]
        },

        // Data taken from https://github.com/umpirsky/country-list/blob/master/country/cldr/en_US/country.json
        countries: [{"name":"Afghanistan","abbreviation":"AF"},{"name":"Albania","abbreviation":"AL"},{"name":"Algeria","abbreviation":"DZ"},{"name":"American Samoa","abbreviation":"AS"},{"name":"Andorra","abbreviation":"AD"},{"name":"Angola","abbreviation":"AO"},{"name":"Anguilla","abbreviation":"AI"},{"name":"Antarctica","abbreviation":"AQ"},{"name":"Antigua and Barbuda","abbreviation":"AG"},{"name":"Argentina","abbreviation":"AR"},{"name":"Armenia","abbreviation":"AM"},{"name":"Aruba","abbreviation":"AW"},{"name":"Australia","abbreviation":"AU"},{"name":"Austria","abbreviation":"AT"},{"name":"Azerbaijan","abbreviation":"AZ"},{"name":"Bahamas","abbreviation":"BS"},{"name":"Bahrain","abbreviation":"BH"},{"name":"Bangladesh","abbreviation":"BD"},{"name":"Barbados","abbreviation":"BB"},{"name":"Belarus","abbreviation":"BY"},{"name":"Belgium","abbreviation":"BE"},{"name":"Belize","abbreviation":"BZ"},{"name":"Benin","abbreviation":"BJ"},{"name":"Bermuda","abbreviation":"BM"},{"name":"Bhutan","abbreviation":"BT"},{"name":"Bolivia","abbreviation":"BO"},{"name":"Bosnia and Herzegovina","abbreviation":"BA"},{"name":"Botswana","abbreviation":"BW"},{"name":"Bouvet Island","abbreviation":"BV"},{"name":"Brazil","abbreviation":"BR"},{"name":"British Antarctic Territory","abbreviation":"BQ"},{"name":"British Indian Ocean Territory","abbreviation":"IO"},{"name":"British Virgin Islands","abbreviation":"VG"},{"name":"Brunei","abbreviation":"BN"},{"name":"Bulgaria","abbreviation":"BG"},{"name":"Burkina Faso","abbreviation":"BF"},{"name":"Burundi","abbreviation":"BI"},{"name":"Cambodia","abbreviation":"KH"},{"name":"Cameroon","abbreviation":"CM"},{"name":"Canada","abbreviation":"CA"},{"name":"Canton and Enderbury Islands","abbreviation":"CT"},{"name":"Cape Verde","abbreviation":"CV"},{"name":"Cayman Islands","abbreviation":"KY"},{"name":"Central African Republic","abbreviation":"CF"},{"name":"Chad","abbreviation":"TD"},{"name":"Chile","abbreviation":"CL"},{"name":"China","abbreviation":"CN"},{"name":"Christmas Island","abbreviation":"CX"},{"name":"Cocos [Keeling] Islands","abbreviation":"CC"},{"name":"Colombia","abbreviation":"CO"},{"name":"Comoros","abbreviation":"KM"},{"name":"Congo - Brazzaville","abbreviation":"CG"},{"name":"Congo - Kinshasa","abbreviation":"CD"},{"name":"Cook Islands","abbreviation":"CK"},{"name":"Costa Rica","abbreviation":"CR"},{"name":"Croatia","abbreviation":"HR"},{"name":"Cuba","abbreviation":"CU"},{"name":"Cyprus","abbreviation":"CY"},{"name":"Czech Republic","abbreviation":"CZ"},{"name":"Cte dIvoire","abbreviation":"CI"},{"name":"Denmark","abbreviation":"DK"},{"name":"Djibouti","abbreviation":"DJ"},{"name":"Dominica","abbreviation":"DM"},{"name":"Dominican Republic","abbreviation":"DO"},{"name":"Dronning Maud Land","abbreviation":"NQ"},{"name":"East Germany","abbreviation":"DD"},{"name":"Ecuador","abbreviation":"EC"},{"name":"Egypt","abbreviation":"EG"},{"name":"El Salvador","abbreviation":"SV"},{"name":"Equatorial Guinea","abbreviation":"GQ"},{"name":"Eritrea","abbreviation":"ER"},{"name":"Estonia","abbreviation":"EE"},{"name":"Ethiopia","abbreviation":"ET"},{"name":"Falkland Islands","abbreviation":"FK"},{"name":"Faroe Islands","abbreviation":"FO"},{"name":"Fiji","abbreviation":"FJ"},{"name":"Finland","abbreviation":"FI"},{"name":"France","abbreviation":"FR"},{"name":"French Guiana","abbreviation":"GF"},{"name":"French Polynesia","abbreviation":"PF"},{"name":"French Southern Territories","abbreviation":"TF"},{"name":"French Southern and Antarctic Territories","abbreviation":"FQ"},{"name":"Gabon","abbreviation":"GA"},{"name":"Gambia","abbreviation":"GM"},{"name":"Georgia","abbreviation":"GE"},{"name":"Germany","abbreviation":"DE"},{"name":"Ghana","abbreviation":"GH"},{"name":"Gibraltar","abbreviation":"GI"},{"name":"Greece","abbreviation":"GR"},{"name":"Greenland","abbreviation":"GL"},{"name":"Grenada","abbreviation":"GD"},{"name":"Guadeloupe","abbreviation":"GP"},{"name":"Guam","abbreviation":"GU"},{"name":"Guatemala","abbreviation":"GT"},{"name":"Guernsey","abbreviation":"GG"},{"name":"Guinea","abbreviation":"GN"},{"name":"Guinea-Bissau","abbreviation":"GW"},{"name":"Guyana","abbreviation":"GY"},{"name":"Haiti","abbreviation":"HT"},{"name":"Heard Island and McDonald Islands","abbreviation":"HM"},{"name":"Honduras","abbreviation":"HN"},{"name":"Hong Kong SAR China","abbreviation":"HK"},{"name":"Hungary","abbreviation":"HU"},{"name":"Iceland","abbreviation":"IS"},{"name":"India","abbreviation":"IN"},{"name":"Indonesia","abbreviation":"ID"},{"name":"Iran","abbreviation":"IR"},{"name":"Iraq","abbreviation":"IQ"},{"name":"Ireland","abbreviation":"IE"},{"name":"Isle of Man","abbreviation":"IM"},{"name":"Israel","abbreviation":"IL"},{"name":"Italy","abbreviation":"IT"},{"name":"Jamaica","abbreviation":"JM"},{"name":"Japan","abbreviation":"JP"},{"name":"Jersey","abbreviation":"JE"},{"name":"Johnston Island","abbreviation":"JT"},{"name":"Jordan","abbreviation":"JO"},{"name":"Kazakhstan","abbreviation":"KZ"},{"name":"Kenya","abbreviation":"KE"},{"name":"Kiribati","abbreviation":"KI"},{"name":"Kuwait","abbreviation":"KW"},{"name":"Kyrgyzstan","abbreviation":"KG"},{"name":"Laos","abbreviation":"LA"},{"name":"Latvia","abbreviation":"LV"},{"name":"Lebanon","abbreviation":"LB"},{"name":"Lesotho","abbreviation":"LS"},{"name":"Liberia","abbreviation":"LR"},{"name":"Libya","abbreviation":"LY"},{"name":"Liechtenstein","abbreviation":"LI"},{"name":"Lithuania","abbreviation":"LT"},{"name":"Luxembourg","abbreviation":"LU"},{"name":"Macau SAR China","abbreviation":"MO"},{"name":"Macedonia","abbreviation":"MK"},{"name":"Madagascar","abbreviation":"MG"},{"name":"Malawi","abbreviation":"MW"},{"name":"Malaysia","abbreviation":"MY"},{"name":"Maldives","abbreviation":"MV"},{"name":"Mali","abbreviation":"ML"},{"name":"Malta","abbreviation":"MT"},{"name":"Marshall Islands","abbreviation":"MH"},{"name":"Martinique","abbreviation":"MQ"},{"name":"Mauritania","abbreviation":"MR"},{"name":"Mauritius","abbreviation":"MU"},{"name":"Mayotte","abbreviation":"YT"},{"name":"Metropolitan France","abbreviation":"FX"},{"name":"Mexico","abbreviation":"MX"},{"name":"Micronesia","abbreviation":"FM"},{"name":"Midway Islands","abbreviation":"MI"},{"name":"Moldova","abbreviation":"MD"},{"name":"Monaco","abbreviation":"MC"},{"name":"Mongolia","abbreviation":"MN"},{"name":"Montenegro","abbreviation":"ME"},{"name":"Montserrat","abbreviation":"MS"},{"name":"Morocco","abbreviation":"MA"},{"name":"Mozambique","abbreviation":"MZ"},{"name":"Myanmar [Burma]","abbreviation":"MM"},{"name":"Namibia","abbreviation":"NA"},{"name":"Nauru","abbreviation":"NR"},{"name":"Nepal","abbreviation":"NP"},{"name":"Netherlands","abbreviation":"NL"},{"name":"Netherlands Antilles","abbreviation":"AN"},{"name":"Neutral Zone","abbreviation":"NT"},{"name":"New Caledonia","abbreviation":"NC"},{"name":"New Zealand","abbreviation":"NZ"},{"name":"Nicaragua","abbreviation":"NI"},{"name":"Niger","abbreviation":"NE"},{"name":"Nigeria","abbreviation":"NG"},{"name":"Niue","abbreviation":"NU"},{"name":"Norfolk Island","abbreviation":"NF"},{"name":"North Korea","abbreviation":"KP"},{"name":"North Vietnam","abbreviation":"VD"},{"name":"Northern Mariana Islands","abbreviation":"MP"},{"name":"Norway","abbreviation":"NO"},{"name":"Oman","abbreviation":"OM"},{"name":"Pacific Islands Trust Territory","abbreviation":"PC"},{"name":"Pakistan","abbreviation":"PK"},{"name":"Palau","abbreviation":"PW"},{"name":"Palestinian Territories","abbreviation":"PS"},{"name":"Panama","abbreviation":"PA"},{"name":"Panama Canal Zone","abbreviation":"PZ"},{"name":"Papua New Guinea","abbreviation":"PG"},{"name":"Paraguay","abbreviation":"PY"},{"name":"People's Democratic Republic of Yemen","abbreviation":"YD"},{"name":"Peru","abbreviation":"PE"},{"name":"Philippines","abbreviation":"PH"},{"name":"Pitcairn Islands","abbreviation":"PN"},{"name":"Poland","abbreviation":"PL"},{"name":"Portugal","abbreviation":"PT"},{"name":"Puerto Rico","abbreviation":"PR"},{"name":"Qatar","abbreviation":"QA"},{"name":"Romania","abbreviation":"RO"},{"name":"Russia","abbreviation":"RU"},{"name":"Rwanda","abbreviation":"RW"},{"name":"Runion","abbreviation":"RE"},{"name":"Saint Barthlemy","abbreviation":"BL"},{"name":"Saint Helena","abbreviation":"SH"},{"name":"Saint Kitts and Nevis","abbreviation":"KN"},{"name":"Saint Lucia","abbreviation":"LC"},{"name":"Saint Martin","abbreviation":"MF"},{"name":"Saint Pierre and Miquelon","abbreviation":"PM"},{"name":"Saint Vincent and the Grenadines","abbreviation":"VC"},{"name":"Samoa","abbreviation":"WS"},{"name":"San Marino","abbreviation":"SM"},{"name":"Saudi Arabia","abbreviation":"SA"},{"name":"Senegal","abbreviation":"SN"},{"name":"Serbia","abbreviation":"RS"},{"name":"Serbia and Montenegro","abbreviation":"CS"},{"name":"Seychelles","abbreviation":"SC"},{"name":"Sierra Leone","abbreviation":"SL"},{"name":"Singapore","abbreviation":"SG"},{"name":"Slovakia","abbreviation":"SK"},{"name":"Slovenia","abbreviation":"SI"},{"name":"Solomon Islands","abbreviation":"SB"},{"name":"Somalia","abbreviation":"SO"},{"name":"South Africa","abbreviation":"ZA"},{"name":"South Georgia and the South Sandwich Islands","abbreviation":"GS"},{"name":"South Korea","abbreviation":"KR"},{"name":"Spain","abbreviation":"ES"},{"name":"Sri Lanka","abbreviation":"LK"},{"name":"Sudan","abbreviation":"SD"},{"name":"Suriname","abbreviation":"SR"},{"name":"Svalbard and Jan Mayen","abbreviation":"SJ"},{"name":"Swaziland","abbreviation":"SZ"},{"name":"Sweden","abbreviation":"SE"},{"name":"Switzerland","abbreviation":"CH"},{"name":"Syria","abbreviation":"SY"},{"name":"So Tom and Prncipe","abbreviation":"ST"},{"name":"Taiwan","abbreviation":"TW"},{"name":"Tajikistan","abbreviation":"TJ"},{"name":"Tanzania","abbreviation":"TZ"},{"name":"Thailand","abbreviation":"TH"},{"name":"Timor-Leste","abbreviation":"TL"},{"name":"Togo","abbreviation":"TG"},{"name":"Tokelau","abbreviation":"TK"},{"name":"Tonga","abbreviation":"TO"},{"name":"Trinidad and Tobago","abbreviation":"TT"},{"name":"Tunisia","abbreviation":"TN"},{"name":"Turkey","abbreviation":"TR"},{"name":"Turkmenistan","abbreviation":"TM"},{"name":"Turks and Caicos Islands","abbreviation":"TC"},{"name":"Tuvalu","abbreviation":"TV"},{"name":"U.S. Minor Outlying Islands","abbreviation":"UM"},{"name":"U.S. Miscellaneous Pacific Islands","abbreviation":"PU"},{"name":"U.S. Virgin Islands","abbreviation":"VI"},{"name":"Uganda","abbreviation":"UG"},{"name":"Ukraine","abbreviation":"UA"},{"name":"Union of Soviet Socialist Republics","abbreviation":"SU"},{"name":"United Arab Emirates","abbreviation":"AE"},{"name":"United Kingdom","abbreviation":"GB"},{"name":"United States","abbreviation":"US"},{"name":"Unknown or Invalid Region","abbreviation":"ZZ"},{"name":"Uruguay","abbreviation":"UY"},{"name":"Uzbekistan","abbreviation":"UZ"},{"name":"Vanuatu","abbreviation":"VU"},{"name":"Vatican City","abbreviation":"VA"},{"name":"Venezuela","abbreviation":"VE"},{"name":"Vietnam","abbreviation":"VN"},{"name":"Wake Island","abbreviation":"WK"},{"name":"Wallis and Futuna","abbreviation":"WF"},{"name":"Western Sahara","abbreviation":"EH"},{"name":"Yemen","abbreviation":"YE"},{"name":"Zambia","abbreviation":"ZM"},{"name":"Zimbabwe","abbreviation":"ZW"},{"name":"land Islands","abbreviation":"AX"}],

        provinces: {
            "ca": [
                {name: 'Alberta', abbreviation: 'AB'},
                {name: 'British Columbia', abbreviation: 'BC'},
                {name: 'Manitoba', abbreviation: 'MB'},
                {name: 'New Brunswick', abbreviation: 'NB'},
                {name: 'Newfoundland and Labrador', abbreviation: 'NL'},
                {name: 'Nova Scotia', abbreviation: 'NS'},
                {name: 'Ontario', abbreviation: 'ON'},
                {name: 'Prince Edward Island', abbreviation: 'PE'},
                {name: 'Quebec', abbreviation: 'QC'},
                {name: 'Saskatchewan', abbreviation: 'SK'},

                // The case could be made that the following are not actually provinces
                // since they are technically considered "territories" however they all
                // look the same on an envelope!
                {name: 'Northwest Territories', abbreviation: 'NT'},
                {name: 'Nunavut', abbreviation: 'NU'},
                {name: 'Yukon', abbreviation: 'YT'}
            ],
            "it": [
                { name: "Agrigento", abbreviation: "AG", code: 84 },
                { name: "Alessandria", abbreviation: "AL", code: 6 },
                { name: "Ancona", abbreviation: "AN", code: 42 },
                { name: "Aosta", abbreviation: "AO", code: 7 },
                { name: "L'Aquila", abbreviation: "AQ", code: 66 },
                { name: "Arezzo", abbreviation: "AR", code: 51 },
                { name: "Ascoli-Piceno", abbreviation: "AP", code: 44 },
                { name: "Asti", abbreviation: "AT", code: 5 },
                { name: "Avellino", abbreviation: "AV", code: 64 },
                { name: "Bari", abbreviation: "BA", code: 72 },
                { name: "Barletta-Andria-Trani", abbreviation: "BT", code: 72 },
                { name: "Belluno", abbreviation: "BL", code: 25 },
                { name: "Benevento", abbreviation: "BN", code: 62 },
                { name: "Bergamo", abbreviation: "BG", code: 16 },
                { name: "Biella", abbreviation: "BI", code: 96 },
                { name: "Bologna", abbreviation: "BO", code: 37 },
                { name: "Bolzano", abbreviation: "BZ", code: 21 },
                { name: "Brescia", abbreviation: "BS", code: 17 },
                { name: "Brindisi", abbreviation: "BR", code: 74 },
                { name: "Cagliari", abbreviation: "CA", code: 92 },
                { name: "Caltanissetta", abbreviation: "CL", code: 85 },
                { name: "Campobasso", abbreviation: "CB", code: 70 },
                { name: "Carbonia Iglesias", abbreviation: "CI", code: 70 },
                { name: "Caserta", abbreviation: "CE", code: 61 },
                { name: "Catania", abbreviation: "CT", code: 87 },
                { name: "Catanzaro", abbreviation: "CZ", code: 79 },
                { name: "Chieti", abbreviation: "CH", code: 69 },
                { name: "Como", abbreviation: "CO", code: 13 },
                { name: "Cosenza", abbreviation: "CS", code: 78 },
                { name: "Cremona", abbreviation: "CR", code: 19 },
                { name: "Crotone", abbreviation: "KR", code: 101 },
                { name: "Cuneo", abbreviation: "CN", code: 4 },
                { name: "Enna", abbreviation: "EN", code: 86 },
                { name: "Fermo", abbreviation: "FM", code: 86 },
                { name: "Ferrara", abbreviation: "FE", code: 38 },
                { name: "Firenze", abbreviation: "FI", code: 48 },
                { name: "Foggia", abbreviation: "FG", code: 71 },
                { name: "Forli-Cesena", abbreviation: "FC", code: 71 },
                { name: "Frosinone", abbreviation: "FR", code: 60 },
                { name: "Genova", abbreviation: "GE", code: 10 },
                { name: "Gorizia", abbreviation: "GO", code: 31 },
                { name: "Grosseto", abbreviation: "GR", code: 53 },
                { name: "Imperia", abbreviation: "IM", code: 8 },
                { name: "Isernia", abbreviation: "IS", code: 94 },
                { name: "La-Spezia", abbreviation: "SP", code: 66 },
                { name: "Latina", abbreviation: "LT", code: 59 },
                { name: "Lecce", abbreviation: "LE", code: 75 },
                { name: "Lecco", abbreviation: "LC", code: 97 },
                { name: "Livorno", abbreviation: "LI", code: 49 },
                { name: "Lodi", abbreviation: "LO", code: 98 },
                { name: "Lucca", abbreviation: "LU", code: 46 },
                { name: "Macerata", abbreviation: "MC", code: 43 },
                { name: "Mantova", abbreviation: "MN", code: 20 },
                { name: "Massa-Carrara", abbreviation: "MS", code: 45 },
                { name: "Matera", abbreviation: "MT", code: 77 },
                { name: "Medio Campidano", abbreviation: "VS", code: 77 },
                { name: "Messina", abbreviation: "ME", code: 83 },
                { name: "Milano", abbreviation: "MI", code: 15 },
                { name: "Modena", abbreviation: "MO", code: 36 },
                { name: "Monza-Brianza", abbreviation: "MB", code: 36 },
                { name: "Napoli", abbreviation: "NA", code: 63 },
                { name: "Novara", abbreviation: "NO", code: 3 },
                { name: "Nuoro", abbreviation: "NU", code: 91 },
                { name: "Ogliastra", abbreviation: "OG", code: 91 },
                { name: "Olbia Tempio", abbreviation: "OT", code: 91 },
                { name: "Oristano", abbreviation: "OR", code: 95 },
                { name: "Padova", abbreviation: "PD", code: 28 },
                { name: "Palermo", abbreviation: "PA", code: 82 },
                { name: "Parma", abbreviation: "PR", code: 34 },
                { name: "Pavia", abbreviation: "PV", code: 18 },
                { name: "Perugia", abbreviation: "PG", code: 54 },
                { name: "Pesaro-Urbino", abbreviation: "PU", code: 41 },
                { name: "Pescara", abbreviation: "PE", code: 68 },
                { name: "Piacenza", abbreviation: "PC", code: 33 },
                { name: "Pisa", abbreviation: "PI", code: 50 },
                { name: "Pistoia", abbreviation: "PT", code: 47 },
                { name: "Pordenone", abbreviation: "PN", code: 93 },
                { name: "Potenza", abbreviation: "PZ", code: 76 },
                { name: "Prato", abbreviation: "PO", code: 100 },
                { name: "Ragusa", abbreviation: "RG", code: 88 },
                { name: "Ravenna", abbreviation: "RA", code: 39 },
                { name: "Reggio-Calabria", abbreviation: "RC", code: 35 },
                { name: "Reggio-Emilia", abbreviation: "RE", code: 35 },
                { name: "Rieti", abbreviation: "RI", code: 57 },
                { name: "Rimini", abbreviation: "RN", code: 99 },
                { name: "Roma", abbreviation: "Roma", code: 58 },
                { name: "Rovigo", abbreviation: "RO", code: 29 },
                { name: "Salerno", abbreviation: "SA", code: 65 },
                { name: "Sassari", abbreviation: "SS", code: 90 },
                { name: "Savona", abbreviation: "SV", code: 9 },
                { name: "Siena", abbreviation: "SI", code: 52 },
                { name: "Siracusa", abbreviation: "SR", code: 89 },
                { name: "Sondrio", abbreviation: "SO", code: 14 },
                { name: "Taranto", abbreviation: "TA", code: 73 },
                { name: "Teramo", abbreviation: "TE", code: 67 },
                { name: "Terni", abbreviation: "TR", code: 55 },
                { name: "Torino", abbreviation: "TO", code: 1 },
                { name: "Trapani", abbreviation: "TP", code: 81 },
                { name: "Trento", abbreviation: "TN", code: 22 },
                { name: "Treviso", abbreviation: "TV", code: 26 },
                { name: "Trieste", abbreviation: "TS", code: 32 },
                { name: "Udine", abbreviation: "UD", code: 30 },
                { name: "Varese", abbreviation: "VA", code: 12 },
                { name: "Venezia", abbreviation: "VE", code: 27 },
                { name: "Verbania", abbreviation: "VB", code: 27 },
                { name: "Vercelli", abbreviation: "VC", code: 2 },
                { name: "Verona", abbreviation: "VR", code: 23 },
                { name: "Vibo-Valentia", abbreviation: "VV", code: 102 },
                { name: "Vicenza", abbreviation: "VI", code: 24 },
                { name: "Viterbo", abbreviation: "VT", code: 56 }   
            ]
        },

            // from: https://github.com/samsargent/Useful-Autocomplete-Data/blob/master/data/nationalities.json
        nationalities: [
           {name: 'Afghan'},
           {name: 'Albanian'},
           {name: 'Algerian'},
           {name: 'American'},
           {name: 'Andorran'},
           {name: 'Angolan'},
           {name: 'Antiguans'},
           {name: 'Argentinean'},
           {name: 'Armenian'},
           {name: 'Australian'},
           {name: 'Austrian'},
           {name: 'Azerbaijani'},
           {name: 'Bahami'},
           {name: 'Bahraini'},
           {name: 'Bangladeshi'},
           {name: 'Barbadian'},
           {name: 'Barbudans'},
           {name: 'Batswana'},
           {name: 'Belarusian'},
           {name: 'Belgian'},
           {name: 'Belizean'},
           {name: 'Beninese'},
           {name: 'Bhutanese'},
           {name: 'Bolivian'},
           {name: 'Bosnian'},
           {name: 'Brazilian'},
           {name: 'British'},
           {name: 'Bruneian'},
           {name: 'Bulgarian'},
           {name: 'Burkinabe'},
           {name: 'Burmese'},
           {name: 'Burundian'},
           {name: 'Cambodian'},
           {name: 'Cameroonian'},
           {name: 'Canadian'},
           {name: 'Cape Verdean'},
           {name: 'Central African'},
           {name: 'Chadian'},
           {name: 'Chilean'},
           {name: 'Chinese'},
           {name: 'Colombian'},
           {name: 'Comoran'},
           {name: 'Congolese'},
           {name: 'Costa Rican'},
           {name: 'Croatian'},
           {name: 'Cuban'},
           {name: 'Cypriot'},
           {name: 'Czech'},
           {name: 'Danish'},
           {name: 'Djibouti'},
           {name: 'Dominican'},
           {name: 'Dutch'},
           {name: 'East Timorese'},
           {name: 'Ecuadorean'},
           {name: 'Egyptian'},
           {name: 'Emirian'},
           {name: 'Equatorial Guinean'},
           {name: 'Eritrean'},
           {name: 'Estonian'},
           {name: 'Ethiopian'},
           {name: 'Fijian'},
           {name: 'Filipino'},
           {name: 'Finnish'},
           {name: 'French'},
           {name: 'Gabonese'},
           {name: 'Gambian'},
           {name: 'Georgian'},
           {name: 'German'},
           {name: 'Ghanaian'},
           {name: 'Greek'},
           {name: 'Grenadian'},
           {name: 'Guatemalan'},
           {name: 'Guinea-Bissauan'},
           {name: 'Guinean'},
           {name: 'Guyanese'},
           {name: 'Haitian'},
           {name: 'Herzegovinian'},
           {name: 'Honduran'},
           {name: 'Hungarian'},
           {name: 'I-Kiribati'},
           {name: 'Icelander'},
           {name: 'Indian'},
           {name: 'Indonesian'},
           {name: 'Iranian'},
           {name: 'Iraqi'},
           {name: 'Irish'},
           {name: 'Israeli'},
           {name: 'Italian'},
           {name: 'Ivorian'},
           {name: 'Jamaican'},
           {name: 'Japanese'},
           {name: 'Jordanian'},
           {name: 'Kazakhstani'},
           {name: 'Kenyan'},
           {name: 'Kittian and Nevisian'},
           {name: 'Kuwaiti'},
           {name: 'Kyrgyz'},
           {name: 'Laotian'},
           {name: 'Latvian'},
           {name: 'Lebanese'},
           {name: 'Liberian'},
           {name: 'Libyan'},
           {name: 'Liechtensteiner'},
           {name: 'Lithuanian'},
           {name: 'Luxembourger'},
           {name: 'Macedonian'},
           {name: 'Malagasy'},
           {name: 'Malawian'},
           {name: 'Malaysian'},
           {name: 'Maldivan'},
           {name: 'Malian'},
           {name: 'Maltese'},
           {name: 'Marshallese'},
           {name: 'Mauritanian'},
           {name: 'Mauritian'},
           {name: 'Mexican'},
           {name: 'Micronesian'},
           {name: 'Moldovan'},
           {name: 'Monacan'},
           {name: 'Mongolian'},
           {name: 'Moroccan'},
           {name: 'Mosotho'},
           {name: 'Motswana'},
           {name: 'Mozambican'},
           {name: 'Namibian'},
           {name: 'Nauruan'},
           {name: 'Nepalese'},
           {name: 'New Zealander'},
           {name: 'Nicaraguan'},
           {name: 'Nigerian'},
           {name: 'Nigerien'},
           {name: 'North Korean'},
           {name: 'Northern Irish'},
           {name: 'Norwegian'},
           {name: 'Omani'},
           {name: 'Pakistani'},
           {name: 'Palauan'},
           {name: 'Panamanian'},
           {name: 'Papua New Guinean'},
           {name: 'Paraguayan'},
           {name: 'Peruvian'},
           {name: 'Polish'},
           {name: 'Portuguese'},
           {name: 'Qatari'},
           {name: 'Romani'},          
           {name: 'Russian'},
           {name: 'Rwandan'},
           {name: 'Saint Lucian'},
           {name: 'Salvadoran'},
           {name: 'Samoan'},
           {name: 'San Marinese'},
           {name: 'Sao Tomean'},
           {name: 'Saudi'},
           {name: 'Scottish'},
           {name: 'Senegalese'},
           {name: 'Serbian'},
           {name: 'Seychellois'},
           {name: 'Sierra Leonean'},
           {name: 'Singaporean'},
           {name: 'Slovakian'},
           {name: 'Slovenian'},
           {name: 'Solomon Islander'},
           {name: 'Somali'},
           {name: 'South African'},
           {name: 'South Korean'},
           {name: 'Spanish'},
           {name: 'Sri Lankan'},
           {name: 'Sudanese'},
           {name: 'Surinamer'},
           {name: 'Swazi'},
           {name: 'Swedish'},
           {name: 'Swiss'},
           {name: 'Syrian'},
           {name: 'Taiwanese'},
           {name: 'Tajik'},
           {name: 'Tanzanian'},
           {name: 'Thai'},
           {name: 'Togolese'},
           {name: 'Tongan'},
           {name: 'Trinidadian or Tobagonian'},
           {name: 'Tunisian'},
           {name: 'Turkish'},
           {name: 'Tuvaluan'},
           {name: 'Ugandan'},
           {name: 'Ukrainian'},
           {name: 'Uruguaya'},
           {name: 'Uzbekistani'},
           {name: 'Venezuela'},
           {name: 'Vietnamese'},
           {name: 'Wels'},
           {name: 'Yemenit'},
           {name: 'Zambia'},
           {name: 'Zimbabwe'},
        ],

        us_states_and_dc: [
            {name: 'Alabama', abbreviation: 'AL'},
            {name: 'Alaska', abbreviation: 'AK'},
            {name: 'Arizona', abbreviation: 'AZ'},
            {name: 'Arkansas', abbreviation: 'AR'},
            {name: 'California', abbreviation: 'CA'},
            {name: 'Colorado', abbreviation: 'CO'},
            {name: 'Connecticut', abbreviation: 'CT'},
            {name: 'Delaware', abbreviation: 'DE'},
            {name: 'District of Columbia', abbreviation: 'DC'},
            {name: 'Florida', abbreviation: 'FL'},
            {name: 'Georgia', abbreviation: 'GA'},
            {name: 'Hawaii', abbreviation: 'HI'},
            {name: 'Idaho', abbreviation: 'ID'},
            {name: 'Illinois', abbreviation: 'IL'},
            {name: 'Indiana', abbreviation: 'IN'},
            {name: 'Iowa', abbreviation: 'IA'},
            {name: 'Kansas', abbreviation: 'KS'},
            {name: 'Kentucky', abbreviation: 'KY'},
            {name: 'Louisiana', abbreviation: 'LA'},
            {name: 'Maine', abbreviation: 'ME'},
            {name: 'Maryland', abbreviation: 'MD'},
            {name: 'Massachusetts', abbreviation: 'MA'},
            {name: 'Michigan', abbreviation: 'MI'},
            {name: 'Minnesota', abbreviation: 'MN'},
            {name: 'Mississippi', abbreviation: 'MS'},
            {name: 'Missouri', abbreviation: 'MO'},
            {name: 'Montana', abbreviation: 'MT'},
            {name: 'Nebraska', abbreviation: 'NE'},
            {name: 'Nevada', abbreviation: 'NV'},
            {name: 'New Hampshire', abbreviation: 'NH'},
            {name: 'New Jersey', abbreviation: 'NJ'},
            {name: 'New Mexico', abbreviation: 'NM'},
            {name: 'New York', abbreviation: 'NY'},
            {name: 'North Carolina', abbreviation: 'NC'},
            {name: 'North Dakota', abbreviation: 'ND'},
            {name: 'Ohio', abbreviation: 'OH'},
            {name: 'Oklahoma', abbreviation: 'OK'},
            {name: 'Oregon', abbreviation: 'OR'},
            {name: 'Pennsylvania', abbreviation: 'PA'},
            {name: 'Rhode Island', abbreviation: 'RI'},
            {name: 'South Carolina', abbreviation: 'SC'},
            {name: 'South Dakota', abbreviation: 'SD'},
            {name: 'Tennessee', abbreviation: 'TN'},
            {name: 'Texas', abbreviation: 'TX'},
            {name: 'Utah', abbreviation: 'UT'},
            {name: 'Vermont', abbreviation: 'VT'},
            {name: 'Virginia', abbreviation: 'VA'},
            {name: 'Washington', abbreviation: 'WA'},
            {name: 'West Virginia', abbreviation: 'WV'},
            {name: 'Wisconsin', abbreviation: 'WI'},
            {name: 'Wyoming', abbreviation: 'WY'}
        ],

        territories: [
            {name: 'American Samoa', abbreviation: 'AS'},
            {name: 'Federated States of Micronesia', abbreviation: 'FM'},
            {name: 'Guam', abbreviation: 'GU'},
            {name: 'Marshall Islands', abbreviation: 'MH'},
            {name: 'Northern Mariana Islands', abbreviation: 'MP'},
            {name: 'Puerto Rico', abbreviation: 'PR'},
            {name: 'Virgin Islands, U.S.', abbreviation: 'VI'}
        ],

        armed_forces: [
            {name: 'Armed Forces Europe', abbreviation: 'AE'},
            {name: 'Armed Forces Pacific', abbreviation: 'AP'},
            {name: 'Armed Forces the Americas', abbreviation: 'AA'}
        ],

        country_regions: {
            it: [
                { name: "Valle d'Aosta", abbreviation: "VDA" },
                { name: "Piemonte", abbreviation: "PIE" },
                { name: "Lombardia", abbreviation: "LOM" },
                { name: "Veneto", abbreviation: "VEN" },
                { name: "Trentino Alto Adige", abbreviation: "TAA" },
                { name: "Friuli Venezia Giulia", abbreviation: "FVG" },
                { name: "Liguria", abbreviation: "LIG" },
                { name: "Emilia Romagna", abbreviation: "EMR" },
                { name: "Toscana", abbreviation: "TOS" },
                { name: "Umbria", abbreviation: "UMB" },
                { name: "Marche", abbreviation: "MAR" },
                { name: "Abruzzo", abbreviation: "ABR" },
                { name: "Lazio", abbreviation: "LAZ" },
                { name: "Campania", abbreviation: "CAM" },
                { name: "Puglia", abbreviation: "PUG" },
                { name: "Basilicata", abbreviation: "BAS" },
                { name: "Molise", abbreviation: "MOL" },
                { name: "Calabria", abbreviation: "CAL" },
                { name: "Sicilia", abbreviation: "SIC" },
                { name: "Sardegna", abbreviation: "SAR" }
            ]
        },

        street_suffixes: {
            'us': [
                {name: 'Avenue', abbreviation: 'Ave'},
                {name: 'Boulevard', abbreviation: 'Blvd'},
                {name: 'Center', abbreviation: 'Ctr'},
                {name: 'Circle', abbreviation: 'Cir'},
                {name: 'Court', abbreviation: 'Ct'},
                {name: 'Drive', abbreviation: 'Dr'},
                {name: 'Extension', abbreviation: 'Ext'},
                {name: 'Glen', abbreviation: 'Gln'},
                {name: 'Grove', abbreviation: 'Grv'},
                {name: 'Heights', abbreviation: 'Hts'},
                {name: 'Highway', abbreviation: 'Hwy'},
                {name: 'Junction', abbreviation: 'Jct'},
                {name: 'Key', abbreviation: 'Key'},
                {name: 'Lane', abbreviation: 'Ln'},
                {name: 'Loop', abbreviation: 'Loop'},
                {name: 'Manor', abbreviation: 'Mnr'},
                {name: 'Mill', abbreviation: 'Mill'},
                {name: 'Park', abbreviation: 'Park'},
                {name: 'Parkway', abbreviation: 'Pkwy'},
                {name: 'Pass', abbreviation: 'Pass'},
                {name: 'Path', abbreviation: 'Path'},
                {name: 'Pike', abbreviation: 'Pike'},
                {name: 'Place', abbreviation: 'Pl'},
                {name: 'Plaza', abbreviation: 'Plz'},
                {name: 'Point', abbreviation: 'Pt'},
                {name: 'Ridge', abbreviation: 'Rdg'},
                {name: 'River', abbreviation: 'Riv'},
                {name: 'Road', abbreviation: 'Rd'},
                {name: 'Square', abbreviation: 'Sq'},
                {name: 'Street', abbreviation: 'St'},
                {name: 'Terrace', abbreviation: 'Ter'},
                {name: 'Trail', abbreviation: 'Trl'},
                {name: 'Turnpike', abbreviation: 'Tpke'},
                {name: 'View', abbreviation: 'Vw'},
                {name: 'Way', abbreviation: 'Way'}
            ],
            'it': [
                { name: 'Accesso', abbreviation: 'Acc.' },
                { name: 'Alzaia', abbreviation: 'Alz.' },
                { name: 'Arco', abbreviation: 'Arco' },
                { name: 'Archivolto', abbreviation: 'Acv.' },
                { name: 'Arena', abbreviation: 'Arena' },
                { name: 'Argine', abbreviation: 'Argine' },
                { name: 'Bacino', abbreviation: 'Bacino' },
                { name: 'Banchi', abbreviation: 'Banchi' },
                { name: 'Banchina', abbreviation: 'Ban.' },
                { name: 'Bastioni', abbreviation: 'Bas.' },
                { name: 'Belvedere', abbreviation: 'Belv.' },
                { name: 'Borgata', abbreviation: 'B.ta' },
                { name: 'Borgo', abbreviation: 'B.go' },
                { name: 'Calata', abbreviation: 'Cal.' },
                { name: 'Calle', abbreviation: 'Calle' },
                { name: 'Campiello', abbreviation: 'Cam.' },
                { name: 'Campo', abbreviation: 'Cam.' },
                { name: 'Canale', abbreviation: 'Can.' },
                { name: 'Carraia', abbreviation: 'Carr.' },
                { name: 'Cascina', abbreviation: 'Cascina' },
                { name: 'Case sparse', abbreviation: 'c.s.' },
                { name: 'Cavalcavia', abbreviation: 'Cv.' },
                { name: 'Circonvallazione', abbreviation: 'Cv.' },
                { name: 'Complanare', abbreviation: 'C.re' },
                { name: 'Contrada', abbreviation: 'C.da' },
                { name: 'Corso', abbreviation: 'C.so' },
                { name: 'Corte', abbreviation: 'C.te' },
                { name: 'Cortile', abbreviation: 'C.le' },
                { name: 'Diramazione', abbreviation: 'Dir.' },
                { name: 'Fondaco', abbreviation: 'F.co' },
                { name: 'Fondamenta', abbreviation: 'F.ta' },
                { name: 'Fondo', abbreviation: 'F.do' },
                { name: 'Frazione', abbreviation: 'Fr.' },
                { name: 'Isola', abbreviation: 'Is.' },
                { name: 'Largo', abbreviation: 'L.go' },
                { name: 'Litoranea', abbreviation: 'Lit.' },
                { name: 'Lungolago', abbreviation: 'L.go lago' },
                { name: 'Lungo Po', abbreviation: 'l.go Po' },
                { name: 'Molo', abbreviation: 'Molo' },
                { name: 'Mura', abbreviation: 'Mura' },
                { name: 'Passaggio privato', abbreviation: 'pass. priv.' },
                { name: 'Passeggiata', abbreviation: 'Pass.' },
                { name: 'Piazza', abbreviation: 'P.zza' },
                { name: 'Piazzale', abbreviation: 'P.le' },
                { name: 'Ponte', abbreviation: 'P.te' },
                { name: 'Portico', abbreviation: 'P.co' },
                { name: 'Rampa', abbreviation: 'Rampa' },
                { name: 'Regione', abbreviation: 'Reg.' },
                { name: 'Rione', abbreviation: 'R.ne' },
                { name: 'Rio', abbreviation: 'Rio' },
                { name: 'Ripa', abbreviation: 'Ripa' },
                { name: 'Riva', abbreviation: 'Riva' },
                { name: 'Rond', abbreviation: 'Rond' },
                { name: 'Rotonda', abbreviation: 'Rot.' },
                { name: 'Sagrato', abbreviation: 'Sagr.' },
                { name: 'Salita', abbreviation: 'Sal.' },
                { name: 'Scalinata', abbreviation: 'Scal.' },
                { name: 'Scalone', abbreviation: 'Scal.' },
                { name: 'Slargo', abbreviation: 'Sl.' },
                { name: 'Sottoportico', abbreviation: 'Sott.' },
                { name: 'Strada', abbreviation: 'Str.' },
                { name: 'Stradale', abbreviation: 'Str.le' },
                { name: 'Strettoia', abbreviation: 'Strett.' },
                { name: 'Traversa', abbreviation: 'Trav.' },
                { name: 'Via', abbreviation: 'V.' },
                { name: 'Viale', abbreviation: 'V.le' },
                { name: 'Vicinale', abbreviation: 'Vic.le' },
                { name: 'Vicolo', abbreviation: 'Vic.' }
            ]
        },

        months: [
            {name: 'January', short_name: 'Jan', numeric: '01', days: 31},
            // Not messing with leap years...
            {name: 'February', short_name: 'Feb', numeric: '02', days: 28},
            {name: 'March', short_name: 'Mar', numeric: '03', days: 31},
            {name: 'April', short_name: 'Apr', numeric: '04', days: 30},
            {name: 'May', short_name: 'May', numeric: '05', days: 31},
            {name: 'June', short_name: 'Jun', numeric: '06', days: 30},
            {name: 'July', short_name: 'Jul', numeric: '07', days: 31},
            {name: 'August', short_name: 'Aug', numeric: '08', days: 31},
            {name: 'September', short_name: 'Sep', numeric: '09', days: 30},
            {name: 'October', short_name: 'Oct', numeric: '10', days: 31},
            {name: 'November', short_name: 'Nov', numeric: '11', days: 30},
            {name: 'December', short_name: 'Dec', numeric: '12', days: 31}
        ],

        // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
        cc_types: [
            {name: "American Express", short_name: 'amex', prefix: '34', length: 15},
            {name: "Bankcard", short_name: 'bankcard', prefix: '5610', length: 16},
            {name: "China UnionPay", short_name: 'chinaunion', prefix: '62', length: 16},
            {name: "Diners Club Carte Blanche", short_name: 'dccarte', prefix: '300', length: 14},
            {name: "Diners Club enRoute", short_name: 'dcenroute', prefix: '2014', length: 15},
            {name: "Diners Club International", short_name: 'dcintl', prefix: '36', length: 14},
            {name: "Diners Club United States & Canada", short_name: 'dcusc', prefix: '54', length: 16},
            {name: "Discover Card", short_name: 'discover', prefix: '6011', length: 16},
            {name: "InstaPayment", short_name: 'instapay', prefix: '637', length: 16},
            {name: "JCB", short_name: 'jcb', prefix: '3528', length: 16},
            {name: "Laser", short_name: 'laser', prefix: '6304', length: 16},
            {name: "Maestro", short_name: 'maestro', prefix: '5018', length: 16},
            {name: "Mastercard", short_name: 'mc', prefix: '51', length: 16},
            {name: "Solo", short_name: 'solo', prefix: '6334', length: 16},
            {name: "Switch", short_name: 'switch', prefix: '4903', length: 16},
            {name: "Visa", short_name: 'visa', prefix: '4', length: 16},
            {name: "Visa Electron", short_name: 'electron', prefix: '4026', length: 16}
        ],

        //return all world currency by ISO 4217
        currency_types: [
            {'code' : 'AED', 'name' : 'United Arab Emirates Dirham'},
            {'code' : 'AFN', 'name' : 'Afghanistan Afghani'},
            {'code' : 'ALL', 'name' : 'Albania Lek'},
            {'code' : 'AMD', 'name' : 'Armenia Dram'},
            {'code' : 'ANG', 'name' : 'Netherlands Antilles Guilder'},
            {'code' : 'AOA', 'name' : 'Angola Kwanza'},
            {'code' : 'ARS', 'name' : 'Argentina Peso'},
            {'code' : 'AUD', 'name' : 'Australia Dollar'},
            {'code' : 'AWG', 'name' : 'Aruba Guilder'},
            {'code' : 'AZN', 'name' : 'Azerbaijan New Manat'},
            {'code' : 'BAM', 'name' : 'Bosnia and Herzegovina Convertible Marka'},
            {'code' : 'BBD', 'name' : 'Barbados Dollar'},
            {'code' : 'BDT', 'name' : 'Bangladesh Taka'},
            {'code' : 'BGN', 'name' : 'Bulgaria Lev'},
            {'code' : 'BHD', 'name' : 'Bahrain Dinar'},
            {'code' : 'BIF', 'name' : 'Burundi Franc'},
            {'code' : 'BMD', 'name' : 'Bermuda Dollar'},
            {'code' : 'BND', 'name' : 'Brunei Darussalam Dollar'},
            {'code' : 'BOB', 'name' : 'Bolivia Boliviano'},
            {'code' : 'BRL', 'name' : 'Brazil Real'},
            {'code' : 'BSD', 'name' : 'Bahamas Dollar'},
            {'code' : 'BTN', 'name' : 'Bhutan Ngultrum'},
            {'code' : 'BWP', 'name' : 'Botswana Pula'},
            {'code' : 'BYR', 'name' : 'Belarus Ruble'},
            {'code' : 'BZD', 'name' : 'Belize Dollar'},
            {'code' : 'CAD', 'name' : 'Canada Dollar'},
            {'code' : 'CDF', 'name' : 'Congo/Kinshasa Franc'},
            {'code' : 'CHF', 'name' : 'Switzerland Franc'},
            {'code' : 'CLP', 'name' : 'Chile Peso'},
            {'code' : 'CNY', 'name' : 'China Yuan Renminbi'},
            {'code' : 'COP', 'name' : 'Colombia Peso'},
            {'code' : 'CRC', 'name' : 'Costa Rica Colon'},
            {'code' : 'CUC', 'name' : 'Cuba Convertible Peso'},
            {'code' : 'CUP', 'name' : 'Cuba Peso'},
            {'code' : 'CVE', 'name' : 'Cape Verde Escudo'},
            {'code' : 'CZK', 'name' : 'Czech Republic Koruna'},
            {'code' : 'DJF', 'name' : 'Djibouti Franc'},
            {'code' : 'DKK', 'name' : 'Denmark Krone'},
            {'code' : 'DOP', 'name' : 'Dominican Republic Peso'},
            {'code' : 'DZD', 'name' : 'Algeria Dinar'},
            {'code' : 'EGP', 'name' : 'Egypt Pound'},
            {'code' : 'ERN', 'name' : 'Eritrea Nakfa'},
            {'code' : 'ETB', 'name' : 'Ethiopia Birr'},
            {'code' : 'EUR', 'name' : 'Euro Member Countries'},
            {'code' : 'FJD', 'name' : 'Fiji Dollar'},
            {'code' : 'FKP', 'name' : 'Falkland Islands (Malvinas) Pound'},
            {'code' : 'GBP', 'name' : 'United Kingdom Pound'},
            {'code' : 'GEL', 'name' : 'Georgia Lari'},
            {'code' : 'GGP', 'name' : 'Guernsey Pound'},
            {'code' : 'GHS', 'name' : 'Ghana Cedi'},
            {'code' : 'GIP', 'name' : 'Gibraltar Pound'},
            {'code' : 'GMD', 'name' : 'Gambia Dalasi'},
            {'code' : 'GNF', 'name' : 'Guinea Franc'},
            {'code' : 'GTQ', 'name' : 'Guatemala Quetzal'},
            {'code' : 'GYD', 'name' : 'Guyana Dollar'},
            {'code' : 'HKD', 'name' : 'Hong Kong Dollar'},
            {'code' : 'HNL', 'name' : 'Honduras Lempira'},
            {'code' : 'HRK', 'name' : 'Croatia Kuna'},
            {'code' : 'HTG', 'name' : 'Haiti Gourde'},
            {'code' : 'HUF', 'name' : 'Hungary Forint'},
            {'code' : 'IDR', 'name' : 'Indonesia Rupiah'},
            {'code' : 'ILS', 'name' : 'Israel Shekel'},
            {'code' : 'IMP', 'name' : 'Isle of Man Pound'},
            {'code' : 'INR', 'name' : 'India Rupee'},
            {'code' : 'IQD', 'name' : 'Iraq Dinar'},
            {'code' : 'IRR', 'name' : 'Iran Rial'},
            {'code' : 'ISK', 'name' : 'Iceland Krona'},
            {'code' : 'JEP', 'name' : 'Jersey Pound'},
            {'code' : 'JMD', 'name' : 'Jamaica Dollar'},
            {'code' : 'JOD', 'name' : 'Jordan Dinar'},
            {'code' : 'JPY', 'name' : 'Japan Yen'},
            {'code' : 'KES', 'name' : 'Kenya Shilling'},
            {'code' : 'KGS', 'name' : 'Kyrgyzstan Som'},
            {'code' : 'KHR', 'name' : 'Cambodia Riel'},
            {'code' : 'KMF', 'name' : 'Comoros Franc'},
            {'code' : 'KPW', 'name' : 'Korea (North) Won'},
            {'code' : 'KRW', 'name' : 'Korea (South) Won'},
            {'code' : 'KWD', 'name' : 'Kuwait Dinar'},
            {'code' : 'KYD', 'name' : 'Cayman Islands Dollar'},
            {'code' : 'KZT', 'name' : 'Kazakhstan Tenge'},
            {'code' : 'LAK', 'name' : 'Laos Kip'},
            {'code' : 'LBP', 'name' : 'Lebanon Pound'},
            {'code' : 'LKR', 'name' : 'Sri Lanka Rupee'},
            {'code' : 'LRD', 'name' : 'Liberia Dollar'},
            {'code' : 'LSL', 'name' : 'Lesotho Loti'},
            {'code' : 'LTL', 'name' : 'Lithuania Litas'},
            {'code' : 'LYD', 'name' : 'Libya Dinar'},
            {'code' : 'MAD', 'name' : 'Morocco Dirham'},
            {'code' : 'MDL', 'name' : 'Moldova Leu'},
            {'code' : 'MGA', 'name' : 'Madagascar Ariary'},
            {'code' : 'MKD', 'name' : 'Macedonia Denar'},
            {'code' : 'MMK', 'name' : 'Myanmar (Burma) Kyat'},
            {'code' : 'MNT', 'name' : 'Mongolia Tughrik'},
            {'code' : 'MOP', 'name' : 'Macau Pataca'},
            {'code' : 'MRO', 'name' : 'Mauritania Ouguiya'},
            {'code' : 'MUR', 'name' : 'Mauritius Rupee'},
            {'code' : 'MVR', 'name' : 'Maldives (Maldive Islands) Rufiyaa'},
            {'code' : 'MWK', 'name' : 'Malawi Kwacha'},
            {'code' : 'MXN', 'name' : 'Mexico Peso'},
            {'code' : 'MYR', 'name' : 'Malaysia Ringgit'},
            {'code' : 'MZN', 'name' : 'Mozambique Metical'},
            {'code' : 'NAD', 'name' : 'Namibia Dollar'},
            {'code' : 'NGN', 'name' : 'Nigeria Naira'},
            {'code' : 'NIO', 'name' : 'Nicaragua Cordoba'},
            {'code' : 'NOK', 'name' : 'Norway Krone'},
            {'code' : 'NPR', 'name' : 'Nepal Rupee'},
            {'code' : 'NZD', 'name' : 'New Zealand Dollar'},
            {'code' : 'OMR', 'name' : 'Oman Rial'},
            {'code' : 'PAB', 'name' : 'Panama Balboa'},
            {'code' : 'PEN', 'name' : 'Peru Nuevo Sol'},
            {'code' : 'PGK', 'name' : 'Papua New Guinea Kina'},
            {'code' : 'PHP', 'name' : 'Philippines Peso'},
            {'code' : 'PKR', 'name' : 'Pakistan Rupee'},
            {'code' : 'PLN', 'name' : 'Poland Zloty'},
            {'code' : 'PYG', 'name' : 'Paraguay Guarani'},
            {'code' : 'QAR', 'name' : 'Qatar Riyal'},
            {'code' : 'RON', 'name' : 'Romania New Leu'},
            {'code' : 'RSD', 'name' : 'Serbia Dinar'},
            {'code' : 'RUB', 'name' : 'Russia Ruble'},
            {'code' : 'RWF', 'name' : 'Rwanda Franc'},
            {'code' : 'SAR', 'name' : 'Saudi Arabia Riyal'},
            {'code' : 'SBD', 'name' : 'Solomon Islands Dollar'},
            {'code' : 'SCR', 'name' : 'Seychelles Rupee'},
            {'code' : 'SDG', 'name' : 'Sudan Pound'},
            {'code' : 'SEK', 'name' : 'Sweden Krona'},
            {'code' : 'SGD', 'name' : 'Singapore Dollar'},
            {'code' : 'SHP', 'name' : 'Saint Helena Pound'},
            {'code' : 'SLL', 'name' : 'Sierra Leone Leone'},
            {'code' : 'SOS', 'name' : 'Somalia Shilling'},
            {'code' : 'SPL', 'name' : 'Seborga Luigino'},
            {'code' : 'SRD', 'name' : 'Suriname Dollar'},
            {'code' : 'STD', 'name' : 'So Tom and Prncipe Dobra'},
            {'code' : 'SVC', 'name' : 'El Salvador Colon'},
            {'code' : 'SYP', 'name' : 'Syria Pound'},
            {'code' : 'SZL', 'name' : 'Swaziland Lilangeni'},
            {'code' : 'THB', 'name' : 'Thailand Baht'},
            {'code' : 'TJS', 'name' : 'Tajikistan Somoni'},
            {'code' : 'TMT', 'name' : 'Turkmenistan Manat'},
            {'code' : 'TND', 'name' : 'Tunisia Dinar'},
            {'code' : 'TOP', 'name' : 'Tonga Pa\'anga'},
            {'code' : 'TRY', 'name' : 'Turkey Lira'},
            {'code' : 'TTD', 'name' : 'Trinidad and Tobago Dollar'},
            {'code' : 'TVD', 'name' : 'Tuvalu Dollar'},
            {'code' : 'TWD', 'name' : 'Taiwan New Dollar'},
            {'code' : 'TZS', 'name' : 'Tanzania Shilling'},
            {'code' : 'UAH', 'name' : 'Ukraine Hryvnia'},
            {'code' : 'UGX', 'name' : 'Uganda Shilling'},
            {'code' : 'USD', 'name' : 'United States Dollar'},
            {'code' : 'UYU', 'name' : 'Uruguay Peso'},
            {'code' : 'UZS', 'name' : 'Uzbekistan Som'},
            {'code' : 'VEF', 'name' : 'Venezuela Bolivar'},
            {'code' : 'VND', 'name' : 'Viet Nam Dong'},
            {'code' : 'VUV', 'name' : 'Vanuatu Vatu'},
            {'code' : 'WST', 'name' : 'Samoa Tala'},
            {'code' : 'XAF', 'name' : 'Communaut Financire Africaine (BEAC) CFA Franc BEAC'},
            {'code' : 'XCD', 'name' : 'East Caribbean Dollar'},
            {'code' : 'XDR', 'name' : 'International Monetary Fund (IMF) Special Drawing Rights'},
            {'code' : 'XOF', 'name' : 'Communaut Financire Africaine (BCEAO) Franc'},
            {'code' : 'XPF', 'name' : 'Comptoirs Franais du Pacifique (CFP) Franc'},
            {'code' : 'YER', 'name' : 'Yemen Rial'},
            {'code' : 'ZAR', 'name' : 'South Africa Rand'},
            {'code' : 'ZMW', 'name' : 'Zambia Kwacha'},
            {'code' : 'ZWD', 'name' : 'Zimbabwe Dollar'}
        ],
        
        // return the names of all valide colors
        colorNames : [  "AliceBlue", "Black", "Navy", "DarkBlue", "MediumBlue", "Blue", "DarkGreen", "Green", "Teal", "DarkCyan", "DeepSkyBlue", "DarkTurquoise", "MediumSpringGreen", "Lime", "SpringGreen",
            "Aqua", "Cyan", "MidnightBlue", "DodgerBlue", "LightSeaGreen", "ForestGreen", "SeaGreen", "DarkSlateGray", "LimeGreen", "MediumSeaGreen", "Turquoise", "RoyalBlue", "SteelBlue", "DarkSlateBlue", "MediumTurquoise",
            "Indigo", "DarkOliveGreen", "CadetBlue", "CornflowerBlue", "RebeccaPurple", "MediumAquaMarine", "DimGray", "SlateBlue", "OliveDrab", "SlateGray", "LightSlateGray", "MediumSlateBlue", "LawnGreen", "Chartreuse",
            "Aquamarine", "Maroon", "Purple", "Olive", "Gray", "SkyBlue", "LightSkyBlue", "BlueViolet", "DarkRed", "DarkMagenta", "SaddleBrown", "Ivory", "White",
            "DarkSeaGreen", "LightGreen", "MediumPurple", "DarkViolet", "PaleGreen", "DarkOrchid", "YellowGreen", "Sienna", "Brown", "DarkGray", "LightBlue", "GreenYellow", "PaleTurquoise", "LightSteelBlue", "PowderBlue",
            "FireBrick", "DarkGoldenRod", "MediumOrchid", "RosyBrown", "DarkKhaki", "Silver", "MediumVioletRed", "IndianRed", "Peru", "Chocolate", "Tan", "LightGray", "Thistle", "Orchid", "GoldenRod", "PaleVioletRed",
            "Crimson", "Gainsboro", "Plum", "BurlyWood", "LightCyan", "Lavender", "DarkSalmon", "Violet", "PaleGoldenRod", "LightCoral", "Khaki", "AliceBlue", "HoneyDew", "Azure", "SandyBrown", "Wheat", "Beige", "WhiteSmoke",
            "MintCream", "GhostWhite", "Salmon", "AntiqueWhite", "Linen", "LightGoldenRodYellow", "OldLace", "Red", "Fuchsia", "Magenta", "DeepPink", "OrangeRed", "Tomato", "HotPink", "Coral", "DarkOrange", "LightSalmon", "Orange",
            "LightPink", "Pink", "Gold", "PeachPuff", "NavajoWhite", "Moccasin", "Bisque", "MistyRose", "BlanchedAlmond", "PapayaWhip", "LavenderBlush", "SeaShell", "Cornsilk", "LemonChiffon", "FloralWhite", "Snow", "Yellow", "LightYellow"
        ],        

        fileExtension : {
            "raster"    : ["bmp", "gif", "gpl", "ico", "jpeg", "psd", "png", "psp", "raw", "tiff"],
            "vector"    : ["3dv", "amf", "awg", "ai", "cgm", "cdr", "cmx", "dxf", "e2d", "egt", "eps", "fs", "odg", "svg", "xar"],
            "3d"        : ["3dmf", "3dm", "3mf", "3ds", "an8", "aoi", "blend", "cal3d", "cob", "ctm", "iob", "jas", "max", "mb", "mdx", "obj", "x", "x3d"],
            "document"  : ["doc", "docx", "dot", "html", "xml", "odt", "odm", "ott", "csv", "rtf", "tex", "xhtml", "xps"]
        }
    };

    var o_hasOwnProperty = Object.prototype.hasOwnProperty;
    var o_keys = (Object.keys || function(obj) {
      var result = [];
      for (var key in obj) {
        if (o_hasOwnProperty.call(obj, key)) {
          result.push(key);
        }
      }

      return result;
    });

    function _copyObject(source, target) {
      var keys = o_keys(source);
      var key;

      for (var i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        target[key] = source[key] || target[key];
      }
    }

    function _copyArray(source, target) {
      for (var i = 0, l = source.length; i < l; i++) {
        target[i] = source[i];
      }
    }

    function copyObject(source, _target) {
        var isArray = Array.isArray(source);
        var target = _target || (isArray ? new Array(source.length) : {});

        if (isArray) {
          _copyArray(source, target);
        } else {
          _copyObject(source, target);
        }

        return target;
    }

    /** Get the data based on key**/
    Chance.prototype.get = function (name) {
        return copyObject(data[name]);
    };

    // Mac Address
    Chance.prototype.mac_address = function(options){
        // typically mac addresses are separated by ":"
        // however they can also be separated by "-"
        // the network variant uses a dot every fourth byte

        options = initOptions(options);
        if(!options.separator) {
            options.separator =  options.networkVersion ? "." : ":";
        }

        var mac_pool="ABCDEF1234567890",
            mac = "";
        if(!options.networkVersion) {
            mac = this.n(this.string, 6, { pool: mac_pool, length:2 }).join(options.separator);
        } else {
            mac = this.n(this.string, 3, { pool: mac_pool, length:4 }).join(options.separator);
        }

        return mac;
    };

    Chance.prototype.normal = function (options) {
        options = initOptions(options, {mean : 0, dev : 1, pool : []});

        testRange(
            options.pool.constructor !== Array,
            "Chance: The pool option must be a valid array."
        );

        // If a pool has been passed, then we are returning an item from that pool,
        // using the normal distribution settings that were passed in
        if (options.pool.length > 0) {
            return this.normal_pool(options);
        }

        // The Marsaglia Polar method
        var s, u, v, norm,
            mean = options.mean,
            dev = options.dev;

        do {
            // U and V are from the uniform distribution on (-1, 1)
            u = this.random() * 2 - 1;
            v = this.random() * 2 - 1;

            s = u * u + v * v;
        } while (s >= 1);

        // Compute the standard normal variate
        norm = u * Math.sqrt(-2 * Math.log(s) / s);

        // Shape and scale
        return dev * norm + mean;
    };

    Chance.prototype.normal_pool = function(options) {
        var performanceCounter = 0;
        do {
            var idx = Math.round(this.normal({ mean: options.mean, dev: options.dev }));
            if (idx < options.pool.length && idx >= 0) {
                return options.pool[idx];
            } else {
                performanceCounter++;
            }
        } while(performanceCounter < 100);

        throw new RangeError("Chance: Your pool is too small for the given mean and standard deviation. Please adjust.");
    };

    Chance.prototype.radio = function (options) {
        // Initial Letter (Typically Designated by Side of Mississippi River)
        options = initOptions(options, {side : "?"});
        var fl = "";
        switch (options.side.toLowerCase()) {
        case "east":
        case "e":
            fl = "W";
            break;
        case "west":
        case "w":
            fl = "K";
            break;
        default:
            fl = this.character({pool: "KW"});
            break;
        }

        return fl + this.character({alpha: true, casing: "upper"}) +
                this.character({alpha: true, casing: "upper"}) +
                this.character({alpha: true, casing: "upper"});
    };

    // Set the data as key and data or the data map
    Chance.prototype.set = function (name, values) {
        if (typeof name === "string") {
            data[name] = values;
        } else {
            data = copyObject(name, data);
        }
    };

    Chance.prototype.tv = function (options) {
        return this.radio(options);
    };

    // ID number for Brazil companies
    Chance.prototype.cnpj = function () {
        var n = this.n(this.natural, 8, { max: 9 });
        var d1 = 2+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
        d1 = 11 - (d1 % 11);
        if (d1>=10){
            d1 = 0;
        }
        var d2 = d1*2+3+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
        d2 = 11 - (d2 % 11);
        if (d2>=10){
            d2 = 0;
        }
        return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/0001-'+d1+d2;
    };

    // -- End Miscellaneous --

    Chance.prototype.mersenne_twister = function (seed) {
        return new MersenneTwister(seed);
    };

    Chance.prototype.blueimp_md5 = function () {
        return new BlueImpMD5();
    };

    // Mersenne Twister from https://gist.github.com/banksean/300494
    var MersenneTwister = function (seed) {
        if (seed === undefined) {
            // kept random number same size as time used previously to ensure no unexpected results downstream
            seed = Math.floor(Math.random()*Math.pow(10,13));
        }
        /* Period parameters */
        this.N = 624;
        this.M = 397;
        this.MATRIX_A = 0x9908b0df;   /* constant vector a */
        this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
        this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

        this.mt = new Array(this.N); /* the array for the state vector */
        this.mti = this.N + 1; /* mti==N + 1 means mt[N] is not initialized */

        this.init_genrand(seed);
    };

    /* initializes mt[N] with a seed */
    MersenneTwister.prototype.init_genrand = function (s) {
        this.mt[0] = s >>> 0;
        for (this.mti = 1; this.mti < this.N; this.mti++) {
            s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
            this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
            /* In the previous versions, MSBs of the seed affect   */
            /* only MSBs of the array mt[].                        */
            /* 2002/01/09 modified by Makoto Matsumoto             */
            this.mt[this.mti] >>>= 0;
            /* for >32 bit machines */
        }
    };

    /* initialize by an array with array-length */
    /* init_key is the array for initializing keys */
    /* key_length is its length */
    /* slight change for C++, 2004/2/26 */
    MersenneTwister.prototype.init_by_array = function (init_key, key_length) {
        var i = 1, j = 0, k, s;
        this.init_genrand(19650218);
        k = (this.N > key_length ? this.N : key_length);
        for (; k; k--) {
            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) + init_key[j] + j; /* non linear */
            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
            i++;
            j++;
            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
            if (j >= key_length) { j = 0; }
        }
        for (k = this.N - 1; k; k--) {
            s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
            this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i; /* non linear */
            this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
            i++;
            if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
        }

        this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
    };

    /* generates a random number on [0,0xffffffff]-interval */
    MersenneTwister.prototype.genrand_int32 = function () {
        var y;
        var mag01 = new Array(0x0, this.MATRIX_A);
        /* mag01[x] = x * MATRIX_A  for x=0,1 */

        if (this.mti >= this.N) { /* generate N words at one time */
            var kk;

            if (this.mti === this.N + 1) {   /* if init_genrand() has not been called, */
                this.init_genrand(5489); /* a default initial seed is used */
            }
            for (kk = 0; kk < this.N - this.M; kk++) {
                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
                this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            for (;kk < this.N - 1; kk++) {
                y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
                this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            y = (this.mt[this.N - 1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
            this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];

            this.mti = 0;
        }

        y = this.mt[this.mti++];

        /* Tempering */
        y ^= (y >>> 11);
        y ^= (y << 7) & 0x9d2c5680;
        y ^= (y << 15) & 0xefc60000;
        y ^= (y >>> 18);

        return y >>> 0;
    };

    /* generates a random number on [0,0x7fffffff]-interval */
    MersenneTwister.prototype.genrand_int31 = function () {
        return (this.genrand_int32() >>> 1);
    };

    /* generates a random number on [0,1]-real-interval */
    MersenneTwister.prototype.genrand_real1 = function () {
        return this.genrand_int32() * (1.0 / 4294967295.0);
        /* divided by 2^32-1 */
    };

    /* generates a random number on [0,1)-real-interval */
    MersenneTwister.prototype.random = function () {
        return this.genrand_int32() * (1.0 / 4294967296.0);
        /* divided by 2^32 */
    };

    /* generates a random number on (0,1)-real-interval */
    MersenneTwister.prototype.genrand_real3 = function () {
        return (this.genrand_int32() + 0.5) * (1.0 / 4294967296.0);
        /* divided by 2^32 */
    };

    /* generates a random number on [0,1) with 53-bit resolution*/
    MersenneTwister.prototype.genrand_res53 = function () {
        var a = this.genrand_int32()>>>5, b = this.genrand_int32()>>>6;
        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
    };

    // BlueImp MD5 hashing algorithm from https://github.com/blueimp/JavaScript-MD5
    var BlueImpMD5 = function () {};

    BlueImpMD5.prototype.VERSION = '1.0.1';

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    BlueImpMD5.prototype.safe_add = function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    BlueImpMD5.prototype.bit_roll = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
    * These functions implement the five basic operations the algorithm uses.
    */
    BlueImpMD5.prototype.md5_cmn = function (q, a, b, x, s, t) {
        return this.safe_add(this.bit_roll(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);
    };
    BlueImpMD5.prototype.md5_ff = function (a, b, c, d, x, s, t) {
        return this.md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };
    BlueImpMD5.prototype.md5_gg = function (a, b, c, d, x, s, t) {
        return this.md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };
    BlueImpMD5.prototype.md5_hh = function (a, b, c, d, x, s, t) {
        return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };
    BlueImpMD5.prototype.md5_ii = function (a, b, c, d, x, s, t) {
        return this.md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    BlueImpMD5.prototype.binl_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = this.md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = this.md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = this.md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = this.md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = this.md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = this.md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = this.md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = this.md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = this.md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = this.md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = this.md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = this.md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = this.md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = this.md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = this.md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = this.md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = this.md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = this.md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = this.md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = this.md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = this.md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = this.md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = this.md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = this.md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = this.md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = this.md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = this.md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = this.md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = this.md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = this.md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = this.md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = this.md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = this.md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = this.md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = this.md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = this.md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = this.md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = this.md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = this.md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = this.md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = this.md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = this.md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = this.md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = this.md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = this.md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = this.md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = this.md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = this.md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = this.md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = this.md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = this.md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = this.md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = this.md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = this.md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = this.md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = this.md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = this.md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = this.md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = this.md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = this.md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = this.md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = this.md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = this.md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = this.md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = this.safe_add(a, olda);
            b = this.safe_add(b, oldb);
            c = this.safe_add(c, oldc);
            d = this.safe_add(d, oldd);
        }
        return [a, b, c, d];
    };

    /*
    * Convert an array of little-endian words to a string
    */
    BlueImpMD5.prototype.binl2rstr = function (input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    };

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    BlueImpMD5.prototype.rstr2binl = function (input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    };

    /*
    * Calculate the MD5 of a raw string
    */
    BlueImpMD5.prototype.rstr_md5 = function (s) {
        return this.binl2rstr(this.binl_md5(this.rstr2binl(s), s.length * 8));
    };

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    BlueImpMD5.prototype.rstr_hmac_md5 = function (key, data) {
        var i,
            bkey = this.rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = this.binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = this.binl_md5(ipad.concat(this.rstr2binl(data)), 512 + data.length * 8);
        return this.binl2rstr(this.binl_md5(opad.concat(hash), 512 + 128));
    };

    /*
    * Convert a raw string to a hex string
    */
    BlueImpMD5.prototype.rstr2hex = function (input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    };

    /*
    * Encode a string as utf-8
    */
    BlueImpMD5.prototype.str2rstr_utf8 = function (input) {
        return unescape(encodeURIComponent(input));
    };

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    BlueImpMD5.prototype.raw_md5 = function (s) {
        return this.rstr_md5(this.str2rstr_utf8(s));
    };
    BlueImpMD5.prototype.hex_md5 = function (s) {
        return this.rstr2hex(this.raw_md5(s));
    };
    BlueImpMD5.prototype.raw_hmac_md5 = function (k, d) {
        return this.rstr_hmac_md5(this.str2rstr_utf8(k), this.str2rstr_utf8(d));
    };
    BlueImpMD5.prototype.hex_hmac_md5 = function (k, d) {
        return this.rstr2hex(this.raw_hmac_md5(k, d));
    };

    BlueImpMD5.prototype.md5 = function (string, key, raw) {
        if (!key) {
            if (!raw) {
                return this.hex_md5(string);
            }

            return this.raw_md5(string);
        }

        if (!raw) {
            return this.hex_hmac_md5(key, string);
        }

        return this.raw_hmac_md5(key, string);
    };

    // CommonJS module
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Chance;
        }
        exports.Chance = Chance;
    }

    // Register as an anonymous AMD module
    if (typeof define === 'function' && define.amd) {
        define('chance',[], function () {
            return Chance;
        });
    }

    // if there is a importsScrips object define chance for worker
    if (typeof importScripts !== 'undefined') {
        chance = new Chance();
    }

    // If there is a window object, that at least has a document property,
    // instantiate and define chance on the window
    if (typeof window === "object" && typeof window.document === "object") {
        window.Chance = Chance;
        window.chance = new Chance();
    }
})();

/*globals define*/
/*jshint node: true, browser: true, bitwise: false*/

/**
 * @author kecso / https://github.com/kecso
 *
 * collection of functions that uses random Numbers in WebGME
 */

define('common/util/random',['chance'], function (ChanceJs) {
    'use strict';

    function _generateRelidRegexp() {
        var regexp = '',
            i;

        //adding excludes
        if (excludeList.length > 0) {
            for (i = 0; i < excludeList.length; i += 1) {
                regexp += '(?!(^' + excludeList[i] + '$))';
            }
        }
        //adding the pool
        regexp += '^(-)?[' + relidPool + ']+$';

        return new RegExp(regexp);
    }

    function getRandomCharacter(pool) {
        return pool.charAt(randFunction(pool.length));
    }

    function generateGuid() {
        var S4 = function () {
            return getRandomCharacter(guidPool) +
                getRandomCharacter(guidPool) +
                getRandomCharacter(guidPool) +
                getRandomCharacter(guidPool);
        };

        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());
    }

    function generateRelid(object, minimalLength) {
        var relid,
            i,
            length = minimalLength || 1,
            tries = 0;

        do {
            if (tries >= maxTry) {
                tries = 0;
                length += 1;
            }
            relid = '';
            for (i = 0; i < length; i += 1) {
                relid += getRandomCharacter(relidPool);
            }
            tries += 1;
        } while (object.hasOwnProperty(relid) === true || isValidRelid(relid) === false);

        return relid;
    }

    function isValidRelid(relid) {

        if (typeof relid !== 'string') {
            return false;
        }
        return relidRegexp.test(relid);
    }

    function relidToInteger(relid) {
        var num = 'NaN',
            negative = false,
            i;

        if (isValidRelid(relid)) {
            num = 0;
            for (i = 0; i < relid.length; i += 1) {
                if (relid.charAt(i) === '-') {
                    negative = true;
                } else {
                    num = num * relidPool.length;
                    num += relidPool.indexOf(relid.charAt(i));
                }
            }
        }

        return num;
    }

    var guidPool = '0123456789abcdef',
        relidPool = '0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM',
        excludeList = ['atr', 'reg', 'ovr'],
        maxTry = 2,
        chance = new ChanceJs(),
        randFunction = function (max) {
            //return Math.floor(Math.random() * max);
            return chance.natural({max: max - 1});
        },
        relidRegexp = _generateRelidRegexp(),
        random = {
            generateGuid: generateGuid,
            generateRelid: generateRelid,
            isValidRelid: isValidRelid,
            relidToInteger: relidToInteger
        };

    return random;
});

/*globals define*/
/*jshint node: true, browser: true*/
/**
 * @author kecso / https://github.com/kecso
 */
define('common/core/constants',[], function () {
    'use strict';
    //return string constants
    return {
        ATTRIBUTES_PROPERTY: 'atr',
        REGISTRY_PROPERTY: 'reg',
        OVERLAYS_PROPERTY: 'ovr',
        COLLECTION_NAME_SUFFIX: '-inv',
        ALL_SETS_PROPERTY: '_sets',
        SET_MODIFIED_REGISTRY: '_sets_',
        MEMBER_RELATION: 'member',
        BASE_POINTER: 'base',
        PATH_SEP: '/',
        MUTABLE_PROPERTY: '_mutable',
        MINIMAL_RELID_LENGTH_PROPERTY: '_minlenrelid',
        DOES_NOT_HAVE_RELID_CHILDREN: {
            _sets: true, // ALL_SETS_PROPERTY
            _meta: true  // META_NODE
        },
        INHERITED_CHILD_HAS_OWN_RELATION_PROPERTY: '_hasownrelation',

        NULLPTR_NAME: '_null_pointer',
        NULLPTR_RELID: '_nullptr',

        META_SET_NAME: 'MetaAspectSet',
        NULL_GUID: '00000000-0000-0000-0000-000000000000',
        OWN_GUID: '_relguid',

        CONSTRAINTS_RELID: '_constraints',
        C_DEF_PRIORITY: 1,
        CONSTRAINT_REGISTRY_PREFIX: '_ch#_',

        TO_DELETE_STRING: '*to*delete*',

        SET_ITEMS: 'items',
        SET_ITEMS_MAX: 'max',
        SET_ITEMS_MIN: 'min',

        META_ASPECTS: 'aspects',
        META_CHILDREN: 'children',
        META_NODE: '_meta',
        META_POINTER_PREFIX: '_p_',
        META_ASPECT_PREFIX: '_a_',

        ATTRIBUTE_TYPES: {
            STRING: 'string',
            INTEGER: 'integer',
            FLOAT: 'float',
            BOOLEAN: 'boolean',
            ASSET: 'asset'
        },

        MIXINS_SET: '_mixins',
        MIXIN_ERROR_TYPE: {
            MISSING: 'missing',
            ATTRIBUTE_COLLISION: 'attribute collision',
            SET_COLLISION: 'set collision',
            POINTER_COLLISION: 'pointer collision',
            CONTAINMENT_COLLISION: 'containment collision',
            ASPECT_COLLISION: 'aspect collision',
            CONSTRAINT_COLLISION: 'constraint collision'
        },

        EXPORT_TYPE_PROJECT: 'project',
        EXPORT_TYPE_LIBRARY: 'library',

        NAMESPACE_SEPARATOR: '.',

        MAX_AGE: 3,
        MAX_TICKS: 2000,
        MAX_MUTATE: 30000,
        MAXIMUM_STARTING_RELID_LENGTH: 5
    };
});
/*globals define*/
/*jshint browser:true, node:true*/

/**
 * This is a partial implementation of RFC 6902
 * the generated patch is fully compliant though the
 * patch generation is specialized to the expected input form.
 *
 * @author kecso / https://github.com/kecso
 */

define('common/util/jsonPatcher',[
    'common/util/canon',
    'common/util/random',
    'common/core/constants'
], function (CANON, RANDOM, CORE_CONSTANTS) {

    'use strict';

    var MIN_RELID_LENGTH_PATH = CORE_CONSTANTS.PATH_SEP + CORE_CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY;

    function _strEncode(str) {
        //we should replace the '/' in the patch paths
        return str.replace(/\//g, '%2f');
    }

    function _strDecode(str) {
        return str.replace(/%2f/g, '/');
    }

    function _endsWith(str, pattern) {
        var d = str.length - pattern.length;
        return d >= 0 && str.lastIndexOf(pattern) === d;
    }

    function _startsWith(str, pattern) {
        return str.indexOf(pattern) === 0;
    }

    function _isOvr(path) {
        return path.indexOf('/ovr') === 0;
    }

    function _isRelid(path) {
        return RANDOM.isValidRelid(path.substring(1));
    }

    function _isGmePath(path) {
        if (typeof path !== 'string') {
            return false;
        }

        var relIds = path.split('/'),
            result = false,
            i;

        for (i = 1; i < relIds.length; i += 1) {
            if (RANDOM.isValidRelid(relIds[i]) === false) {
                return false;
            } else {
                result = true;
            }
        }

        return result;
    }

    function diff(source, target, basePath, excludeList, noUpdate, innerPath) {
        var result = [],
            overlay = false,
            inOverlay = false,
            patchItem,
            path,
            i;

        if (basePath === '/ovr/') {
            overlay = true;
        } else if (_startsWith(basePath, '/ovr/')) {
            inOverlay = true;
        }

        //add
        for (i in target) {
            if (excludeList.indexOf(i) === -1 && target.hasOwnProperty(i)) {
                if (!source.hasOwnProperty(i)) {
                    patchItem = {
                        op: 'add',
                        path: basePath + _strEncode(i),
                        value: target[i]
                    };

                    if (inOverlay || overlay) {
                        patchItem.partialUpdates = [];
                        patchItem.updates = [];
                        if (inOverlay) {
                            if (_isGmePath(target[i])) {
                                patchItem.partialUpdates.push(target[i]);
                                if (_isGmePath(innerPath)) {
                                    patchItem.updates.push(innerPath);
                                }
                            } else if (target[i] === '/_nullptr') {
                                patchItem.updates.push('');
                            }
                        } else {
                            for (path in target[i]) {
                                if (_isGmePath(target[i][path])) {
                                    patchItem.partialUpdates.push(target[i][path]);
                                    if (_isGmePath(i)) {
                                        patchItem.updates.push(i);
                                    }
                                } else if (target[i][path] === '/_nullptr') {
                                    patchItem.updates.push('');
                                }
                            }
                        }
                    }

                    result.push(patchItem);
                }
            }
        }

        //replace
        if (!noUpdate) {
            for (i in target) {
                if (excludeList.indexOf(i) === -1 && target.hasOwnProperty(i)) {
                    if (source.hasOwnProperty(i) && CANON.stringify(source[i]) !== CANON.stringify(target[i])) {
                        patchItem = {
                            op: 'replace',
                            path: basePath + _strEncode(i),
                            value: target[i]
                            //oldValue: source[i]
                        };

                        if (inOverlay) {
                            patchItem.partialUpdates = [];
                            patchItem.updates = [];

                            if (_isGmePath(target[i])) {
                                patchItem.partialUpdates.push(target[i]);
                                if (_isGmePath(innerPath)) {
                                    patchItem.updates.push(innerPath);
                                }
                            } else if (target[i] === '/_nullptr') {
                                patchItem.updates.push('');
                            }

                            if (_isGmePath(source[i])) {
                                patchItem.partialUpdates.push(source[i]);
                            } else if (source[i] === '/_nullptr') {
                                patchItem.updates.push('');
                            }
                        }

                        result.push(patchItem);
                    }
                }
            }
        }

        //remove
        for (i in source) {
            if (excludeList.indexOf(i) === -1 && source.hasOwnProperty(i)) {
                if (!target.hasOwnProperty(i)) {
                    patchItem = {
                        op: 'remove',
                        path: basePath + _strEncode(i)
                        //oldValue: source[i]
                    };

                    if (inOverlay || overlay) {
                        patchItem.partialUpdates = [];
                        patchItem.updates = [];
                        if (inOverlay) {
                            if (_isGmePath(source[i])) {
                                patchItem.partialUpdates.push(source[i]);
                                if (_isGmePath(innerPath)) {
                                    patchItem.updates.push(innerPath);
                                }
                            } else if (source[i] === '/_nullptr') {
                                patchItem.updates.push('');
                            }
                        } else {
                            for (path in source[i]) {
                                if (_isGmePath(source[i][path])) {
                                    patchItem.partialUpdates.push(source[i][path]);
                                    if (_isGmePath(i)) {
                                        patchItem.updates.push(i);
                                    }
                                } else if (source[i][path] === '/_nullptr') {
                                    patchItem.updates.push('');
                                }
                            }
                        }
                    }

                    result.push(patchItem);
                }
            }
        }

        return result;
    }

    function create(sourceJson, targetJson) {
        var patch,
            patchItem,
            diffRes,
            i,
            key;

        //main level diff
        patch = diff(sourceJson, targetJson, '/', ['_id', 'ovr', 'atr', 'reg', '_sets'], false);

        //atr
        if (sourceJson.atr && targetJson.atr) {
            patch = patch.concat(diff(sourceJson.atr, targetJson.atr, '/atr/', [], false));
        } else if (sourceJson.atr) {
            patch.push({
                op: 'remove',
                path: '/atr'
            });
        } else if (targetJson.atr) {
            patch.push({
                op: 'add',
                path: '/atr',
                value: targetJson.atr
            });
        }

        //reg
        if (sourceJson.reg && targetJson.reg) {
            patch = patch.concat(diff(sourceJson.reg, targetJson.reg, '/reg/', [], false));
        } else if (sourceJson.reg) {
            patch.push({
                op: 'remove',
                path: '/reg'
            });
        } else if (targetJson.reg) {
            patch.push({
                op: 'add',
                path: '/reg',
                value: targetJson.reg
            });
        }

        //_sets
        if (sourceJson._sets && targetJson._sets) {
            patch = patch.concat(diff(sourceJson._sets, targetJson._sets, '/_sets/', [], true));
            for (key in targetJson._sets) {
                if (sourceJson._sets[key]) {
                    patch = patch.concat(
                        diff(sourceJson._sets[key], targetJson._sets[key], '/_sets/' + _strEncode(key) + '/', [], false)
                    );
                }
            }
        } else if (sourceJson._sets) {
            patch.push({
                op: 'remove',
                path: '/_sets'
            });
        } else if (targetJson._sets) {
            patch.push({
                op: 'add',
                path: '/_sets',
                value: targetJson._sets
            });
        }

        //ovr
        if (sourceJson.ovr && targetJson.ovr) {
            patch = patch.concat(diff(sourceJson.ovr, targetJson.ovr, '/ovr/', [], true));
            for (key in targetJson.ovr) {
                if (sourceJson.ovr[key]) {
                    patch = patch.concat(
                        diff(sourceJson.ovr[key], targetJson.ovr[key], '/ovr/' + _strEncode(key) + '/', [], false, key)
                    );
                }
            }
        } else if (sourceJson.ovr || targetJson.ovr) {
            patchItem = {
                path: '/ovr',
                partialUpdates: [],
                updates: []
            };

            if (sourceJson.ovr) {
                patchItem.op = 'remove';
            } else {
                patchItem.op = 'add';
                patchItem.value = targetJson.ovr;
            }

            // For ovr removal/addition we need to compute updates/partialUpdates
            diffRes = diff(sourceJson.ovr || {}, targetJson.ovr || {}, '/ovr/', [], true);
            for (i = 0; i < diffRes.length; i += 1) {
                patchItem.partialUpdates = patchItem.partialUpdates.concat(diffRes[i].partialUpdates);
                patchItem.updates = patchItem.updates.concat(diffRes[i].updates);
            }

            patch.push(patchItem);
        }

        return patch;
    }

    function apply(sourceJson, patch) {
        var targetJson = JSON.parse(JSON.stringify(sourceJson)),
            i, j,
            badOperation = false,
            pathArray,
            key,
            parent,
            result = {
                status: 'success',
                faults: [],
                patch: patch,
                result: targetJson
            };

        for (i = 0; i < patch.length; i += 1) {
            pathArray = (patch[i].path + '').split('/').slice(1);
            parent = targetJson;

            for (j = 0; j < pathArray.length; j += 1) {
                pathArray[j] = _strDecode(pathArray[j]);
            }
            key = pathArray.pop();
            badOperation = false;
            switch (patch[i].op) {
                case 'remove':
                    if (typeof patch[i].path === 'string') {
                        for (j = 0; j < pathArray.length; j += 1) {
                            if (!parent[pathArray[j]]) {
                                badOperation = true;
                                break;
                            }
                            parent = parent[pathArray[j]];
                        }
                        if (!badOperation && parent[key] !== undefined) {
                            delete parent[key];
                        } else {
                            result.status = 'fail';
                            result.faults.push(patch[i]);
                        }
                    } else {
                        result.status = 'fail';
                        result.faults.push(patch[i]);
                    }
                    break;
                case 'add':
                    if (typeof patch[i].path === 'string' && patch[i].value !== undefined) {
                        for (j = 0; j < pathArray.length; j += 1) {
                            if (!parent[pathArray[j]]) {
                                parent[pathArray[j]] = {};
                            }
                            parent = parent[pathArray[j]];
                        }
                        parent[key] = patch[i].value;

                    } else {
                        result.status = 'fail';
                        result.faults.push(patch[i]);
                    }
                    break;
                case 'replace':
                    if (typeof patch[i].path === 'string' && patch[i].value !== undefined) {
                        for (j = 0; j < pathArray.length; j += 1) {
                            if (!parent[pathArray[j]]) {
                                badOperation = true;
                                break;
                            }
                            parent = parent[pathArray[j]];
                        }
                        if (!badOperation && parent[key] !== undefined) {
                            parent[key] = patch[i].value;
                        } else {
                            result.status = 'fail';
                            result.faults.push(patch[i]);
                        }
                    } else {
                        result.status = 'fail';
                        result.faults.push(patch[i]);
                    }
                    break;
                default:
                    result.status = 'fail';
                    result.faults.push(patch[i]);
                    break;
            }
        }

        return result;
    }

    function _inLoadOrUnload(res, gmePath) {
        var pathPieces = gmePath.split('/'),
            parentPath;

        parentPath = gmePath;

        do {
            if (res.load[parentPath] || res.unload[parentPath]) {
                return true;
            }

            pathPieces.pop();
            parentPath = pathPieces.join('/');
        } while (pathPieces.length > 1);

        return false;
    }

    function _removeFromUpdates(res, gmePath) {
        var updatesPath,
            i;

        updatesPath = Object.keys(res.update);
        for (i = 0; i < updatesPath; i += 1) {
            if (_startsWith(updatesPath[i], gmePath)) {
                delete res.update[gmePath];
            }
        }

        updatesPath = Object.keys(res.partialUpdate);
        for (i = 0; i < updatesPath; i += 1) {
            if (_startsWith(updatesPath[i], gmePath)) {
                delete res.partialUpdate[gmePath];
            }
        }
    }

    function _getChangedNodesRec(patch, res, hash, gmePath) {
        var nodePatches = patch[hash] && patch[hash].patch, // Changes regarding node with hash
            i, j,
            ownChange = false,
            absGmePath,
            patchPath;

        if (!nodePatches) {
            // E.g. if the node was added the full data is given instead of a patch.
            return;
        }

        for (i = 0; i < nodePatches.length; i += 1) {
            patchPath = nodePatches[i].path;

            if (_isOvr(patchPath) === true) {
                // Now handle the updates
                for (j = 0; j < nodePatches[i].partialUpdates.length; j += 1) {
                    absGmePath = gmePath + nodePatches[i].partialUpdates[j];
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.partialUpdate[absGmePath] = true;
                    }
                }

                for (j = 0; j < nodePatches[i].updates.length; j += 1) {
                    absGmePath = gmePath + nodePatches[i].updates[j];
                    if (_inLoadOrUnload(res, absGmePath) === false) {
                        res.update[absGmePath] = true;
                    }
                }
            } else if (_isRelid(patchPath) === true) {
                // There was a change in one of the children..
                switch (nodePatches[i].op) {
                    case 'add':
                        res.load[gmePath + patchPath] = true;
                        _removeFromUpdates(res, gmePath + patchPath);
                        break;
                    case 'remove':
                        res.unload[gmePath + patchPath] = true;
                        _removeFromUpdates(res, gmePath + patchPath);
                        break;
                    case 'replace':
                        _getChangedNodesRec(patch, res, nodePatches[i].value, gmePath + patchPath);
                        break;
                    default:
                        throw new Error('Unexpected patch operation ' + nodePatches[i]);
                }
            } else if (patchPath !== MIN_RELID_LENGTH_PATH && patchPath !== '/__v') {
                ownChange = true;
            }
        }

        if (ownChange) {
            res.update[gmePath] = true;
        }
    }

    /**
     *
     * @param {object} patch
     * @returns {object}
     */
    // TODO check if all event related information could be set during patch creation,
    // so this function would only collect those information.
    function getChangedNodes(patch, rootHash) {
        var res;

        if (patch[rootHash] && patch[rootHash].patch) {
            res = {
                load: {},
                unload: {},
                update: {},
                partialUpdate: {}
            };

            _getChangedNodesRec(patch, res, rootHash, '');
        } else {
            res = null;
        }

        return res;
    }

    return {
        create: create,
        apply: apply,
        getChangedNodes: getChangedNodes
    };
});
/*globals define*/
/*jshint node:true, browser: true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/regexp',[], function () {
    'use strict';
    var HASH = new RegExp('^#[0-9a-zA-Z_]*$'),
        DB_HASH = new RegExp('^#[0-9a-zA-Z_]{40}$'),
        BRANCH = new RegExp('^[0-9a-zA-Z_]*$'),
        TAG = new RegExp('^[0-9a-zA-Z_]*$'),
        RAW_BRANCH = new RegExp('^\\*[0-9a-zA-Z_]*$'),// This is how it's stored in mongodb, i.e. with a prefixed *.
        PROJECT = new RegExp('^(?!system\\.)(?!_)[0-9a-zA-Z_+]*$'), // project name may not start with system. or _
        DOCUMENT_KEY = new RegExp('^[^(\$|\_)\.][^\.]*$'),//based on the MongoDB requirements (no '.' and no leading $)
        PROJECT_NAME = new RegExp('^[0-9a-zA-Z_]+$'),

        INVALID_CSS_CHARS = new RegExp('[!"#$%&\'()\*\+,\./:;<=>\?@\[\\\]^`{\|}~ ]+', 'g'),
        HTML_ELEMENT = new RegExp('<[a-z][\\s\\S]*>', 'i'),
        GUID = new RegExp('[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}', 'i'),
        BLOB_HASH = new RegExp('^[0-9a-f]{40}$');
    return {
        HASH: HASH,
        DB_HASH: DB_HASH,
        BRANCH: BRANCH,
        TAG: TAG,
        RAW_BRANCH: RAW_BRANCH,
        PROJECT: PROJECT,
        DOCUMENT_KEY: DOCUMENT_KEY,
        GUID: GUID,
        INVALID_CSS_CHARS: INVALID_CSS_CHARS,
        HTML_ELEMENT: HTML_ELEMENT,
        PROJECT_NAME: PROJECT_NAME,
        BLOB_HASH: BLOB_HASH
    };
});

//jshint ignore: start
//SHA1 in Javascript 862 bytes, MIT License, http://antimatter15.com/
define('common/util/sha1',[],function() {
return function(l){function p(b,a){return b<<a|b>>>32-a}l+="";for(var n=Math,c=[1518500249,1859775393,2400959708,3395469782,1732584193,4023233417,2562383102,271733878,3285377520,4294967295],s=n.ceil(l.length/4)+2,q=n.ceil(s/16),g=[],a=0,h=[],j,d,e,f,m,i,b,k;a<q;a++){g[a]=[];for(k=0;k<16;k++){function o(b,c){return l.charCodeAt(a*64+k*4+b)<<c}g[a][k]=o(0,24)|o(1,16)|o(2,8)|o(3,0)}}i=l.length*8-8;a=q-1;g[a][14]=i/(c[9]+1);g[a][14]=n.floor(g[a][14]);g[a][15]=i&c[9];for(a=0;a<q;a++){for(b=0;b<16;b++)h[b]=g[a][b];for(b=16;b<80;b++)h[b]=p(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);j=c[4];d=c[5];e=c[6];f=c[7];m=c[8];for(b=0;b<80;b++){var r=n.floor(b/20),t=p(j,5)+(r<1?d&e^~d&f:r==2?d&e^d&f^e&f:d^e^f)+m+c[r]+h[b]&c[9];m=f;f=e;e=p(d,30);d=j;j=t}c[4]+=j;c[5]+=d;c[6]+=e;c[7]+=f;c[8]+=m}i="";for(z=4;z<9;z++)for(a=7;a>=0;a--)i+=((c[z]&c[9])>>>a*4&15).toString(16);return i};
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/util/key',[
    'common/util/sha1',
    'common/util/assert',
    'common/util/canon'
], function (SHA1, ASSERT, CANON) {
    'use strict';

    var keyType = null;

    function rand160Bits() {
        var result = '',
            i, code;
        for (i = 0; i < 40; i++) {
            code = Math.floor(Math.random() * 16);
            code = code > 9 ? code + 87 : code + 48;
            result += String.fromCharCode(code);
        }
        return result;
    }

    return function KeyGenerator(object, gmeConfig) {
        keyType = gmeConfig.storage.keyType;
        ASSERT(typeof keyType === 'string');

        switch (keyType) {
            case 'rand160Bits':
                return rand160Bits();
            default: //plainSHA1
                return SHA1(CANON.stringify(object));
        }
    };
});
/*globals define*/
/*jshint node:true, browser: true*/
/**
 * @author lattmann / https://github.com/lattmann
 */

define('common/storage/util',[
    'common/storage/constants',
    'common/util/jsonPatcher',
    'q',
    'common/regexp',
    'common/util/key'
], function (CONSTANTS, jsonPatcher, Q, REGEXP, GENKEY) {
    'use strict';

    function _getRootHash(project, parameters) {
        var deferred = Q.defer();

        if (parameters.branchName) {
            Q.ninvoke(project, 'getBranchHash', parameters.branchName)
                .then(function (commitHash) {
                    parameters.commitHash = commitHash;
                    return Q.ninvoke(project, 'loadObject', commitHash);
                })
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.commitHash) {
            Q.ninvoke(project, 'loadObject', parameters.commitHash)
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.tagName) {
            Q.ninvoke(project, 'getAllTags')
                .then(function (tags) {
                    if (tags[parameters.tagName]) {
                        parameters.commitHash = tags[parameters.tagName];
                        return Q.ninvoke(project, 'loadObject', tags[parameters.tagName]);
                    } else {
                        throw new Error('Unknown tag name [' + parameters.tagName + ']');
                    }
                })
                .then(function (commitObject) {
                    parameters.rootHash = commitObject.root;
                    deferred.resolve(commitObject.root);
                })
                .catch(deferred.reject);
        } else if (parameters.rootHash) {
            deferred.resolve(parameters.rootHash);
        } else {
            deferred.reject(new Error('No valid input was given to search for rootHash'));
        }

        return deferred.promise;
    }

    function _collectObjects(project, objectHashArray) {
        var deferred = Q.defer(),
            promises = [],
            objects = [],
            i;

        for (i = 0; i < objectHashArray.length; i += 1) {
            promises.push(Q.ninvoke(project, 'loadObject', objectHashArray[i]));
        }

        Q.allSettled(promises)
            .then(function (results) {
                var error = null,
                    i;
                for (i = 0; i < results.length; i += 1) {
                    if (results[i].state === 'fulfilled') {
                        objects.push(results[i].value);
                    } else {
                        error = error || results[i].reason || new Error('unable to load');
                    }
                }

                if (error) {
                    deferred.reject(error);
                } else {
                    deferred.resolve(objects);
                }
            });
        return deferred.promise;
    }

    function _collectObjectAndAssetHashes(project, rootHash) {
        var deferred = Q.defer(),
            objects = {},
            assets = {},
            queue = [rootHash],
            task,
            error = null,
            working = false,
            timerId;

        timerId = setInterval(function () {
            if (!working) {
                task = queue.shift();
                if (task === undefined) {
                    clearInterval(timerId);
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve({objects: Object.keys(objects), assets: Object.keys(assets)});
                    }
                    return;
                }

                if (!objects[task]) {
                    working = true;
                    project.loadObject(task, function (err, object) {
                        var key;

                        error = error || err;
                        if (!err && object) {
                            objects[task] = true;
                            if (object) {
                                //now put every sub-object on top of the queue
                                for (key in object) {
                                    if (typeof object[key] === 'string' && REGEXP.HASH.test(object[key])) {
                                        queue.push(object[key]);
                                    }
                                }

                                //looking for assets
                                if (object.atr) {
                                    for (key in object.atr) {
                                        //TODO why can't we inlcude BlobConfig???
                                        if (typeof object.atr[key] === 'string' &&
                                            REGEXP.BLOB_HASH.test(object.atr[key])) {
                                            assets[object.atr[key]] = true;
                                        }
                                    }
                                }
                            }
                        }
                        working = false;
                    });
                }

            }
        }, 1);

        return deferred.promise;
    }

    return {
        CONSTANTS: CONSTANTS,
        getProjectFullNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, CONSTANTS.PROJECT_DISPLAYED_NAME_SEP);
            }
        },
        getProjectDisplayedNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, ' ' + CONSTANTS.PROJECT_DISPLAYED_NAME_SEP + ' ');
            }
        },
        getProjectIdFromProjectFullName: function (projectFullName) {
            if (projectFullName) {
                return projectFullName.replace(CONSTANTS.PROJECT_DISPLAYED_NAME_SEP, CONSTANTS.PROJECT_ID_SEP);
            }
        },
        getProjectIdFromOwnerIdAndProjectName: function (userId, projectName) {
            return userId + CONSTANTS.PROJECT_ID_SEP + projectName;
        },
        getProjectNameFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.substring(projectId.indexOf(CONSTANTS.PROJECT_ID_SEP) + 1);
            }
        },
        getOwnerFromProjectId: function (projectId) {
            if (projectId) {
                return projectId.substring(0, projectId.indexOf(CONSTANTS.PROJECT_ID_SEP));
            }
        },
        getHashTaggedHash: function (hash) {
            if (typeof hash === 'string') {
                return hash[0] === '#' ? hash : '#' + hash;
            }
            return hash;
        },
        getPatchObject: function (oldData, newData) {
            var patchObject = {
                type: 'patch',
                base: oldData[CONSTANTS.MONGO_ID],
                patch: jsonPatcher.create(oldData, newData)
            };
            patchObject[CONSTANTS.MONGO_ID] = newData[CONSTANTS.MONGO_ID];

            return patchObject;
        },
        coreObjectHasOldAndNewData: function (coreObj) {
            return !!(coreObj.oldHash && coreObj.newHash && coreObj.oldData && coreObj.newData);
        },
        getChangedNodes: jsonPatcher.getChangedNodes,
        applyPatch: jsonPatcher.apply,
        checkHashConsistency: function (gmeConfig, dataObj, hash) {
            var result;

            if (gmeConfig.storage.keyType === 'rand160Bits') {
                // Random hashes should not be checked.
                result = true;
            } else if (gmeConfig.storage.disableHashChecks === true) {
                // Configured to not check.
                result = true;
            } else {
                dataObj[CONSTANTS.MONGO_ID] = '';
                result = hash === '#' + GENKEY(dataObj, gmeConfig);
            }

            return result;
        },

        /**
         * Extracts a serializable json representation of a project tree.
         * To specify starting point set one of the four options. If more than one is set the order of precedence is:
         * branchName, commitHash, tagName and rootHash.
         *
         * @param {ProjectInterface} project
         * @param {object} parameters - Specifies which project tree should be serialized:
         * @param {string} [parameters.rootHash] - The hash of the tree root.
         * @param {string} [parameters.commitHash] - The tree associated with the commitHash.
         * @param {string} [parameters.tagName] - The tree at the given tag.
         * @param {string} [parameters.branchName] - The tree at the given branch.
         * @param {function} callback
         */
        getProjectJson: function (project, parameters, callback) {
            var deferred = Q.defer(),
                rawJson;

            _getRootHash(project, parameters || {})
                .then(function (rootHash) {
                    return _collectObjectAndAssetHashes(project, rootHash);
                })
                .then(function (hashes) {
                    rawJson = {
                        rootHash: parameters.rootHash,
                        projectId: project.projectId,
                        branchName: parameters.branchName,
                        commitHash: parameters.commitHash,
                        hashes: hashes,
                        objects: null
                    };
                    return _collectObjects(project, hashes.objects);
                })
                .then(function (objects) {
                    rawJson.objects = objects;
                    deferred.resolve(rawJson);
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        },

        /**
         * Inserts a serialized project tree into the storage and associates it with a commitHash.
         *
         * @param {ProjectInterface} project
         * @param {object} [options]
         * @param {string} [options.commitMessage=%defaultCommitMessage%] information about the insertion
         * @param {function(Error, hashes)} callback
         */
        insertProjectJson: function (project, projectJson, options, callback) {
            var deferred = Q.defer(),
                toPersist = {},
                rootHash = projectJson.rootHash,
                defaultCommitMessage = 'Importing contents of [' +
                    projectJson.projectId + '@' + rootHash + ']',
                objects = projectJson.objects,
                i;

            for (i = 0; i < objects.length; i += 1) {
                // we have to patch the object right before import, for smoother usage experience
                toPersist[objects[i]._id] = objects[i];
            }

            options = options || {};

            options.branch = options.branch || null;
            options.parentCommit = options.parentCommit || [];

            project.makeCommit(options.branch, options.parentCommit,
                rootHash, toPersist, options.commitMessage || defaultCommitMessage)
                .then(function (commitResult) {
                    deferred.resolve(commitResult);
                })
                .catch(deferred.reject);

            return deferred.promise.nodeify(callback);
        }
    };
});

/*globals define*/
/*jshint browser: true, node:true*/
/**
 * This class (extracted functionality from cache implemented by mmaroti) caches objects associated
 * with a project.
 *
 * @author pmeijer / https://github.com/pmeijer
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/storage/project/cache',[
    'common/util/assert',
    'common/storage/constants',
    'common/storage/util'
], function (ASSERT, CONSTANTS, UTIL) {
    'use strict';
    function ProjectCache(storage, projectId, mainLogger, gmeConfig) {
        var self = this,
            missing = {},
            backup = {},
            cache = {},
            logger = mainLogger.fork('ProjectCache'),
            cacheSize = 0;

        logger.debug('ctor', projectId);

        this.queuedPersists = {};

        function cacheInsert(key, obj) {
            ASSERT(obj[CONSTANTS.MONGO_ID] === key);
            logger.debug('cacheInsert', key);

            //deepFreeze(obj);
            if (!cache[key]) {
                cache[key] = obj;

                if (++cacheSize >= gmeConfig.storage.cache) {
                    backup = cache;
                    cache = {};
                    cacheSize = 0;
                }
                return true;
            } else {
                return false;
            }
        }

        function getFromCache(hash) {
            var obj = cache[hash],
                commitId;

            if (typeof obj === 'undefined') {
                obj = backup[hash];

                if (typeof obj === 'undefined') {
                    for (commitId in self.queuedPersists) {
                        if (self.queuedPersists.hasOwnProperty(commitId) && self.queuedPersists[commitId][hash]) {
                            obj = self.queuedPersists[commitId][hash];
                            break;
                        }
                    }
                }
            }

            return obj;
        }

        this.loadObject = function (key, callback) {
            var commitId;
            ASSERT(typeof key === 'string' && typeof callback === 'function');
            logger.debug('loadObject', {metadata: key});

            var obj = cache[key];
            if (typeof obj === 'undefined') {
                obj = backup[key];
                if (typeof obj === 'undefined') {
                    for (commitId in self.queuedPersists) {
                        if (self.queuedPersists.hasOwnProperty(commitId) && self.queuedPersists[commitId][key]) {
                            obj = self.queuedPersists[commitId][key];
                            break;
                        }
                    }
                    if (typeof obj === 'undefined') {
                        obj = missing[key];
                        if (typeof obj === 'undefined') {
                            obj = [callback];
                            missing[key] = obj;
                            logger.debug('object set to be loaded from storage');
                            storage.loadObject(projectId, key, function (err, obj2) {
                                ASSERT(typeof obj2 === 'object' || typeof obj2 === 'undefined');

                                if (obj.length !== 0) {
                                    ASSERT(missing[key] === obj);

                                    delete missing[key];
                                    if (!err && obj2) {
                                        cacheInsert(key, obj2);
                                    }

                                    var cb;
                                    while ((cb = obj.pop())) {
                                        cb(err, obj2);
                                    }
                                }
                            });
                        } else {
                            logger.debug('object was already queued to be loaded');
                            obj.push(callback);
                        }
                        return;
                    } else {
                        logger.debug('object was erased from cache and backup but present in queuedPersists');
                        cacheInsert(key, obj);
                    }
                } else {
                    logger.debug('object was in backup');
                    cacheInsert(key, obj);
                }
            } else {
                logger.debug('object was in cache');
            }

            ASSERT(typeof obj === 'object' && obj !== null && obj[CONSTANTS.MONGO_ID] === key);
            callback(null, obj);
        };

        /**
         * Loads the necessary objects for the nodes corresponding to paths and inserts them in the cache.
         * If the rootKey is empty or does not exist - it won't attempt to load any nodes.
         * @param {string} rootKey
         * @param {string[]} paths
         * @param {function(err)} callback
         */
        this.loadPaths = function (rootKey, paths, callback) {
            logger.debug('loadPaths', {metadata: {rootKey: rootKey, paths: paths}});

            var cachedObjects = {},
                excludes = [],
                rootObj = getFromCache(rootKey),
                i = paths.length,
                j,
                pathArray,
                obj,
                pathsInfo = [],
                key;

            if (!rootKey) {
                logger.debug('rootKey empty:', rootKey);
                callback(null);
                return;
            }

            if (rootObj) {
                // The root was loaded, so for each requested path we start from the root
                // and work our way down to the containment chain and add each object that is
                // already in the cache to 'excludes'.

                excludes.push(rootKey);
                cachedObjects[rootKey] = rootObj;
                while (i--) {
                    pathArray = paths[i].split('/');
                    pathArray.shift();

                    obj = rootObj;
                    for (j = 0; j < pathArray.length; j += 1) {
                        key = obj[pathArray[j]];
                        if (key) {
                            obj = getFromCache(key);
                            if (typeof obj !== 'undefined') {
                                excludes.push(key);
                                cachedObjects[key] = obj;
                            } else {
                                pathsInfo.push({
                                    parentHash: key,
                                    path: '/' + pathArray.slice(j + 1).join('/')
                                });
                                break;
                            }
                        } else {
                            // The given path does not exist anymore - break.
                            break;
                        }
                    }
                }
            } else {
                pathsInfo = paths.map(function (path) {
                    return {
                        parentHash: rootKey,
                        path: path
                    };
                });
            }

            if (pathsInfo.length === 0) {
                logger.debug('All given paths already loaded');
                callback(null);
                return;
            }

            logger.debug('loadPaths will request from server, pathsInfo:', pathsInfo);
            storage.loadPaths(projectId, pathsInfo, excludes, function (err, serverObjects) {
                var keys, i;
                if (!err && serverObjects) {
                    // Insert every obtained object into the cache (that was not there before).
                    keys = Object.keys(serverObjects);
                    for (i = 0; i < keys.length; i += 1) {
                        if (serverObjects[keys[i]] !== undefined) {
                            // When not going through a web-socket loadPaths returns keys with
                            // undefined values, therefore the extra check.
                            cacheInsert(keys[i], serverObjects[keys[i]]);
                        }
                    }

                    // Reinsert the cachedObjects.
                    keys = Object.keys(cachedObjects);
                    for (i = 0; i < keys.length; i += 1) {
                        cacheInsert(keys[i], cachedObjects[keys[i]]);
                    }
                    callback(null);
                } else {
                    logger.error('loadingPaths failed', err || new Error('no object arrived from server'));
                    callback(err);
                }
            });
        };

        this.insertObject = function (obj, stackedObjects) {
            ASSERT(typeof obj === 'object' && obj !== null);

            var key = obj[CONSTANTS.MONGO_ID];
            logger.debug('insertObject', {metadata: key});
            ASSERT(typeof key === 'string');

            if (cacheInsert(key, obj) === false) {
                // The storage on the server will return error if it's not the same..
                logger.debug('object inserted was already in cache');
            } else {
                var item = backup[key];

                if (typeof item !== 'undefined') {
                    // The storage on the server will return error if it's not the same..
                    logger.debug('object inserted was already in back-up');
                } else {
                    item = missing[key];
                    if (typeof item !== 'undefined') {
                        delete missing[key];

                        var cb;
                        while ((cb = item.pop())) {
                            cb(null, obj);
                        }
                    }
                }
            }
            if (stackedObjects) {
                stackedObjects[key] = obj;
            }
        };

        this.insertPatchObject = function (obj) {
            ASSERT(typeof obj === 'object' && obj !== null);

            var base,
                patch,
                key = obj[CONSTANTS.MONGO_ID];

            if (obj.base && typeof obj.patch === 'object' && key) {
                base = getFromCache(obj.base);

                if (base) {
                    patch = UTIL.applyPatch(base, obj.patch);
                    if (patch.status === 'success') {
                        patch.result[CONSTANTS.MONGO_ID] = key;
                        this.insertObject(patch.result);
                    } else {
                        logger.error('patch application failed', patch);
                    }
                } else {
                    logger.debug('the base [' +
                        obj.base + '] is not available from the cache so the patch object is ignored');
                }
            } else {
                logger.error('invalid patch object format', obj);
            }
        };
    }

    return ProjectCache;
});
/*globals define*/
/*jshint node:true, browser: true*/
/**
 * This class defines the common interface for a storage-project.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/project/interface',[
    'common/storage/project/cache',
    'common/storage/constants',
    'common/storage/util'
], function (ProjectCache, CONSTANTS, UTIL) {
    'use strict';

    /**
     *
     * @param {string} projectId - Id of project to be opened.
     * @param {object} storageObjectsAccessor - Exposes loadObject towards the database.
     * @param {GmeLogger} mainLogger - Logger instance from instantiator.
     * @param {GmeConfig} gmeConfig
     * @alias ProjectInterface
     * @constructor
     */
    function ProjectInterface(projectId, storageObjectsAccessor, mainLogger, gmeConfig) {

        /**
         * Unique ID of project, built up by the ownerId and projectName.
         *
         * @example
         * 'guest+TestProject', 'organization+TestProject2'
         * @type {string}
         */
        this.projectId = projectId;
        this.projectName = UTIL.getProjectNameFromProjectId(projectId);

        this.CONSTANTS = CONSTANTS;

        this.ID_NAME = CONSTANTS.MONGO_ID;
        this.logger = mainLogger.fork('Project:' + this.projectId);

        this.logger.debug('ctor', projectId);
        this.projectCache = new ProjectCache(storageObjectsAccessor, this.projectId, this.logger, gmeConfig);

        // Functions forwarded to project cache.
        /**
         * Inserts the given object to project-cache.
         *
         * @param {module:Storage~CommitObject|module:Core~ObjectData} obj - Object to be inserted in database.
         * @param {Object.<module:Core~ObjectHash, module:Core~ObjectData>} [stackedObjects] - When used by the core, inserts between persists are stored here.
         * @func
         * @private
         */
        this.insertObject = this.projectCache.insertObject;

        /**
         * Try to create the full object from the patch object by looking for the base object in the cache.
         * If the base has been found it applies the patch and inserts the result. If any step fails it simply
         * ignores the insert.
         *
         * @param {module:Storage~CommitObject|module:Core~ObjectData} obj - Object to be inserted in database.
         * @func
         * @private
         */
        this.insertPatchObject = this.projectCache.insertPatchObject;

        /**
         * Callback for loadObject.
         *
         * @callback ProjectInterface~loadObjectCallback
         * @param {Error} err - If error occurred.
         * @param {module:Storage~CommitObject|module:Core~ObjectData} object - Object loaded from database, e.g. a commit object.
         */

        /**
         * Loads the object with hash key from the database or
         * directly from the cache if recently loaded.
         *
         * @param {string} key - Hash of object to load.
         * @param {ProjectInterface~loadObjectCallback} callback - Invoked when object is loaded.
         * @func
         */
        this.loadObject = this.projectCache.loadObject;

        /**
         * Collects the objects from the server and pre-loads them into the cache
         * making the load of multiple objects faster.
         *
         * @param {string} rootKey - Hash of the object at the entry point of the paths.
         * @param {string[]} paths - List of paths that needs to be pre-loaded.
         * @param {function} callback - Invoked when objects have been collected.
         * @func
         */
        this.loadPaths = this.projectCache.loadPaths;

        /**
         * Makes a commit to data base. Based on the root hash and commit message a new
         * {@link module:Storage.CommitObject} (with returned hash)
         * is generated and insert together with the core objects to the database on the server.
         *
         * @example
         * var persisted = core.persist(rootNode);
         *
         * project.makeCommit('master', ['#thePreviousCommitHash'], persisted.rootHash, persisted.objects, 'new commit')
         *   .then(function (result) {
         *     // result = {
         *     //   status: 'SYNCED',
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })
         *   .catch(function (error) {
         *     // error.message = 'Not authorized to read project: guest+project'
         *   });
         * @example
         * project.makeCommit('master', ['#notPreviousCommitHash'], persisted.rootHash, persisted.objects, 'new commit')
         *   .then(function (result) {
         *     // result = {
         *     //   status: 'FORKED',
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })...
         * @example
         * project.makeCommit(null, ['#anExistingCommitHash'], persisted.rootHash, persisted.objects, 'new commit')
         *   .then(function (result) {
         *     // result = {
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })...
         * @example
         * project.makeCommit('master', ['#aPreviousCommitHash'], previousRootHash, {}, 'just adding a commit to master')
         *   .then(function (result) {
         *     // result = {
         *     //   status: 'SYNCED',
         *     //   hash: '#thisCommitHash'
         *     // }
         *   })...
         * @param {string} branchName - Name of branch to update (none if null).
         * @param {module:Storage~CommitHash[]} parents - Parent commit hashes.
         * @param {module:Core~ObjectHash} rootHash - Hash of root object.
         * @param {module:Core~DataObject} coreObjects - Core objects associated with the commit.
         * @param {string} msg='n/a' - Commit message.
         * @param {function} [callback] - If provided no promise will be returned.
         * @async
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {Error} <b>error</b>.
         */
        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {
            throw new Error('makeCommit must be overridden in derived class');
        };

        /**
         * Updates the head of the branch.
         * @param {string} branchName - Name of branch to update.
         * @param {module:Storage~CommitHash} newHash - New commit hash for branch head.
         * @param {module:Storage~CommitHash} oldHash - Current state of the branch head inside the database.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.setBranchHash = function (branchName, newHash, oldHash, callback) {
            throw new Error('setBranchHash must be overridden in derived class');
        };

        /**
         * Retrieves the commit hash for the head of the branch.
         * @param {string} branchName - Name of branch.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {module:Storage~CommitHash} <b>branchHash</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getBranchHash = function (branchName, callback) {
            throw new Error('getBranchHash must be overridden in derived class');
        };

        /**
         * Creates a new branch with head pointing to the provided commit hash.
         * @param {string} branchName - Name of branch to create.
         * @param {module:Storage~CommitHash} newHash - New commit hash for branch head.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.createBranch = function (branchName, newHash, callback) {
            throw new Error('createBranch must be overridden in derived class');
        };

        /**
         * Deletes the branch.
         * @param {string} branchName - Name of branch to create.
         * @param {module:Storage~CommitHash} oldHash - Previous commit hash for branch head.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitResult} <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.deleteBranch = function (branchName, oldHash, callback) {
            throw new Error('deleteBranch must be overridden in derived class');
        };

        /**
         * Retrieves all branches and their current heads within the project.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * Object.<string, {@link module:Storage~CommitHash}> <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getBranches = function (callback) {
            throw new Error('getBranches must be overridden in derived class');
        };

        /**
         * Retrieves an array of commits starting from a branch(es) and/or commitHash(es).
         * <br> The result is ordered by the rules (applied in order)
         * <br> 1. Descendants are always returned before their ancestors.
         * <br> 2. By their timestamp.
         * @param {string|module:Storage~CommitHash|Array} start - Branch name, commit hash or array of these.
         * @param {number} number - Number of commits to load.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * Array.<{@link module:Storage~CommitObject}> <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getHistory = function (start, number, callback) {
            throw new Error('getHistory must be overridden in derived class');
        };

        /**
         * Retrieves and array of the latest (sorted by timestamp) commits for the project.
         * If timestamp is given it will get <b>number</b> of commits strictly before <b>before</b>.
         * If commit hash is specified that commit will be included too.
         * <br> N.B. due to slight time differences on different machines, ancestors may be returned before
         * their descendants. Unless looking for 'headless' commits 'getHistory' is the preferred method.
         * @param {number|module:Storage~CommitHash} before - Timestamp or commitHash to load history from.
         * @param {number} number - Number of commits to load.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * Array.<{@link module:Storage~CommitObject}> <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getCommits = function (before, number, callback) {
            throw new Error('getCommits must be overridden in derived class');
        };

        /**
         * Creates a new tag pointing to the provided commit hash.
         * @param {string} tagName - Name of tag to create.
         * @param {module:Storage~CommitHash} commitHash - Commit hash tag will point to.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with nothing.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.createTag = function (tagName, commitHash, callback) {
            throw new Error('createTag must be overridden in derived class');
        };

        /**
         * Deletes the given tag.
         * @param {string} tagName - Name of tag to delete.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with nothing.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.deleteTag = function (tagName, callback) {
            throw new Error('deleteTag must be overridden in derived class');
        };

        /**
         * Retrieves all tags and their commits hashes within the project.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * Object.<string, {@link module:Storage~CommitHash}> <b>result</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getTags = function (callback) {
            throw new Error('getTags must be overridden in derived class');
        };

        /**
         * Retrieves the common ancestor of two commits. If no ancestor exists it will result in an error.
         *
         * @param {module:Storage~CommitHash} commitA - Commit hash.
         * @param {module:Storage~CommitHash} commitB - Commit hash.
         * @param {function} [callback] - if provided no promise will be returned.
         *
         * @return {external:Promise}  On success the promise will be resolved with
         * {@link module:Storage~CommitHash} <b>commonCommitHash</b>.<br>
         * On error the promise will be rejected with {@link Error} <b>error</b>.
         */
        this.getCommonAncestorCommit = function (commitA, commitB, callback) {
            throw new Error('getCommonAncestorCommit must be overridden in derived class');
        };
    }

    return ProjectInterface;
});

/*globals define*/
/*jshint browser: true, node:true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/project/branch',['common/storage/constants'], function (CONSTANTS) {
    'use strict';

    function Branch(name, mainLogger) {
        var self = this,
            logger = mainLogger.fork('Branch:' + name),
            originHash = '',
            localHash = '',
            commitQueue = [],
            updateQueue = [],
            branchStatus = CONSTANTS.BRANCH_STATUS.SYNC;

        logger.debug('ctor');
        this.name = name;
        this.isOpen = true;
        this.inSync = true;

        this.branchStatusHandlers = [];
        this.hashUpdateHandlers = [];
        this.callbackQueue = [];

        /**
         * @type {Error[]}
         */
        this.errorList = [];

        this._remoteUpdateHandler = null;

        this.cleanUp = function () {
            var i,
                commitResult;
            self.isOpen = false;
            self.branchStatusHandlers = [];
            self.hashUpdateHandlers = [];

            self._remoteUpdateHandler = null;
            for (i = 0; i < self.callbackQueue.length; i += 1) {
                // Make sure there are no pending callbacks, invoke with status CANCELED.
                commitResult = {
                    status: CONSTANTS.CANCELED,
                    hash: commitQueue[i].commitObject[CONSTANTS.MONGO_ID]
                };
                self.callbackQueue[i](null, commitResult);
            }
            self.callbackQueue = [];
            commitQueue = [];
            updateQueue = [];
        };

        // Hash related functions
        this.getLocalHash = function () {
            return localHash;
        };

        this.getOriginHash = function () {
            return originHash;
        };

        this.updateHashes = function (newLocal, newOrigin) {
            logger.debug('updatingHashes');
            if (newLocal !== null) {
                logger.debug('localHash: old, new', localHash, newLocal);
                localHash = newLocal;
            }
            if (newOrigin !== null) {
                logger.debug('originHash: old, new', originHash, newOrigin);
                originHash = newOrigin;
            }
        };

        // Queue related functions
        this.queueCommit = function (commitData, commitCallback) {
            commitQueue.push(commitData);
            self.callbackQueue.push(commitCallback);
            logger.debug('Adding new commit to queue', commitQueue.length);
        };

        this.getFirstCommit = function (shift) {
            var commitData;
            if (shift) {
                commitData = commitQueue.shift();
                self.callbackQueue.shift();
                logger.debug('Removed commit from queue', commitQueue.length);
            } else {
                commitData = commitQueue[0];
            }

            return commitData;
        };

        this.getMergedCommit = function (mergeHash) {
            var mergeCommit,
                i = updateQueue.length;

            while (i) {
                i -= 1;
                if (updateQueue[i].commitObject[CONSTANTS.MONGO_ID] === mergeHash) {
                    mergeCommit = updateQueue[i];
                    break;
                }
            }

            if (!mergeCommit) {
                logger.error('mergeCommit not available in updateQueue', mergeHash, JSON.stringify(updateQueue, null, 2));
            }

            updateQueue = [];

            return mergeCommit;
        };

        this.getCommitQueue = function () {
            return commitQueue;
        };

        this.getCommitsForNewFork = function (upTillCommitHash) {
            var i,
                commitData,
                commitHash,
                commitHashExisted = false,
                subQueue = [];

            logger.debug('getCommitsForNewFork', upTillCommitHash);

            if (commitQueue.length === 0) {
                commitHash = localHash;

                logger.debug('No commits queued will fork from', commitHash);
                upTillCommitHash = upTillCommitHash || commitHash;
                commitHashExisted = upTillCommitHash === commitHash;
            } else {
                upTillCommitHash = upTillCommitHash ||
                    commitQueue[commitQueue.length - 1].commitObject[CONSTANTS.MONGO_ID];
            }

            logger.debug('Will fork up to commitHash', upTillCommitHash);

            // Move over all commit-data up till the chosen commitHash to the fork's queue,
            // except the commit that caused the fork (all its objects are already in the database).
            for (i = 0; i < commitQueue.length; i += 1) {
                commitData = commitQueue[i];
                commitHash = commitData.commitObject[CONSTANTS.MONGO_ID];
                if (i !== 0) {
                    subQueue.push(commitData);
                }
                if (commitData.commitObject[CONSTANTS.MONGO_ID] === upTillCommitHash) {
                    // The commitHash from where to fork has been reached.
                    // If any, the rest of the 'pending' commits will not be used.
                    commitHashExisted = true;
                    break;
                }
            }

            if (commitHashExisted === false) {
                logger.error('Could not find the specified commitHash', upTillCommitHash);
                return false;
            }

            return {commitHash: commitHash, queue: subQueue};
        };

        this.queueUpdate = function (updateData) {
            updateQueue.push(updateData);
            logger.debug('Adding new update to queue', updateQueue.length);
        };

        this.getUpdateQueue = function () {
            return updateQueue;
        };

        this.getFirstUpdate = function (shift) {
            var updateData;
            if (shift) {
                updateData = updateQueue.shift();
                logger.debug('Removed update from queue', updateQueue.length);
            } else {
                updateData = updateQueue[0];
            }

            return updateData;
        };

        // Event related functions
        this.addBranchStatusHandler = function (fn) {
            self.branchStatusHandlers.push(fn);
        };

        this.removeBranchStatusHandler = function (fn) {
            var i;

            for (i = 0; i < self.branchStatusHandlers.length; i += 1) {
                if (self.branchStatusHandlers[i] === fn) {
                    self.branchStatusHandlers.splice(i, 1);
                    return true;
                }
            }

            return false;
        };

        this.dispatchBranchStatus = function (newStatus, err) {
            var i;

            logger.debug('dispatchBranchStatus old, new', branchStatus, newStatus);

            if (branchStatus === CONSTANTS.BRANCH_STATUS.ERROR) {
                logger.error('In error state, action from user required!');
                newStatus = branchStatus;
            } else {
                branchStatus = newStatus;
            }

            if (err) {
                this.errorList.push(err instanceof Error ? err : new Error(err));
            }

            for (i = 0; i < self.branchStatusHandlers.length; i += 1) {
                self.branchStatusHandlers[i](newStatus, commitQueue, updateQueue);
            }
        };

        this.addHashUpdateHandler = function (fn) {
            self.hashUpdateHandlers.push(fn);
        };

        this.removeHashUpdateHandler = function (fn) {
            var i;

            for (i = 0; i < self.hashUpdateHandlers.length; i += 1) {
                if (self.hashUpdateHandlers[i] === fn) {
                    self.hashUpdateHandlers.splice(i, 1);
                    return true;
                }
            }

            return false;
        };

        this.dispatchHashUpdate = function (data, callback) {
            var i,
                error = null,
                counter = self.hashUpdateHandlers.length,
                allProceed = true,
                counterCallback = function (err, proceed) {
                    error = error || err; // Use the latest error
                    allProceed = allProceed && proceed === true;
                    counter -= 1;
                    if (counter === 0) {
                        callback(error, allProceed);
                    }
                };

            for (i = 0; i < self.hashUpdateHandlers.length; i += 1) {
                self.hashUpdateHandlers[i](data, commitQueue, updateQueue, counterCallback);
            }
        };
    }

    return Branch;
});
/*globals define*/
/*jshint browser: true, node:true*/
/**

 *
 * Storage.openProject resolves with an instance of this classes.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/project/project',[
    'common/storage/project/interface',
    'common/storage/project/branch',
    'q'
], function (ProjectInterface, Branch, Q) {
    'use strict';

    /**
     * This project uses a common storage to connect to the database on the server via web-sockets.
     * It can run under both nodeJS and in the browser.
     *
     *
     * @param {string} projectId - Id of project to be opened.
     * @param {object} storage - Storage connected to the server and database.
     * @param {object} mainLogger - Logger instance.
     * @param {GmeConfig} gmeConfig
     * @alias Project
     * @constructor
     * @augments ProjectInterface
     */
    function Project(projectId, storage, mainLogger, gmeConfig) {
        var self = this;
        this.branches = {};

        ProjectInterface.call(this, projectId, storage, mainLogger, gmeConfig);

        // Functions defined in ProjectInterface
        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {
            return Q.ninvoke(storage, 'makeCommit', self.projectId, branchName, parents, rootHash, coreObjects, msg)
                .nodeify(callback);
        };

        this.setBranchHash = function (branchName, newHash, oldHash, callback) {
            return Q.ninvoke(storage, 'setBranchHash', self.projectId, branchName, newHash, oldHash)
                .nodeify(callback);
        };

        this.getBranchHash = function (branchName, callback) {
            return Q.ninvoke(storage, 'getBranchHash', self.projectId, branchName)
                .nodeify(callback);
        };

        this.createBranch = function (branchName, newHash, callback) {
            return Q.ninvoke(storage, 'createBranch', self.projectId, branchName, newHash)
                .nodeify(callback);
        };

        this.deleteBranch = function (branchName, oldHash, callback) {
            return Q.ninvoke(storage, 'deleteBranch', self.projectId, branchName, oldHash)
                .nodeify(callback);
        };

        this.getBranches = function (callback) {
            return Q.ninvoke(storage, 'getBranches', self.projectId)
                .nodeify(callback);
        };

        this.createTag = function (tagName, commitHash, callback) {
            return Q.ninvoke(storage, 'createTag', self.projectId, tagName, commitHash)
                .nodeify(callback);
        };

        this.deleteTag = function (tagName, callback) {
            return Q.ninvoke(storage, 'deleteTag', self.projectId, tagName)
                .nodeify(callback);
        };

        this.getTags = function (callback) {
            return Q.ninvoke(storage, 'getTags', self.projectId)
                .nodeify(callback);
        };

        this.getCommits = function (before, number, callback) {
            return Q.ninvoke(storage, 'getCommits', self.projectId, before, number)
                .nodeify(callback);
        };

        this.getHistory = function (start, number, callback) {
            return Q.ninvoke(storage, 'getHistory', self.projectId, start, number)
                .nodeify(callback);
        };

        this.getCommonAncestorCommit = function (commitA, commitB, callback) {
            return Q.ninvoke(storage, 'getCommonAncestorCommit', self.projectId, commitA, commitB)
                .nodeify(callback);
        };

        this.squashCommits = function (fromCommit, toCommitOrBranch, message, callback) {
            return Q.ninvoke(storage, 'squashCommits', self.projectId, fromCommit, toCommitOrBranch, message)
                .nodeify(callback);
        };
    }

    Project.prototype = Object.create(ProjectInterface.prototype);
    Project.prototype.constructor = Project;

    return Project;
});
/*globals define*/
/*jshint node:true*/
/**
 * This class implements the functionality needed to edit a model in a specific project and branch in a
 * collaborative fashion.
 *
 * It keeps a state of the open projects which in turn keeps track of the open branches.
 *
 * Each project is associated with a project-cache which is shared amongst the branches. So switching
 * between branches is (potentially) an operation that does not require lots of server round-trips.
 *
 * It is possible to have multiple projects open and multiple branches within each project. However
 * one instance of a storage can only hold a single instance of a project (or branch within a project).
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/storageclasses/editorstorage',[
    'common/storage/storageclasses/objectloaders',
    'common/storage/constants',
    'common/storage/project/project',
    'common/storage/project/branch',
    'common/util/assert',
    'common/util/key',
    'common/storage/util',
    'q'
], function (StorageObjectLoaders, CONSTANTS, Project, Branch, ASSERT, GENKEY, UTIL, Q) {
    'use strict';

    /**
     *
     * @param webSocket
     * @param mainLogger
     * @param gmeConfig
     * @constructor
     */
    function EditorStorage(webSocket, mainLogger, gmeConfig) {
        var self = this,
            logger = mainLogger.fork('storage'),
            projects = {};

        self.logger = logger;
        self.userId = null;
        self.serverVersion = null;

        StorageObjectLoaders.call(this, webSocket, mainLogger, gmeConfig);

        this.open = function (networkHandler) {
            webSocket.connect(function (err, connectionState) {
                if (err) {
                    logger.error(err);
                    networkHandler(CONSTANTS.CONNECTION_ERROR);
                } else if (connectionState === CONSTANTS.CONNECTED) {
                    self.connected = true;
                    self.userId = webSocket.userId;
                    self.serverVersion = webSocket.serverVersion;
                    networkHandler(connectionState);
                } else if (connectionState === CONSTANTS.RECONNECTED) {
                    self.connected = true;
                    self._rejoinWatcherRooms()
                        .then(function () {
                            return self._rejoinBranchRooms();
                        })
                        .then(function () {
                            networkHandler(connectionState);
                        })
                        .catch(function (err) {
                            logger.error('failing during reconnect', err);
                            networkHandler(CONSTANTS.CONNECTION_ERROR);
                        });

                } else if (connectionState === CONSTANTS.DISCONNECTED) {
                    self.connected = false;
                    networkHandler(connectionState);
                } else if (connectionState === CONSTANTS.INCOMPATIBLE_CONNECTION) {
                    networkHandler(connectionState);
                } else if (connectionState === CONSTANTS.JWT_ABOUT_TO_EXPIRE) {
                    networkHandler(connectionState);
                } else if (connectionState === CONSTANTS.JWT_EXPIRED) {
                    networkHandler(connectionState);
                } else {
                    logger.error('unexpected connection state');
                    networkHandler(CONSTANTS.CONNECTION_ERROR);
                }
            });
        };

        this.close = function (callback) {
            var error = null,
                openProjects = Object.keys(projects),
                projectCnt = openProjects.length;

            logger.debug('Closing storage, openProjects', openProjects);

            function afterProjectClosed(err) {
                if (err) {
                    logger.error(err.message);
                    error = err;
                }
                logger.debug('inside afterProjectClosed projectCnt', projectCnt);
                if (projectCnt === 0) {
                    // Remove the handler for the socket.io events 'connect' and 'disconnect'.
                    logger.debug('Removing connect and disconnect events');
                    webSocket.socket.removeAllListeners('connect');
                    webSocket.socket.removeAllListeners('disconnect');
                    // Disconnect from the server.
                    logger.debug('Disconnecting web-socket');
                    webSocket.disconnect();
                    self.connected = false;
                    // Remove all local event-listeners.
                    webSocket.clearAllEvents();
                    callback(error);
                }
            }

            if (projectCnt > 0) {
                while (projectCnt) {
                    projectCnt -= 1;
                    this.closeProject(openProjects[projectCnt], afterProjectClosed);
                }
            } else {
                logger.debug('No projects were open, will disconnect directly');
                afterProjectClosed(null);
            }
        };

        /**
         * Callback for openProject.
         *
         * @callback EditorStorage~openProjectCallback
         * @param {string} err - error string.
         * @param {Project} project - the newly opened project.
         * @param {object} branches - the newly opened project.
         * @example
         * // branches is of the form
         * // { master: '#somevalidhash', b1: '#someothervalidhash' }
         */

        /**
         *
         * @param {string} projectId - name of project to open.
         * @param {EditorStorage~openProjectCallback} - callback
         */
        this.openProject = function (projectId, callback) {
            var data = {
                projectId: projectId
            };
            if (projects[projectId]) {
                callback(new Error('project is already open ' + projectId));
                return;
            }

            webSocket.openProject(data, function (err, branches, access) {
                if (err) {
                    callback(err);
                    return;
                }
                var project = new Project(projectId, self, logger, gmeConfig);
                projects[projectId] = project;
                callback(null, project, branches, access);
            });
        };

        this.closeProject = function (projectId, callback) {
            var project = projects[projectId],
                error = null,
                branchCnt,
                branchNames;
            logger.debug('closeProject', projectId);

            function closeAndDelete(err) {
                if (err) {
                    logger.error(err.message);
                    error = err;
                }
                logger.debug('inside closeAndDelete branchCnt', branchCnt);
                if (branchCnt === 0) {
                    webSocket.closeProject({projectId: projectId}, function (err) {
                        logger.debug('project closed on server.');
                        delete projects[projectId];
                        callback(err || error);
                    });
                }
            }

            if (project) {
                branchNames = Object.keys(project.branches);
                branchCnt = branchNames.length;
                if (branchCnt > 0) {
                    logger.warn('Branches still open for project, will be closed.', projectId, branchNames);
                    while (branchCnt) {
                        branchCnt -= 1;
                        this.closeBranch(projectId, branchNames[branchCnt], closeAndDelete);
                    }
                } else {
                    closeAndDelete(null);
                }
            } else {
                logger.warn('Project is not open ', projectId);
                callback(null);
            }

        };

        this.openBranch = function (projectId, branchName, hashUpdateHandler, branchStatusHandler, callback) {
            var project = projects[projectId],
                data = {
                    projectId: projectId,
                    branchName: branchName
                },
                branch;

            if (!project) {
                callback(new Error('Cannot open branch, ' + branchName + ', project ' + projectId + ' is not opened.'));
                return;
            }

            if (project.branches[branchName]) {
                callback(new Error('Branch is already open ' + branchName + ', project: ' + projectId));
                return;
            }

            logger.debug('openBranch, calling webSocket openBranch', projectId, branchName);

            webSocket.openBranch(data, function (err, latestCommit) {
                var branchHash;
                if (err) {
                    callback(err);
                    return;
                }

                branch = new Branch(branchName, project.logger);
                project.branches[branchName] = branch;

                // Update state of branch
                branch.latestCommitData = latestCommit;
                branchHash = latestCommit.commitObject[CONSTANTS.MONGO_ID];
                branch.updateHashes(branchHash, branchHash);

                // Add handlers to branch and set the remote update handler for the web-socket.
                branch.addHashUpdateHandler(hashUpdateHandler);
                branch.addBranchStatusHandler(branchStatusHandler);

                branch._remoteUpdateHandler = function (_ws, updateData, initCallback) {
                    var j,
                        originHash = updateData.commitObject[CONSTANTS.MONGO_ID];
                    logger.debug('_remoteUpdateHandler invoked for project, branch', projectId, branchName);
                    for (j = 0; j < updateData.coreObjects.length; j += 1) {
                        if (updateData.coreObjects[j] && updateData.coreObjects[j].type === 'patch') {
                            project.insertPatchObject(updateData.coreObjects[j]);
                        } else {
                            project.insertObject(updateData.coreObjects[j]);
                        }
                    }

                    branch.queueUpdate(updateData);
                    branch.updateHashes(null, originHash);

                    if (branch.getCommitQueue().length === 0) {
                        if (branch.getUpdateQueue().length === 1) {
                            self._pullNextQueuedCommit(projectId, branchName, initCallback); // hashUpdateHandlers
                        }
                    } else {
                        logger.debug('commitQueue is not empty, only updating originHash.');
                    }
                };

                branch._remoteUpdateHandler(null, latestCommit, function (err) {
                    webSocket.addEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),
                        branch._remoteUpdateHandler);
                    callback(err, latestCommit);
                });
            });
        };

        this.closeBranch = function (projectId, branchName, callback) {
            var project = projects[projectId],
                branch;

            logger.debug('closeBranch', projectId, branchName);

            if (!project) {
                logger.warn('closeBranch: project is not open', projectId, branchName);
                callback(null);
                return;
            }

            branch = project.branches[branchName];

            if (!branch) {
                logger.warn('closeBranch: project does not have given branch.', projectId, branchName);
                callback(null);
                return;
            }

            // This will prevent memory leaks and expose if a commit is being
            // processed at the server this time (see last error in _pushNextQueuedCommit).
            branch.dispatchBranchStatus(null);

            // Stop listening to events from the server
            webSocket.removeEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),
                branch._remoteUpdateHandler);

            branch.cleanUp();

            webSocket.closeBranch({projectId: projectId, branchName: branchName}, function (err) {
                delete project.branches[branchName];
                callback(err);
            });
        };

        this.forkBranch = function (projectId, branchName, forkName, commitHash, callback) {
            var project = projects[projectId],
                branch,
                forkData;

            this.logger.debug('forkBranch', projectId, branchName, forkName, commitHash);

            if (!project) {
                callback(new Error('Cannot fork branch, ' + branchName + ', project ' + projectId + ' is not opened.'));
                return;
            }

            branch = project.branches[branchName];

            if (!branch) {
                callback(new Error('Cannot fork branch, branch is not open ' + branchName + ', project: ' + projectId));
                return;
            }

            forkData = branch.getCommitsForNewFork(commitHash, forkName); // commitHash = null defaults to latest commit
            self.logger.debug('forkBranch - forkData', forkData);

            if (forkData === false) {
                callback(new Error('Could not find specified commitHash: ' + commitHash));
                return;
            }

            self.persistCommits(forkData.queue, function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                self.createBranch(projectId, forkName, forkData.commitHash, function (err) {
                    if (err) {
                        logger.error('forkBranch - failed creating new branch', err);
                        callback(err);
                        return;
                    }

                    callback(null, forkData.commitHash);
                });
            });
        };

        this.persistCommits = function (commitQueue, callback) {
            var commitHash;

            function commitNext(i) {
                var currentCommitData = commitQueue[i];

                if (i < commitQueue.length) {
                    currentCommitData = commitQueue[i];
                    logger.debug('persistCommits - commitNext, currentCommitData', currentCommitData);
                    delete currentCommitData.branchName;
                    commitHash = currentCommitData.commitObject[CONSTANTS.MONGO_ID];

                    webSocket.makeCommit(currentCommitData, function (err, result) {
                        if (err) {
                            logger.error('persistCommits - failed committing', err);
                            callback(err);
                            return;
                        }

                        logger.debug('persistCommits - commit successful, hash', result);
                        commitNext(i += 1);
                    });
                } else {
                    callback(null, commitHash);
                }
            }

            commitNext(0);
        };

        this.makeCommit = function (projectId, branchName, parents, rootHash, coreObjects, msg, callback) {
            var project = projects[projectId],
                branch,
                commitId,
                commitCallback,
                persistQueueElement = {},
                commitData = {
                    rootHash: rootHash,
                    projectId: projectId,
                    commitObject: null,
                    coreObjects: {},
                    changedNodes: null
                },
                keys = Object.keys(coreObjects),
                i;

            //handling patch object creation
            //console.time('patch-computation');
            for (i = 0; i < keys.length; i += 1) {
                if (UTIL.coreObjectHasOldAndNewData(coreObjects[keys[i]])) {
                    // Patch type object.
                    persistQueueElement[keys[i]] = coreObjects[keys[i]].newData;
                    if (keys[i] === rootHash) {
                        //console.time('root-patch-computation');
                    }
                    commitData.coreObjects[keys[i]] = UTIL.getPatchObject(coreObjects[keys[i]].oldData,
                        coreObjects[keys[i]].newData);
                    //if (keys[i] === rootHash) {
                    //console.timeEnd('root-patch-computation');
                    //}
                } else if (coreObjects[keys[i]].newData && coreObjects[keys[i]].newHash) {
                    // A new object with no previous data (send the entire data).
                    commitData.coreObjects[keys[i]] = coreObjects[keys[i]].newData;
                    persistQueueElement[keys[i]] = coreObjects[keys[i]].newData;
                } else {
                    // A regular object.
                    commitData.coreObjects[keys[i]] = coreObjects[keys[i]];
                    persistQueueElement[keys[i]] = coreObjects[keys[i]];
                }
            }
            //console.timeEnd('patch-computation');
            //console.time('getChangedNodes');
            commitData.changedNodes = UTIL.getChangedNodes(commitData.coreObjects, rootHash);

            //console.timeEnd('getChangedNodes');

            commitData.commitObject = self._getCommitObject(projectId, parents, commitData.rootHash, msg);

            if (project) {
                project.insertObject(commitData.commitObject);
                commitId = commitData.commitObject[CONSTANTS.MONGO_ID];

                commitCallback = function commitCallback() {
                    delete project.projectCache.queuedPersists[commitId];
                    self.logger.debug('Removed now persisted core-objects from cache: ',
                        Object.keys(project.projectCache.queuedPersists).length);
                    callback.apply(null, arguments);
                };

                project.projectCache.queuedPersists[commitId] = persistQueueElement;
                logger.debug('Queued non-persisted core-objects in cache: ',
                    Object.keys(project.projectCache.queuedPersists).length);
            } else {
                commitCallback = callback;
            }

            if (typeof branchName === 'string') {
                commitData.branchName = branchName;
                branch = project ? project.branches[branchName] : null;
            }

            logger.debug('makeCommit', commitData);
            if (branch) {
                logger.debug('makeCommit, branch is open will commit using commitQueue. branchName:', branchName);
                self._commitToBranch(projectId, branchName, commitData, parents[0], commitCallback);
            } else {
                webSocket.makeCommit(commitData, commitCallback);
            }
        };

        this.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {
            var project = projects[projectId],
                branch;

            logger.debug('setBranchHash', projectId, branchName, newHash, oldHash);
            if (project && project.branches[branchName]) {
                branch = project.branches[branchName];
                logger.debug('setBranchHash, branch is open, will notify other local users about change');
                project.loadObject(newHash, function (err, commitObject) {
                    var commitData;
                    if (err) {
                        logger.error('setBranchHash, failed to load in commitObject');
                        //branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                        callback(err);
                        return;
                    }
                    logger.debug('setBranchHash, loaded commitObject');
                    commitData = {
                        projectId: projectId,
                        branchName: branchName,
                        coreObjects: {},
                        changedNodes: null,
                        commitObject: commitObject,
                        oldHash: oldHash
                    };
                    self._commitToBranch(projectId, branchName, commitData, oldHash, callback);
                });
            } else {
                StorageObjectLoaders.prototype.setBranchHash.call(self,
                    projectId, branchName, newHash, oldHash, callback);
            }
        };

        this._commitToBranch = function (projectId, branchName, commitData, oldCommitHash, callback) {
            var project = projects[projectId],
                newCommitHash = commitData.commitObject._id,
                branch = project.branches[branchName],
                wasFirstInQueue,
                eventData = {
                    commitData: commitData,
                    local: true
                };

            logger.debug('_commitToBranch, [oldCommitHash, localHash]', oldCommitHash, branch.getLocalHash());

            if (oldCommitHash === branch.getLocalHash()) {
                branch.updateHashes(newCommitHash, null);
                branch.queueCommit(commitData, callback);

                if (branch.inSync === false) {
                    branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);
                } else {
                    branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);
                }

                // Get the queue length before dispatching because within the asynchrony,
                // the queue may get longer and we end up never pushing any commit.
                wasFirstInQueue = branch.getCommitQueue().length === 1;

                branch.dispatchHashUpdate(eventData, function (err, proceed) {
                    logger.debug('_commitToBranch, dispatchHashUpdate done. [err, proceed]', err, proceed);

                    if (err) {
                        branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                        callback(new Error('Commit failed being loaded in users: ' + err));
                    } else if (proceed === true) {
                        if (wasFirstInQueue) {
                            logger.debug('_commitToBranch, commit was first in queue - will start pushing commit');
                            self._pushNextQueuedCommit(projectId, branchName);
                        } else {
                            logger.debug('_commitToBranch, commit was NOT first in queue');
                        }
                    } else {
                        callback(new Error('Commit halted when loaded in users: ' + err));
                    }
                });
            } else {
                // The current user is behind the local branch, e.g. plugin trying to save after client changes.
                logger.warn('_commitToBranch, incoming commit parent was not the same as the localHash ' +
                    'for the branch, commit will be canceled!');
                callback(null, {status: CONSTANTS.CANCELED, hash: newCommitHash});
            }
        };

        this._pushNextQueuedCommit = function (projectId, branchName) {
            var project = projects[projectId],
                branch = project.branches[branchName],
                commitData;

            logger.debug('_pushNextQueuedCommit, length=', branch.getCommitQueue().length);

            commitData = branch.getFirstCommit();

            logger.debug('_pushNextQueuedCommit, makeCommit [from# -> to#]',
                commitData.commitObject.parents[0], commitData.commitObject._id);

            webSocket.makeCommit(commitData, function (err, result) {
                var mergeCommitData;
                if (err) {
                    logger.error('makeCommit failed', err);
                }

                if (branch.isOpen) {
                    branch.callbackQueue[0](err, result);
                    if (!err && result) {
                        if (result.status === CONSTANTS.SYNCED) {
                            branch.inSync = true;
                            branch.updateHashes(null, result.hash);
                            branch.getFirstCommit(true);
                            if (branch.getCommitQueue().length === 0) {
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                            } else {
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);
                                self._pushNextQueuedCommit(projectId, branchName);
                            }
                        } else if (result.status === CONSTANTS.MERGED) {
                            branch.inSync = true;
                            branch.updateHashes(null, result.mergeHash);

                            if (branch.getCommitQueue().length === 1) {
                                // Finds the MERGED commit-data and clears the update-queue.
                                mergeCommitData = branch.getMergedCommit(result.mergeHash);
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.MERGING);
                                branch.dispatchHashUpdate({commitData: mergeCommitData, local: false},
                                    function (err, proceed) {
                                        branch.getFirstCommit(true);
                                        if (err) {
                                            logger.error('Loading of merged commit failed with error', err,
                                                {metadata: mergeCommitData});
                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                                        } else if (proceed === true) {
                                            logger.debug('Merged commit was successfully loaded, updating localHash.');
                                            branch.updateHashes(result.mergeHash, null);
                                            // TODO: What if a commit is made during the hashUpdate?
                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                                            return;
                                        } else {
                                            logger.warn('Loading of update commit was aborted',
                                                {metadata: result.mergeHash});
                                        }
                                    }
                                );
                            } else {
                                branch.getFirstCommit(true);
                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.MERGING);
                                self._pushNextQueuedCommit(projectId, branchName);
                            }
                        } else if (result.status === CONSTANTS.FORKED) {
                            branch.inSync = false;
                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);
                        } else {
                            err = new Error('Unsupported commit status ' + result.status);
                            logger.error(err);
                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                        }
                    } else {
                        branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                    }
                } else {
                    logger.error('_pushNextQueuedCommit returned from server but the branch was closed, ' +
                        'the branch has probably been closed while waiting for the response.', projectId, branchName);
                }
            });
        };

        this._pullNextQueuedCommit = function (projectId, branchName, callback) {
            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);
            var project = projects[projectId],
                branch = project.branches[branchName],
                error,
                updateData;

            if (!branch) {
                error = new Error('Branch, ' + branchName + ', not in project ' + projectId + '.');
                if (callback) {
                    callback(error);
                } else {
                    throw error;
                }
            }

            logger.debug('About to update, updateQueue', {metadata: branch.getUpdateQueue()});
            if (branch.getUpdateQueue().length === 0) {
                logger.debug('No queued updates, returns');
                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                if (callback) {
                    callback(null);
                }
                return;
            }

            updateData = branch.getFirstUpdate();

            if (branch.isOpen) {
                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.PULLING);
                branch.dispatchHashUpdate({commitData: updateData, local: false}, function (err, proceed) {
                    var originHash = updateData.commitObject[CONSTANTS.MONGO_ID];
                    if (err) {
                        logger.error('Loading of update commit failed with error', err, {metadata: updateData});
                        branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.ERROR, err);
                    } else if (proceed === true) {
                        logger.debug('New commit was successfully loaded, updating localHash.');
                        branch.updateHashes(originHash, null);
                        branch.getFirstUpdate(true);
                        if (branch.getCommitQueue().length === 0) {
                            self._pullNextQueuedCommit(projectId, branchName, callback);
                        }
                        return;
                    } else {
                        logger.warn('Loading of update commit was aborted', {metadata: updateData});
                    }
                    if (callback) {
                        callback(new Error('Loading the first commit was aborted'));
                    }
                });
            } else {
                logger.error('_pullNextQueuedCommit returned from server but the branch was closed.',
                    projectId, branchName);
            }
        };

        this._getCommitObject = function (projectId, parents, rootHash, msg) {
            msg = msg || 'n/a';
            var commitObj = {
                    root: rootHash,
                    parents: parents,
                    updater: [self.userId],
                    time: (new Date()).getTime(),
                    message: msg,
                    type: CONSTANTS.COMMIT_TYPE,
                    __v: CONSTANTS.VERSION
                },
                commitHash = '#' + GENKEY(commitObj, gmeConfig);

            commitObj[CONSTANTS.MONGO_ID] = commitHash;

            return commitObj;
        };

        this._rejoinBranchRooms = function (callback) {
            var projectId,
                project,
                branchName,
                branchRooms = [],
                promises = [];

            logger.debug('_rejoinBranchRooms');

            function afterRejoin(projectId, branchName) {
                var project = projects[projectId],
                    deferred = Q.defer();

                logger.debug('_rejoinBranchRooms, rejoined branch room', projectId, branchName);

                if (project) {
                    project.getBranchHash(branchName)
                        .then(function (branchHash) {
                            var branch = project.branches[branchName],
                                queuedCommitHash;
                            logger.debug('_rejoinBranchRooms received branchHash', projectId, branchName, branchHash);

                            if (!branch) {
                                throw new Error('_rejoinBranchRooms branch was closed ' + projectId + ':' + branchName);
                            }

                            if (branch.getCommitQueue().length > 0) {
                                queuedCommitHash = branch.getFirstCommit().commitObject._id;
                                logger.debug('_rejoinBranchRooms, commits were queued length=, firstQueuedCommitHash',
                                    branch.getCommitQueue().length, queuedCommitHash);

                                project.getCommonAncestorCommit(branchHash, queuedCommitHash)
                                    .then(function (commonCommitHash) {
                                        var result;
                                        // The commit made it to the server but the acknowledgement was
                                        // interrupted by the disconnect.

                                        logger.debug('_rejoinBranchRooms getCommonAncestorCommit',
                                            projectId, branchName, commonCommitHash);

                                        if (branch.isOpen === false) {
                                            throw new Error('_rejoinBranchRooms branch was closed ' +
                                                projectId + ':' + branchName);
                                        }

                                        function dispatchSynced() {
                                            result = {status: CONSTANTS.SYNCED, hash: branchHash};

                                            branch.callbackQueue[0](null, result);
                                            branch.inSync = true;
                                            branch.updateHashes(null, branchHash);
                                            branch.getFirstCommit(true);
                                            if (branch.getCommitQueue().length === 0) {
                                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);
                                            } else {
                                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);
                                                self._pushNextQueuedCommit(projectId, branchName);
                                            }
                                        }

                                        function dispatchForked() {
                                            result = {status: CONSTANTS.FORKED, hash: branchHash};

                                            branch.callbackQueue[0](null, result);
                                            branch.inSync = false;
                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);
                                        }

                                        // c - the commit made by this storage
                                        // H - the head of the branch
                                        if (commonCommitHash === queuedCommitHash) {
                                            // The commit is (or was) in sync with the branch.
                                            //  Hc  or  H
                                            //  |       c
                                            //  |       |
                                            // In case two the next commit made will be forked.
                                            dispatchSynced();
                                        } else if (commonCommitHash === branchHash) {
                                            // The branch has moved back since the commit was made.
                                            // Treat it like the commit was forked.
                                            //  c
                                            //  H
                                            dispatchForked();
                                        } else {
                                            // The branch has moved forward in a different direction.
                                            //  c   H
                                            //   \ /
                                            dispatchForked();
                                        }

                                        deferred.resolve();
                                    })
                                    .catch(function (err) {
                                        try {
                                            if (err.message.indexOf('Commit object does not exist [' +
                                                    queuedCommitHash) > -1) {
                                                // Commit never made it to the server - push it.
                                                logger.debug('First queued commit never made it to the server - push!');
                                                self._pushNextQueuedCommit(projectId, branchName);
                                                deferred.resolve();
                                            } else {
                                                deferred.reject(err);
                                            }
                                        } catch (err) {
                                            deferred.reject(err);
                                        }
                                    });
                            } else {
                                logger.debug('_rejoinBranchRooms, no commits were queued during disconnect.');
                                deferred.resolve();
                            }
                        })
                        .catch(function (err) {
                            deferred.reject(err);
                        });
                } else {
                    deferred.reject(new Error('_rejoinBranchRooms project was closed ' + projectId + ':' + branchName));
                }

                return deferred.promise;
            }

            for (projectId in projects) {
                if (projects.hasOwnProperty(projectId)) {
                    project = projects[projectId];
                    logger.debug('_rejoinBranchRooms found project', projectId);
                    for (branchName in project.branches) {
                        if (project.branches.hasOwnProperty(branchName)) {
                            logger.debug('_rejoinBranchRooms joining branch', projectId, branchName);

                            branchRooms.push({
                                projectId: projectId,
                                branchName: branchName
                            });

                            promises.push(Q.ninvoke(webSocket, 'watchBranch', {
                                projectId: projectId,
                                branchName: branchName,
                                join: true
                            }));
                        }
                    }
                }
            }

            return Q.all(promises)
                .then(function () {
                    return Q.all(branchRooms.map(function (data) {
                        // Deal with commit queue for each room after rejoining.
                        return afterRejoin(data.projectId, data.branchName);
                    }));
                })
                .nodeify(callback);
        };
    }

    EditorStorage.prototype = Object.create(StorageObjectLoaders.prototype);
    EditorStorage.prototype.constructor = EditorStorage;

    return EditorStorage;
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * @author kecso / https://github.com/kecso
 *
 * FIXME: is there a built in function to JavaScript to parse cookies?
 */

define('common/util/url',[],function () {
    'use strict';

    function parseCookie(cookie) {
        var parsed,
            elements,
            i,
            pair;

        cookie = decodeURIComponent(cookie);
        parsed = {};
        elements = cookie.split(/[;] */);
        for (i = 0; i < elements.length; i++) {
            pair = elements[i].split('=');
            parsed[pair[0]] = pair[1];
        }
        return parsed;
    }

    function urlToRefObject(url) {
        return {
            $ref: url
        };
    }

    return {
        parseCookie: parseCookie,
        urlToRefObject: urlToRefObject
    };
});

/*globals define, require, document*/
/*jshint browser:true, camelcase:false*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/socketio/browserclient',['common/util/url'], function (URL) {
    'use strict';

    function IoClient (mainLogger, gmeConfig) {
        var logger = mainLogger.fork('socketio-browserclient');

        this.connect = function (callback) {
            var hostAddress = window.location.protocol + '//' + window.location.host,
                socketIoUrl;

            if (window.__karma__) {
                // TRICKY: karma uses web sockets too, we need to use the gme server's port
                hostAddress = window.location.protocol + '//localhost:' + gmeConfig.server.port;
            }

            socketIoUrl = hostAddress + '/socket.io/socket.io.js';
            logger.debug('Will require socketIO from', socketIoUrl);

            require([socketIoUrl], function (io_) {
                var io = io_ || window.io,
                    socket;

                logger.debug('Connecting to "' + hostAddress + '" with options', gmeConfig.socketIO.clientOptions);
                socket = io.connect(hostAddress, gmeConfig.socketIO.clientOptions);
                callback(null, socket);
            });
        };

        this.getToken = function () {
            var cookies = URL.parseCookie(document.cookie);
            if (cookies[gmeConfig.authentication.jwt.cookieId]) {
                return cookies[gmeConfig.authentication.jwt.cookieId];
            }
        };
    }

    return IoClient;
});
/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author rkereskenyi / https://github.com/rkereskenyi
 */

define('common/EventDispatcher',[], function () {
    'use strict';

    var EventDispatcher = function () {
        this._eventList = {};
    };

    EventDispatcher.prototype = {
        _eventList: null,
        _getEvent: function (eventName, create) {
            // Check if Array of Event Handlers has been created
            if (!this._eventList[eventName]) {

                // Check if the calling method wants to create the Array
                // if not created. This reduces unneeded memory usage.
                if (!create) {
                    return null;
                }

                // Create the Array of Event Handlers
                this._eventList[eventName] = [];
                // new Array
            }

            // return the Array of Event Handlers already added
            return this._eventList[eventName];
        },
        addEventListener: function (eventName, handler) {
            // Get the Array of Event Handlers
            var evt = this._getEvent(eventName, true);

            // Add the new Event Handler to the Array
            evt.push(handler);
        },
        removeEventListener: function (eventName, handler) {
            // Get the Array of Event Handlers
            var evt = this._getEvent(eventName);

            if (!evt) {
                return;
            }

            // Helper Method - an Array.indexOf equivalent
            var getArrayIndex = function (array, item) {
                for (var i = 0; i < array.length; i++) {
                    if (array[i] === item) {
                        return i;
                    }
                }
                return -1;
            };

            // Get the Array index of the Event Handler
            var index = getArrayIndex(evt, handler);

            if (index > -1) {
                // Remove Event Handler from Array
                evt.splice(index, 1);
            }
        },
        removeAllEventListeners: function (eventName) {
            // Get the Array of Event Handlers
            var evt = this._getEvent(eventName);

            if (!evt) {
                return;
            }

            evt.splice(0, evt.length);
        },
        dispatchEvent: function (eventName, eventArgs) {
            // Get a function that will call all the Event Handlers internally
            var handler = this._getEventHandler(eventName);
            if (handler) {
                // call the handler function
                // Pass in "sender" and "eventArgs" parameters
                handler(this, eventArgs);
            }
        },
        clearAllEvents: function () {
            this._eventList = {};
        },
        _getEventHandler: function (eventName) {
            // Get Event Handler Array for this Event
            var evt = this._getEvent(eventName, false);
            if (!evt || evt.length === 0) {
                return null;
            }

            // Create the Handler method that will use currying to
            // call all the Events Handlers internally
            var h = function (sender, args) {
                for (var i = 0; i < evt.length; i++) {
                    evt[i](sender, args);
                }
            };

            // Return this new Handler method
            return h;
        }
    };

    return EventDispatcher;
});
/*globals define*/
/*jshint browser: true, node:true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

// socket.io-client
//
define('common/storage/socketio/websocket',[
    'common/EventDispatcher',
    'common/storage/constants'
], function (EventDispatcher, CONSTANTS) {

    'use strict';

    function WebSocket(ioClient, mainLogger, gmeConfig) {
        var self = this,
            logger = mainLogger.fork('WebSocket'),
            forcedDisconnect,
            beenConnected = false;

        self.socket = null;
        self.userId = null;
        self.serverVersion = null;

        logger.debug('ctor');
        EventDispatcher.call(this);

        function wrapError(callback) {
            return function () {
                if (typeof arguments[0] === 'string') {
                    callback(new Error(arguments[0]), arguments[1]); // Add second argument for e.g. pluginResults
                } else {
                    callback.apply(null, arguments);
                }
            };
        }

        this.connect = function (networkHandler) {
            logger.debug('Connecting via ioClient.');
            forcedDisconnect = false;

            ioClient.connect(function (err, socket_) {
                if (err) {
                    networkHandler(err);
                    return;
                }
                self.socket = socket_;

                self.socket.on('connect', function () {
                    var i,
                        sendBufferSave = [];
                    if (beenConnected) {
                        logger.debug('Socket got reconnected.');

                        // #368
                        for (i = 0; i < self.socket.sendBuffer.length; i += 1) {
                            // Clear all makeCommits. If pushed - they would be emitted back to the socket.
                            if (self.socket.sendBuffer[i].data[0] === 'makeCommit') {
                                logger.debug('Removed makeCommit from sendBuffer...');
                            } else {
                                sendBufferSave.push(self.socket.sendBuffer[i]);
                            }
                        }
                        if (self.socket.receiveBuffer.length > 0) {
                            // TODO: In which cases is this applicable??
                            logger.debug('receiveBuffer not empty after reconnect');
                        }
                        self.socket.sendBuffer = sendBufferSave;
                        self.socket.emit('getConnectionInfo', {webgmeToken: ioClient.getToken()}, function (err, info) {
                            if (err) {
                                networkHandler(new Error('Could not get info on reconnect'));
                            } else {
                                if (self.serverVersion === info.serverVersion) {
                                    networkHandler(null, CONSTANTS.RECONNECTED);
                                } else {
                                    networkHandler(null, CONSTANTS.INCOMPATIBLE_CONNECTION);
                                }
                            }
                        });
                    } else {
                        logger.debug('Socket got connected for the first time.');
                        beenConnected = true;
                        self.socket.emit('getConnectionInfo', {webgmeToken: ioClient.getToken()}, function (err, info) {
                            if (err) {
                                networkHandler(new Error('Could not get info on connect'));
                            } else {
                                self.userId = info.userId || gmeConfig.authentication.guestAccount;
                                self.serverVersion = info.serverVersion;
                                networkHandler(null, CONSTANTS.CONNECTED);
                            }
                        });
                    }
                });

                self.socket.on('disconnect', function () {
                    logger.debug('Socket got disconnected!');
                    networkHandler(null, CONSTANTS.DISCONNECTED);

                    // When the server is shut-down the skipReconnect is set to false
                    // create a new socket connect.
                    if (self.socket.io.skipReconnect === true && forcedDisconnect === false) {
                        self.connect(networkHandler);
                    }
                });

                self.socket.on(CONSTANTS.JWT_ABOUT_TO_EXPIRE, function (data) {
                    data.etype = CONSTANTS.JWT_ABOUT_TO_EXPIRE;
                    logger.debug('JWT_ABOUT_TO_EXPIRE event', {metadata: data});
                    networkHandler(null, CONSTANTS.JWT_ABOUT_TO_EXPIRE);
                });

                self.socket.on(CONSTANTS.JWT_EXPIRED, function (data) {
                    data.etype = CONSTANTS.JWT_EXPIRED;
                    logger.debug('JWT_EXPIRED event', {metadata: data});
                    networkHandler(null, CONSTANTS.JWT_EXPIRED);
                });

                self.socket.on(CONSTANTS.PROJECT_DELETED, function (data) {
                    data.etype = CONSTANTS.PROJECT_DELETED;
                    logger.debug('PROJECT_DELETED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.PROJECT_DELETED, data);
                });

                self.socket.on(CONSTANTS.PROJECT_CREATED, function (data) {
                    data.etype = CONSTANTS.PROJECT_CREATED;
                    logger.debug('PROJECT_CREATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.PROJECT_CREATED, data);
                });

                self.socket.on(CONSTANTS.BRANCH_CREATED, function (data) {
                    data.etype = CONSTANTS.BRANCH_CREATED;
                    logger.debug('BRANCH_CREATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.BRANCH_CREATED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.BRANCH_DELETED, function (data) {
                    data.etype = CONSTANTS.BRANCH_DELETED;
                    logger.debug('BRANCH_DELETED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.BRANCH_DELETED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.BRANCH_HASH_UPDATED, function (data) {
                    data.etype = CONSTANTS.BRANCH_HASH_UPDATED;
                    logger.debug('BRANCH_HASH_UPDATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.BRANCH_HASH_UPDATED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.TAG_CREATED, function (data) {
                    data.etype = CONSTANTS.TAG_CREATED;
                    logger.debug('TAG_CREATED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.TAG_CREATED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.TAG_DELETED, function (data) {
                    data.etype = CONSTANTS.TAG_DELETED;
                    logger.debug('TAG_DELETED event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.TAG_DELETED + data.projectId, data);
                });

                self.socket.on(CONSTANTS.BRANCH_UPDATED, function (data) {
                    logger.debug('BRANCH_UPDATED event', {metadata: data});
                    self.dispatchEvent(self.getBranchUpdateEventName(data.projectId, data.branchName), data);
                });

                self.socket.on(CONSTANTS.NOTIFICATION, function (data) {
                    logger.debug('NOTIFICATION event', {metadata: data});
                    self.dispatchEvent(CONSTANTS.NOTIFICATION, data);
                });
            });
        };

        this.disconnect = function () {
            forcedDisconnect = true;
            self.socket.disconnect();
            beenConnected = false; //This is a forced disconnect from the storage and all listeners are removed
        };

        // watcher functions
        this.watchDatabase = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('watchDatabase', data, wrapError(callback));
        };

        this.watchProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('watchProject', data, wrapError(callback));
        };

        this.watchBranch = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('watchBranch', data, wrapError(callback));
        };

        // model editing functions
        this.openProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('openProject', data, wrapError(callback));
        };

        this.closeProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('closeProject', data, wrapError(callback));
        };

        this.openBranch = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('openBranch', data, wrapError(callback));
        };

        this.closeBranch = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('closeBranch', data, wrapError(callback));
        };

        this.makeCommit = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('makeCommit', data, wrapError(callback));
        };

        this.loadObjects = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('loadObjects', data, wrapError(callback));
        };

        this.loadPaths = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('loadPaths', data, wrapError(callback));
        };

        this.setBranchHash = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('setBranchHash', data, wrapError(callback));
        };

        this.getBranchHash = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getBranchHash', data, wrapError(callback));
        };

        this.squashCommits = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('squashCommits', data, wrapError(callback));
        };

        // REST like functions
        this.getProjects = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getProjects', data, wrapError(callback));
        };

        this.deleteProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('deleteProject', data, wrapError(callback));
        };

        this.createProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('createProject', data, wrapError(callback));
        };

        this.transferProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('transferProject', data, wrapError(callback));
        };

        this.duplicateProject = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('duplicateProject', data, wrapError(callback));
        };

        this.getBranches = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getBranches', data, wrapError(callback));
        };

        this.createTag = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('createTag', data, wrapError(callback));
        };

        this.deleteTag = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('deleteTag', data, wrapError(callback));
        };

        this.getTags = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getTags', data, wrapError(callback));
        };

        this.getCommits = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getCommits', data, wrapError(callback));
        };

        this.getHistory = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getHistory', data, wrapError(callback));
        };

        this.getLatestCommitData = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getLatestCommitData', data, wrapError(callback));
        };

        this.getCommonAncestorCommit = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('getCommonAncestorCommit', data, wrapError(callback));
        };

        //temporary simple request / result functions
        this.simpleRequest = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('simpleRequest', data, wrapError(callback));
        };

        this.simpleQuery = function (workerId, data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('simpleQuery', workerId, data, wrapError(callback));
        };

        this.sendNotification = function (data, callback) {
            data.webgmeToken = ioClient.getToken();
            self.socket.emit('notification', data, wrapError(callback));
        };

        // Helper functions
        this.getBranchUpdateEventName = function (projectId, branchName) {
            return CONSTANTS.BRANCH_UPDATED + projectId + CONSTANTS.ROOM_DIVIDER + branchName;
        };
    }

    WebSocket.prototype = Object.create(EventDispatcher.prototype);
    WebSocket.prototype.constructor = WebSocket;

    return WebSocket;
});
/*globals define*/
/*jshint browser:true*/
/**
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/storage/browserstorage',[
    'common/storage/storageclasses/editorstorage',
    'common/storage/socketio/browserclient',
    'common/storage/socketio/websocket',
], function (EditorStorage, BrowserIoClient, WebSocket) {
    'use strict';

    var _storage;

    function _createStorage(logger, gmeConfig) {
        var ioClient = new BrowserIoClient(logger, gmeConfig),
            webSocket = new WebSocket(ioClient, logger, gmeConfig),
            storage = new EditorStorage(webSocket, logger, gmeConfig);

        return storage;
    }

    function getStorage (logger, gmeConfig, forceNew) {
        logger.debug('getStorage');

        if (!_storage) {
            logger.debug('No storage existed, will create new one..');
            _storage = _createStorage(logger, gmeConfig);
        } else {
            logger.debug('Storage existed...');

            if (forceNew === true) {
                logger.debug('Force new set to true, will create new one.');
                _storage = _createStorage(logger, gmeConfig);
            }
        }

        return _storage;
    }

    return {
        getStorage: getStorage
    };
});
/*globals define*/
/*jshint node: true, browser: true, camelcase: false*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

(function () {
    'use strict';

    // ------- assert -------

    var TASYNC_TRACE_ENABLE = true;

    function setTrace(value) {
        TASYNC_TRACE_ENABLE = value;
    }

    function assert(cond) {
        if (!cond) {
            throw new Error('tasync internal error');
        }
    }

    // ------- Future -------

    var STATE_LISTEN = 0;
    var STATE_REJECTED = 1;
    var STATE_RESOLVED = 2;

    var Future = function () {
        this.state = STATE_LISTEN;
        this.value = [];
    };

    Future.prototype.register = function (target) {
        assert(this.state === STATE_LISTEN);
        assert(typeof target === 'object' && target !== null);

        this.value.push(target);
    };

    Future.prototype.resolve = function (value) {
        assert(this.state === STATE_LISTEN && !(value instanceof Future));

        var listeners = this.value;

        this.state = STATE_RESOLVED;
        this.value = value;

        var i;
        for (i = 0; i < listeners.length; ++i) {
            listeners[i].onResolved(value);
        }
    };

    Future.prototype.reject = function (error) {
        assert(this.state === STATE_LISTEN && error instanceof Error);

        var listeners = this.value;

        this.state = STATE_REJECTED;
        this.value = error;

        var i;
        for (i = 0; i < listeners.length; ++i) {
            listeners[i].onRejected(error);
        }
    };

    // ------- Delay -------

    function delay(timeout, value) {
        if (timeout < 0) {
            return value;
        }

        var future = new Future();
        setTimeout(function () {
            future.resolve(value);
        }, timeout);
        return future;
    }

    // ------- Lift -------

    var FutureLift = function (array, index) {
        Future.call(this);

        this.array = array;
        this.index = index;
    };

    FutureLift.prototype = Object.create(Future.prototype);

    FutureLift.prototype.onResolved = function (value) {
        assert(this.state === STATE_LISTEN);

        var array = this.array;
        array[this.index] = value;

        while (++this.index < array.length) {
            value = array[this.index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    array[this.index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    value.register(this);
                    return;
                } else {
                    assert(value.state === STATE_REJECTED);
                    this.reject(value.value);
                    return;
                }
            }
        }

        this.array = null;
        this.resolve(array);
    };

    FutureLift.prototype.onRejected = function (error) {
        this.array = null;
        this.reject(error);
    };

    var lift = function (array) {
        if (!(array instanceof Array)) {
            throw new Error('array argument is expected');
        }

        var index;
        for (index = 0; index < array.length; ++index) {
            var value = array[index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    array[index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    var future = new FutureLift(array, index);
                    value.register(future);
                    return future;
                } else {
                    assert(value.state === STATE_REJECTED);
                    return value;
                }
            }
        }

        return array;
    };

    // ------- Apply -------

    var ROOT = {
        subframes: 0
    };

    var FRAME = ROOT;

    var FutureApply = function tasync_trace_end(func, that, args, index) {
        Future.call(this);

        this.caller = FRAME;
        this.position = ++FRAME.subframes;
        this.subframes = 0;

        if (TASYNC_TRACE_ENABLE) {
            this.trace = new Error();
        }

        this.func = func;
        this.that = that;
        this.args = args;
        this.index = index;
    };

    FutureApply.prototype = Object.create(Future.prototype);

    FutureApply.prototype.getPath = function () {
        var future = this.caller,
            path = [this.position];

        while (future !== ROOT) {
            path.push(future.position);
            future = future.caller;
        }

        return path;
    };

    function getSlice(trace) {
        assert(typeof trace === 'string');

        var end = trace.indexOf('tasync_trace_start');
        if (end >= 0) {
            end = trace.lastIndexOf('\n', end) + 1;
        } else {
            if (trace.charAt(trace.length - 1) !== '\n') {
                // trace += '\n';
            }
            end = undefined;
        }

        var start = trace.indexOf('tasync_trace_end');
        if (start >= 0) {
            start = trace.indexOf('\n', start) + 1;
            if (start >= 0) {
                start = trace.indexOf('\n', start) + 1;
            }
        } else {
            start = 0;
        }

        return trace.substring(start, end);
    }

    function createError(error, future) {
        if (!(error instanceof Error)) {
            error = new Error(error);
        }

        if (TASYNC_TRACE_ENABLE) {
            error.trace = getSlice(error.stack);
            do {
                error.trace += '*** callback ***\n';
                error.trace += getSlice(future.trace.stack);
                future = future.caller;
            } while (future !== ROOT);
        }

        return error;
    }

    FutureApply.prototype.onRejected = function (error) {
        this.args = null;
        this.reject(error);
    };

    FutureApply.prototype.onResolved = function tasync_trace_start(value) {
        assert(this.state === STATE_LISTEN);

        var args = this.args;
        args[this.index] = value;

        while (--this.index >= 0) {
            value = args[this.index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    args[this.index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    value.register(this);
                    return;
                } else {
                    assert(value.state === STATE_REJECTED);
                    this.reject(value.value);
                    return;
                }
            }
        }

        assert(FRAME === ROOT);
        FRAME = this;

        this.args = null;
        try {
            value = this.func.apply(this.that, args);
        } catch (error) {
            FRAME = ROOT;

            this.reject(createError(error, this));
            return;
        }

        FRAME = ROOT;

        if (value instanceof Future) {
            assert(value.state === STATE_LISTEN);

            this.onResolved = this.resolve;
            value.register(this);
        } else {
            this.resolve(value);
        }
    };

    var apply = function (func, args, that) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        } else if (!(args instanceof Array)) {
            throw new Error('array argument is expected');
        }

        var index = args.length;
        while (--index >= 0) {
            var value = args[index];
            if (value instanceof Future) {
                if (value.state === STATE_LISTEN) {
                    var future = new FutureApply(func, that, args, index);
                    value.register(future);
                    return future;
                } else if (value.state === STATE_RESOLVED) {
                    args[index] = value.value;
                } else {
                    assert(value.state === STATE_REJECTED);
                    return value;
                }
            }
        }

        return func.apply(that, args);
    };

    // ------- Call -------

    var FutureCall = function tasync_trace_end(args, index) {
        Future.call(this);

        this.caller = FRAME;
        this.position = ++FRAME.subframes;
        this.subframes = 0;

        if (TASYNC_TRACE_ENABLE) {
            this.trace = new Error();
        }

        this.args = args;
        this.index = index;
    };

    FutureCall.prototype = Object.create(Future.prototype);

    FutureCall.prototype.getPath = FutureApply.prototype.getPath;
    FutureCall.prototype.onRejected = FutureApply.prototype.onRejected;

    var FUNCTION_CALL = Function.call;

    FutureCall.prototype.onResolved = function tasync_trace_start(value) {
        assert(this.state === STATE_LISTEN);

        var args = this.args;
        args[this.index] = value;

        while (--this.index >= 0) {
            value = args[this.index];
            if (value instanceof Future) {
                if (value.state === STATE_RESOLVED) {
                    args[this.index] = value.value;
                } else if (value.state === STATE_LISTEN) {
                    value.register(this);
                    return;
                } else {
                    assert(value.state === STATE_REJECTED);
                    this.reject(value.value);
                    return;
                }
            }
        }

        assert(FRAME === ROOT);
        FRAME = this;

        this.args = null;
        try {
            var func = args[0];
            args[0] = null;
            value = FUNCTION_CALL.apply(func, args);
        } catch (error) {
            FRAME = ROOT;

            this.reject(createError(error, this));
            return;
        }

        FRAME = ROOT;

        if (value instanceof Future) {
            assert(value.state === STATE_LISTEN);

            this.onResolved = this.resolve;
            value.register(this);
        } else {
            this.resolve(value);
        }
    };

    var call = function () {
        var index = arguments.length;
        while (--index >= 0) {
            var value = arguments[index];
            if (value instanceof Future) {
                if (value.state === STATE_LISTEN) {
                    var future = new FutureCall(arguments, index);
                    value.register(future);
                    return future;
                } else if (value.state === STATE_RESOLVED) {
                    arguments[index] = value.value;
                } else {
                    assert(value.state === STATE_REJECTED);
                    return value;
                }
            }
        }

        var func = arguments[0];
        return FUNCTION_CALL.apply(func, arguments);
    };

    // ------- TryCatch -------

    function FutureTryCatch(handler) {
        Future.call(this);

        this.handler = handler;
    }

    FutureTryCatch.prototype = Object.create(Future.prototype);

    FutureTryCatch.prototype.onRejected = function (error) {
        try {
            var value = this.handler(error);

            if (value instanceof Future) {
                this.onRejected = Future.prorotype.reject;
                value.register(this);
            } else {
                this.resolve(value);
            }
        } catch (err) {
            this.reject(err);
        }
    };

    FutureTryCatch.prototype.onResolved = Future.prototype.resolve;

    function trycatch(func, handler) {
        if (typeof func !== 'function' || typeof handler !== 'function') {
            throw new Error('function arguments are expected');
        }

        try {
            var value = func();

            if (value instanceof Future) {
                var future = new FutureTryCatch(handler);
                value.register(future);

                return future;
            } else {
                return value;
            }
        } catch (error) {
            return handler(error);
        }
    }

    // ------- Wrap -------

    function wrap(func) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        }

        if (func.tasync_wraped === undefined) {
            func.tasync_wraped = function () {
                var args = arguments;
                var future = new Future();

                args[args.length++] = function (error, value) {
                    if (error) {
                        future.reject(error instanceof Error ? error : new Error(error));
                    } else {
                        future.resolve(value);
                    }
                };

                func.apply(this, args);

                if (future.state === STATE_LISTEN) {
                    return future;
                } else if (future.state === STATE_RESOLVED) {
                    return future.value;
                } else {
                    assert(future.state === STATE_REJECTED);
                    throw future.value;
                }
            };

            func.tasync_wraped.tasync_unwraped = func;
        }

        return func.tasync_wraped;
    }

    // ------- Unwrap -------

    function UnwrapListener(callback) {
        this.callback = callback;
    }

    UnwrapListener.prototype.onRejected = function (error) {
        this.callback(error);
    };

    UnwrapListener.prototype.onResolved = function (value) {
        this.callback(null, value);
    };

    function unwrap(func) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        }

        if (func.tasync_unwraped === undefined) {
            func.tasync_unwraped = function () {
                var args = arguments;

                var callback = args[--args.length];
                assert(typeof callback === 'function');

                var value;
                try {
                    value = func.apply(this, args);
                } catch (error) {
                    callback(error);
                    return;
                }

                if (value instanceof Future) {
                    assert(value.state === STATE_LISTEN);

                    var listener = new UnwrapListener(callback);
                    value.register(listener);
                } else {
                    callback(null, value);
                }
            };

            func.tasync_unwraped.tasync_wraped = func;
        }

        return func.tasync_unwraped;
    }

    // ------- Throttle -------

    function FutureThrottle(func, that, args) {
        Future.call(this);

        this.func = func;
        this.that = that;
        this.args = args;

        this.caller = FRAME;
        this.position = ++FRAME.subframes;

        this.path = this.getPath();
    }

    FutureThrottle.prototype = Object.create(Future.prototype);

    FutureThrottle.prototype.execute = function () {
        var value;
        try {
            assert(FRAME === ROOT);
            FRAME = this;

            value = this.func.apply(this.that, this.args);

            FRAME = ROOT;
        } catch (error) {
            FRAME = ROOT;

            this.reject(error);
            return;
        }

        if (value instanceof Future) {
            assert(value.state === STATE_LISTEN);
            value.register(this);
        } else {
            this.resolve(value);
        }
    };

    FutureThrottle.prototype.getPath = FutureApply.prototype.getPath;
    FutureThrottle.prototype.onResolved = Future.prototype.resolve;
    FutureThrottle.prototype.onRejected = Future.prototype.reject;

    FutureThrottle.prototype.compare = function (second) {
        var first = this.path;
        second = second.path;

        var i, limit = first.length < second.length ? first.length : second.length;
        for (i = 0; i < limit; ++i) {
            if (first[i] !== second[i]) {
                return first[i] - second[i];
            }
        }

        return first.length - second.length;
    };

    function ThrottleListener(limit) {
        this.running = 0;
        this.limit = limit;
        this.queue = [];
    }

    function priorityQueueInsert(queue, elem) {
        var low = 0;
        var high = queue.length;

        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            assert(low <= mid && mid < high);

            if (elem.compare(queue[mid]) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        queue.splice(low, 0, elem);
    }

    ThrottleListener.prototype.execute = function (func, that, args) {
        if (this.running < this.limit) {
            var value = func.apply(that, args);

            if (value instanceof Future) {
                assert(value.state === STATE_LISTEN);

                ++this.running;
                value.register(this);
            }

            return value;
        } else {
            var future = new FutureThrottle(func, that, args);
            priorityQueueInsert(this.queue, future);

            return future;
        }
    };

    ThrottleListener.prototype.onResolved = function () {
        if (this.queue.length > 0) {
            var future = this.queue.pop();
            future.register(this);

            future.execute();
        } else {
            --this.running;
        }
    };

    ThrottleListener.prototype.onRejected = ThrottleListener.prototype.onResolved;

    // TODO: prevent recursion, otheriwise throttle will not work
    function throttle(func, limit) {
        if (typeof func !== 'function') {
            throw new Error('function argument is expected');
        } else if (typeof limit !== 'number') {
            throw new Error('number argument is expected');
        }

        var listener = new ThrottleListener(limit);

        return function () {
            return listener.execute(func, this, arguments);
        };
    }

    // ------- Join -------

    function FutureJoin(first) {
        Future.call(this);

        this.first = first;
        this.missing = first instanceof Future && first.state === STATE_LISTEN ? 1 : 0;
    }

    FutureJoin.prototype = Object.create(Future.prototype);

    FutureJoin.prototype.onResolved = function (/*value*/) {
        if (--this.missing === 0) {
            assert(this.state !== STATE_RESOLVED);

            if (this.state === STATE_LISTEN) {
                if (this.first instanceof Future) {
                    assert(this.first.state === STATE_RESOLVED);

                    this.resolve(this.first.value);
                } else {
                    this.resolve(this.first);
                }
            }
        }
    };

    FutureJoin.prototype.onRejected = function (error) {
        if (this.state === STATE_LISTEN) {
            this.reject(error);
        }
    };

    function join(first, second) {
        if (first instanceof Future && first.state === STATE_REJECTED) {
            return first;
        } else if (second instanceof Future) {
            if (second.state === STATE_RESOLVED) {
                return first;
            } else if (second.state === STATE_REJECTED) {
                return second;
            }
        } else {
            return first;
        }

        if (!(first instanceof FutureJoin)) {
            first = new FutureJoin(first);
        }

        first.missing += 1;
        second.register(first);

        return first;
    }

    // ------- TASYNC -------

    var TASYNC = {
        setTrace: setTrace,
        delay: delay,
        lift: lift,
        apply: apply,
        call: call,
        trycatch: trycatch,
        wrap: wrap,
        unwrap: unwrap,
        throttle: throttle,
        join: join
    };

    if (typeof define === 'function' && define.amd) {
        define('common/core/tasync',[], function () {
            return TASYNC;
        });
    } else {
        module.exports = TASYNC;
    }
}());

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/corerel',[
    'common/util/assert',
    'common/core/tasync',
    'common/util/random',
    'common/core/constants',
], function (ASSERT, TASYNC, RANDOM, CONSTANTS) {

    'use strict';

    function InverseOverlaysCache(maxSize, logger) {
        var self = this;

        maxSize = maxSize || 10000;
        this._backup = {};
        this._cache = {};
        this._size = 0;

        this.getItem = function (key) {
            if (self._cache[key]) {
                return self._cache[key];
            }

            if (self._backup[key]) {
                return self._backup[key];
            }

            return null;

        };

        this.setItem = function (key, data) {
            if (!self._cache[key]) {
                if (self._size === maxSize) {
                    self._size = 0;
                    self._backup = self._cache;
                    self._cache = {};
                }
                self._size += 1;
                self._cache[key] = data;

            } else {
                logger.warn('trying to add inverse relation object multiple times [#' + key + ']');
            }
        };

    }

    function CoreRel(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof innerCore === 'object');

        var logger = innerCore.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        this._inverseCache = new InverseOverlaysCache(options.globConf.core.inverseRelationsCacheSize,
            logger.fork('inverseCache'));

        logger.debug('initialized CoreRel');

        //<editor-fold=Helper Functions>
        function test(text, cond) {
            if (!cond) {
                throw new Error(text);
            }
        }

        function isObject(node) {
            node = innerCore.normalize(node);
            return typeof node.data === 'object' && node.data !== null;
        }

        function isValidNodeThrow(node) {
            test('coretree', innerCore.isValidNode(node));
            test('isobject', isObject(node));
        }

        function getRelativePointerPathFrom(node, source, name) {
            ASSERT(self.isValidNode(node) && typeof source === 'string' && typeof name === 'string');
            var target,
                ovrData;

            do {
                ovrData = (innerCore.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {})[source];
                if (ovrData) {
                    target = ovrData[name];
                    if (target !== undefined) {
                        break;
                    }
                }

                source = '/' + innerCore.getRelid(node) + source;
                node = innerCore.getParent(node);

            } while (node);

            return {
                target: target,
                node: node
            };
        }

        function storeNewInverseOverlays(node) {
            var hash = self.getHash(node),
                relid;

            if (hash && node.inverseOverlays) {
                self._inverseCache.setItem(hash, node.inverseOverlays);
                for (relid in node.children) {
                    storeNewInverseOverlays(node.children[relid]);
                }
            }
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.isValidNode = function (node) {
            try {
                isValidNodeThrow(node);

                return true;
            } catch (error) {
                logger.error(error.message, {metadata: {stack: error.stack, node: node}});
                return false;
            }
        };

        this.persist = function (node) {
            var persisted = innerCore.persist(node);

            storeNewInverseOverlays(self.getRoot(node));

            return persisted;
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getInverseOverlayOfNode = function (node) {
            var hash,
                inverseOverlays = {},
                overlay,
                source,
                name,
                target;

            // If the node already has inverse computed we return that
            if (node.inverseOverlays) {
                return node.inverseOverlays;
            }

            // If we find it in the cache we set that and use it
            hash = self.getHash(node);
            if (hash) {
                inverseOverlays = self._inverseCache.getItem(hash);
                if (inverseOverlays) {
                    node.inverseOverlays = inverseOverlays;
                    return node.inverseOverlays;
                }
            }

            // Otherwise we have to compute it
            overlay = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY);
            overlay = overlay || {};
            inverseOverlays = {};
            for (source in overlay) {
                for (name in overlay[source]) {
                    target = overlay[source][name];
                    inverseOverlays[target] = inverseOverlays[target] || {};
                    inverseOverlays[target][name] = inverseOverlays[target][name] || [];
                    inverseOverlays[target][name].push(source);
                }
            }

            // If it is an unmodified node, we can store the inverse, otherwise it still can change
            if (hash) {
                self._inverseCache.setItem(hash, inverseOverlays);
            }

            node.inverseOverlays = inverseOverlays;

            return node.inverseOverlays;

        };

        this.isPointerName = function (name) {
            ASSERT(typeof name === 'string');
            //TODO this is needed as now we work with modified data as well
            if (name === CONSTANTS.MUTABLE_PROPERTY) {
                return false;
            }
            // return name.slice(-CONSTANTS.COLLECTION_NAME_SUFFIX.length) !==
            //     CONSTANTS.COLLECTION_NAME_SUFFIX;

            return true;
        };

        this.getAttributeNames = function (node) {
            ASSERT(self.isValidNode(node));

            var data,
                keys,
                i,
                result = [],
                key;

            data = (innerCore.getProperty(node, CONSTANTS.ATTRIBUTES_PROPERTY) || {});
            keys = Object.keys(data);
            i = keys.length;
            while (--i >= 0) {
                key = keys[i];
                if (key.charAt(0) === '') {
                    logger.error('empty named attribute found in node [' + innerCore.getPath(node) + ']');
                    //keys.splice(i, 1);
                } else if (key.charAt(0) === '_') {
                    //keys.splice(i, 1);
                } else {
                    result.push(key);
                }
            }

            return result;
        };

        this.getRegistryNames = function (node) {
            ASSERT(self.isValidNode(node));

            var data,
                keys,
                i,
                result = [],
                key;

            data = (innerCore.getProperty(node, CONSTANTS.REGISTRY_PROPERTY) || {});
            keys = Object.keys(data);
            i = keys.length;
            while (--i >= 0) {
                key = keys[i];
                if (keys[i].charAt(0) === '') {
                    logger.error('empty named attribute found in node [' + innerCore.getPath(node) + ']');
                    //keys.splice(i, 1);
                } else if (keys[i].charAt(0) === '_') {
                    //keys.splice(i, 1);
                } else {
                    result.push(key);
                }
            }

            return result;
        };

        this.getAttribute = function (node, name) {
            /*node = coretree.getChild(node, coretree.constants.ATTRIBUTES_PROPERTY);
             return coretree.getProperty(node, name);*/
            return (innerCore.getProperty(node, CONSTANTS.ATTRIBUTES_PROPERTY) || {})[name];
        };

        this.delAttribute = function (node, name) {
            node = innerCore.getChild(node, CONSTANTS.ATTRIBUTES_PROPERTY);
            innerCore.deleteProperty(node, name);
        };

        this.setAttribute = function (node, name, value) {
            node = innerCore.getChild(node, CONSTANTS.ATTRIBUTES_PROPERTY);
            innerCore.setProperty(node, name, value);
        };

        this.getRegistry = function (node, name) {
            /*node = coretree.getChild(node, coretree.constants.REGISTRY_PROPERTY);
             return coretree.getProperty(node, name);*/
            return (innerCore.getProperty(node, CONSTANTS.REGISTRY_PROPERTY) || {})[name];
        };

        this.delRegistry = function (node, name) {
            node = innerCore.getChild(node, CONSTANTS.REGISTRY_PROPERTY);
            innerCore.deleteProperty(node, name);
        };

        this.setRegistry = function (node, name, value) {
            node = innerCore.getChild(node, CONSTANTS.REGISTRY_PROPERTY);
            innerCore.setProperty(node, name, value);
        };

        this.overlayRemove = function (node, source, name, target) {
            ASSERT(self.isValidNode(node));
            ASSERT(innerCore.isValidPath(source) && innerCore.isValidPath(target) && self.isPointerName(name));
            ASSERT(innerCore.getCommonPathPrefixData(source, target).common === '');

            var overlays = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY),
                inverseOverlays = node.inverseOverlays, // we only handle it if it is already computed
                overlayNode,
                index;

            overlayNode = innerCore.getChild(overlays, source);
            ASSERT(overlayNode && innerCore.getProperty(overlayNode, name) === target);
            innerCore.deleteProperty(overlayNode, name);

            if (innerCore.getKeys(overlayNode).length === 0) {
                innerCore.deleteProperty(overlays, source);
            }

            //Now we check if some mutation happened
            if (inverseOverlays && !node.inverseOverlays) {
                inverseOverlays = JSON.parse(JSON.stringify(inverseOverlays));
                node.inverseOverlays = inverseOverlays;
            }
            if (inverseOverlays && inverseOverlays[target] && inverseOverlays[target][name]) {
                index = inverseOverlays[target][name].indexOf(source);
                if (index !== -1) {
                    inverseOverlays[target][name].splice(index, 1);
                    if (inverseOverlays[target][name].length === 0) {
                        delete inverseOverlays[target][name];
                        if (Object.keys(inverseOverlays[target]).length === 0) {
                            delete inverseOverlays[target];
                        }
                    }
                }
            }

        }

        this.overlayQuery = function (node, prefix) {
            ASSERT(self.isValidNode(node) && innerCore.isValidPath(prefix));

            var overlays = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {},
                inverseOverlays = self.getInverseOverlayOfNode(node), // We necessarily have to compute at this point,
                i, path, name, list = [],
                prefix2 = prefix + CONSTANTS.PATH_SEP;

            for (path in overlays) {
                if (path === prefix || path.substr(0, prefix2.length) === prefix2) {
                    for (name in overlays[path]) {
                        if (self.isPointerName(name)) {
                            list.push({
                                s: path,
                                n: name,
                                t: overlays[path][name],
                                p: true
                            });
                        }
                    }
                }
            }

            for (path in inverseOverlays) {
                if (path === prefix || path.substr(0, prefix2.length) === prefix2) {
                    for (name in inverseOverlays[path]) {
                        for (i = 0; i < inverseOverlays[path][name].length; i += 1) {
                            list.push({
                                s: inverseOverlays[path][name][i],
                                n: name,
                                t: path,
                                p: false
                            });
                        }
                    }
                }
            }

            return list;
        }

        this.overlayInsert = function (node, source, name, target) {
            ASSERT(self.isValidNode(node));
            ASSERT(innerCore.isValidPath(source) && innerCore.isValidPath(target) && self.isPointerName(name));
            ASSERT(innerCore.getCommonPathPrefixData(source, target).common === '');

            var overlays = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY),
                inverseOverlays = node.inverseOverlays, // We update it only if it exists
                overlay = self.getChild(overlays, source);

            // Make sure it is an insert
            ASSERT(self.getProperty(overlay, name) === undefined);
            self.setProperty(overlay, name, target);

            // First check if mutation took place.
            if (inverseOverlays && !node.inverseOverlays) {
                inverseOverlays = JSON.parse(JSON.stringify(inverseOverlays));
                node.inverseOverlays = inverseOverlays;
            }

            if (inverseOverlays) {
                inverseOverlays[target] = inverseOverlays[target] || {};
                inverseOverlays[target][name] = inverseOverlays[target][name] || [];
                inverseOverlays[target][name].push(source);
            }
        };

        this.createNode = function (parameters, takenRelids, relidLength) {
            parameters = parameters || {};
            var relid = parameters.relid,
                parent = parameters.parent;

            ASSERT(!parent || self.isValidNode(parent));
            // ASSERT(!relid || typeof relid === 'string');

            var node;
            if (parent) {
                if (relid) {
                    if ((takenRelids && takenRelids[relid]) || self.getChildrenRelids(parent).indexOf(relid) > -1) {
                        throw new Error('Given relid already used in parent "' + relid + '".');
                    } else {
                        node = innerCore.getChild(parent, relid);
                        parent.childrenRelids = null;
                    }
                } else {
                    node = self.createChild(parent, takenRelids, relidLength);
                }

                innerCore.setHashed(node, true);
            } else {
                node = innerCore.createRoot();
            }

            // As we just created the node, we can allocate an empty inverse object, that is appropriate this time
            node.inverseOverlays = {};
            return node;
        };

        this.deleteNode = function (node) {
            ASSERT(self.isValidNode(node));

            var parent = innerCore.getParent(node);

            ASSERT(parent !== null);
            self.deleteChild(parent, innerCore.getRelid(node));
        };

        /**
         *
         * @param {Node} node - Node containing the child.
         * @param {string} relid - Relid of the child to be removed.
         */
        this.deleteChild = function (parent, relid) {
            var prefix = '/' + relid;
            innerCore.deleteProperty(parent, relid);
            if (parent.childrenRelids) {
                parent.childrenRelids = null;
            }

            while (parent) {

                var list = self.overlayQuery(parent, prefix);
                for (var i = 0; i < list.length; ++i) {
                    var entry = list[i];
                    self.overlayRemove(parent, entry.s, entry.n, entry.t);
                }

                prefix = CONSTANTS.PATH_SEP + innerCore.getRelid(parent) + prefix;
                parent = innerCore.getParent(parent);
            }
        };

        this.createChild = function (parent, takenRelids, relidLength) {
            var child = innerCore.createChild(parent, takenRelids, relidLength);

            parent.childrenRelids = null;

            return child;
        };

        this.copyNode = function (node, parent, takenRelids, relidLength) {
            ASSERT(self.isValidNode(node));
            ASSERT(!parent || self.isValidNode(parent));
            var newNode,
                ancestor,
                ancestorNewPath,
                nodeToChangeOverlay,
                base,
                baseOldPath,
                aboveAncestor,
                list,
                tempAncestor,
                i,
                entry,
                relativePath,
                source,
                target,
                inverseOverlays;

            node = innerCore.normalize(node);
            inverseOverlays = node.inverseOverlays;

            if (parent) {
                ancestor = innerCore.getAncestor(node, parent);

                // cannot copy inside of itself
                if (ancestor === node) {
                    return null;
                }

                newNode = self.createChild(parent, takenRelids, relidLength);
                innerCore.setHashed(newNode, true);
                innerCore.setData(newNode, innerCore.copyData(node));

                ancestorNewPath = innerCore.getPath(newNode, ancestor);

                base = innerCore.getParent(node);
                baseOldPath = '/' + innerCore.getRelid(node);
                aboveAncestor = 1;

                while (base) {
                    list = self.overlayQuery(base, baseOldPath);
                    tempAncestor = innerCore.getAncestor(base, ancestor);

                    aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);

                    relativePath = aboveAncestor < 0 ?
                        innerCore.getPath(base, ancestor) : innerCore.getPath(ancestor, base);

                    for (i = 0; i < list.length; ++i) {
                        entry = list[i];

                        if (entry.p) {
                            ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);
                            ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');

                            if (aboveAncestor < 0) {
                                //below ancestor node - further from root
                                source = ancestorNewPath + entry.s.substr(baseOldPath.length);
                                target = innerCore.joinPaths(relativePath, entry.t);
                                nodeToChangeOverlay = ancestor;
                            } else if (aboveAncestor === 0) {
                                //at ancestor node
                                var data = innerCore.getCommonPathPrefixData(ancestorNewPath, entry.t);

                                nodeToChangeOverlay = newNode;
                                while (data.firstLength-- > 0) {
                                    nodeToChangeOverlay = innerCore.getParent(nodeToChangeOverlay);
                                }
                                // overlays = innerCore.getChild(overlays, CONSTANTS.OVERLAYS_PROPERTY);

                                source = innerCore.joinPaths(data.first, entry.s.substr(baseOldPath.length));
                                target = data.second;
                            } else {
                                //above ancestor node - closer to root
                                ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);

                                source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);
                                target = entry.t;
                                nodeToChangeOverlay = base;
                            }

                            self.overlayInsert(nodeToChangeOverlay, source, entry.n, target);
                        }
                    }

                    baseOldPath = '/' + innerCore.getRelid(base) + baseOldPath;
                    base = innerCore.getParent(base);
                }
            } else {
                newNode = innerCore.createRoot();
                innerCore.setData(newNode, innerCore.copyData(node));
            }

            if (inverseOverlays) {
                newNode.inverseOverlays = JSON.parse(JSON.stringify(inverseOverlays));
            }
            return newNode;
        };

        this.copyNodes = function (nodes, parent, takenRelids, relidLength) {
            //copying multiple nodes at once for keeping their internal relations
            var paths = [],
                i, j, index, names, pointer, newNode,
                copiedNodes = [],
                // Every single element will be an object with the
                // internally pointing relations and the index of the target.
                internalRelationPaths = [];

            for (i = 0; i < nodes.length; i++) {
                paths.push(innerCore.getPath(nodes[i]));
            }

            for (i = 0; i < nodes.length; i++) {
                names = self.getPointerNames(nodes[i]);
                pointer = {};
                for (j = 0; j < names.length; j++) {
                    index = paths.indexOf(self.getPointerPath(nodes[i], names[j]));
                    if (index !== -1) {
                        pointer[names[j]] = index;
                    }
                }
                internalRelationPaths.push(pointer);
            }

            //now we use our simple copy
            for (i = 0; i < nodes.length; i++) {
                newNode = self.copyNode(nodes[i], parent, takenRelids, relidLength);
                copiedNodes.push(newNode);
                if (takenRelids) {
                    takenRelids[self.getRelid(newNode)] = true;
                }
            }

            //and now back to the relations
            for (i = 0; i < internalRelationPaths.length; i++) {
                names = Object.keys(internalRelationPaths[i]);
                for (j = 0; j < names.length; j++) {
                    self.setPointer(copiedNodes[i], names[j], copiedNodes[internalRelationPaths[i][names[j]]]);
                }
            }

            return copiedNodes;
        };

        this.moveNode = function (node, parent, takenRelids, relidLength) {
            ASSERT(self.isValidNode(node) && self.isValidNode(parent));

            var ancestor,
                base,
                baseOldPath,
                aboveAncestor,
                ancestorNewPath,
                list,
                tempAncestor,
                relativePath,
                i,
                source,
                target,
                nodeToModifyOverlays,
                entry,
                tmp;

            node = innerCore.normalize(node);
            ancestor = innerCore.getAncestor(node, parent);

            // cannot move inside of itself
            if (ancestor === node) {
                return null;
            }

            base = innerCore.getParent(node);
            baseOldPath = '/' + innerCore.getRelid(node);
            aboveAncestor = 1;

            var oldNode = node;
            if (takenRelids) {
                if (takenRelids[innerCore.getRelid(oldNode)]) {
                    node = innerCore.createChild(parent, takenRelids, relidLength);
                } else {
                    node = innerCore.getChild(parent, innerCore.getRelid(oldNode));
                }
            } else {
                node = innerCore.getChild(parent, innerCore.getRelid(oldNode));
                if (!innerCore.isEmpty(node)) {
                    // we have to change the relid of the node, to fit into its new
                    // place...
                    node = innerCore.createChild(parent);
                }
            }

            parent.childrenRelids = null;

            innerCore.setHashed(node, true);
            innerCore.setData(node, innerCore.copyData(oldNode));

            ancestorNewPath = innerCore.getPath(node, ancestor);

            while (base) {
                list = self.overlayQuery(base, baseOldPath);
                tempAncestor = innerCore.getAncestor(base, ancestor);

                aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);

                relativePath = aboveAncestor < 0 ?
                    innerCore.getPath(base, ancestor) : innerCore.getPath(ancestor, base);

                for (i = 0; i < list.length; ++i) {
                    entry = list[i];

                    self.overlayRemove(base, entry.s, entry.n, entry.t);

                    if (!entry.p) {
                        tmp = entry.s;
                        entry.s = entry.t;
                        entry.t = tmp;
                    }

                    ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);
                    ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');

                    if (aboveAncestor < 0) {
                        //below ancestor node
                        source = ancestorNewPath + entry.s.substr(baseOldPath.length);
                        target = innerCore.joinPaths(relativePath, entry.t);
                        nodeToModifyOverlays = ancestor;
                    } else if (aboveAncestor === 0) {
                        //at ancestor node
                        var data = innerCore.getCommonPathPrefixData(ancestorNewPath, entry.t);

                        nodeToModifyOverlays = node;
                        while (data.firstLength-- > 0) {
                            nodeToModifyOverlays = innerCore.getParent(nodeToModifyOverlays);
                        }
                        // overlays = innerCore.getChild(overlays, CONSTANTS.OVERLAYS_PROPERTY);

                        source = innerCore.joinPaths(data.first, entry.s.substr(baseOldPath.length));
                        target = data.second;
                    } else {
                        //above ancestor node
                        ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);

                        source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);
                        target = entry.t;
                        nodeToModifyOverlays = base;
                    }

                    if (!entry.p) {
                        tmp = entry.s;
                        entry.s = entry.t;
                        entry.t = tmp;

                        tmp = source;
                        source = target;
                        target = tmp;
                    }

                    //console.log(source, target);
                    self.overlayInsert(nodeToModifyOverlays, source, entry.n, target);
                }

                baseOldPath = '/' + innerCore.getRelid(base) + baseOldPath;
                base = innerCore.getParent(base);
            }

            self.deleteNode(oldNode);

            return node;
        };

        this.getChildrenRelids = function (node) {
            ASSERT(self.isValidNode(node));

            // Check if they are already cached by the node
            if (!node.childrenRelids) {
                node.childrenRelids = innerCore.getKeys(node, self.isValidRelid);
            }

            return node.childrenRelids;
        };

        this.getChildrenPaths = function (node) {
            var path = innerCore.getPath(node),
                relids = self.getChildrenRelids(node),
                result = [],
                i;

            for (i = 0; i < relids.length; i += 1) {
                result.push(path + '/' + relids[i]);
            }

            return result;
        };

        this.loadChildren = function (node) {
            var children = self.getChildrenRelids(node),
                result = [],
                i;

            for (i = 0; i < children.length; i += 1) {
                result.push(innerCore.loadChild(node, children[i]));
            }

            return TASYNC.lift(result);
        };

        this.getPointerNames = function (node) {
            return self.getPointerNamesFrom(node, '');
        };

        this.getPointerNamesFrom = function (node, source) {
            ASSERT(self.isValidNode(node));

            var names = [];

            do {
                var child = (innerCore.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {})[source];
                if (child) {
                    for (var name in child) {
                        ASSERT(names.indexOf(name) === -1);
                        if (self.isPointerName(name)) {
                            names.push(name);
                        }
                    }
                }

                source = '/' + innerCore.getRelid(node) + source;
                node = innerCore.getParent(node);
            } while (node);

            return names;
        };

        this.getPointerPath = function (node, name) {
            return self.getPointerPathFrom(node, '', name);
        };

        this.getPointerPathFrom = function (node, source, name) {
            var res = getRelativePointerPathFrom(node, source, name),
                target;

            if (res.target !== undefined) {
                target = innerCore.joinPaths(innerCore.getPath(res.node), res.target);
            }

            return target;
        };

        this.loadPointer = function (node, name) {
            var res = getRelativePointerPathFrom(node, '', name);

            if (res.target !== undefined) {
                return innerCore.loadByPath(res.node, res.target);
            } else {
                return null;
            }
        };

        this.getCollectionNames = function (node) {
            ASSERT(self.isValidNode(node));
            var names = [],
                target = '',
                name,
                inverseOverlays;

            do {
                inverseOverlays = self.getInverseOverlayOfNode(node);
                if (inverseOverlays[target]) {
                    for (name in inverseOverlays[target]) {
                        if (names.indexOf(name) === -1) {
                            names.push(name);
                        }
                    }
                }

                target = CONSTANTS.PATH_SEP + self.getRelid(node) + target;
                node = self.getParent(node);
            } while (node);

            return names;
        };

        this.loadCollection = function (node, name) {
            ASSERT(self.isValidNode(node) && self.isPointerName(name));

            var collection = [],
                target = '',
                i,
                inverseOverlays;

            do {
                inverseOverlays = self.getInverseOverlayOfNode(node);

                if (inverseOverlays[target] && inverseOverlays[target][name]) {
                    for (i = 0; i < inverseOverlays[target][name].length; i += 1) {
                        collection.push(self.loadByPath(node, inverseOverlays[target][name][i]));
                    }
                }

                target = CONSTANTS.PATH_SEP + self.getRelid(node) + target;
                node = self.getParent(node);
            } while (node);

            return TASYNC.lift(collection);
        };

        this.getCollectionPaths = function (node, name) {
            ASSERT(self.isValidNode(node) && self.isPointerName(name));

            var result = [],
                target = '',
                inverseOverlays,
                i,
                prefix = '';

            do {
                inverseOverlays = self.getInverseOverlayOfNode(node);
                if (inverseOverlays[target] && inverseOverlays[target][name]) {
                    prefix = self.getPath(node);
                    for (i = 0; i < inverseOverlays[target][name].length; i += 1) {
                        result.push(prefix + inverseOverlays[target][name][i]);
                    }
                }

                target = CONSTANTS.PATH_SEP + self.getRelid(node) + target;
                node = self.getParent(node);
            } while (node);

            return result;
        };

        this.deletePointer = function (node, name) {
            ASSERT(self.isValidNode(node) && typeof name === 'string');

            var source = '',
                overlays;

            do {
                overlays = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY);
                if (overlays && overlays[source] && overlays[source][name]) {
                    self.overlayRemove(node, source, name, overlays[source][name]);
                }

                source = CONSTANTS.PATH_SEP + self.getRelid(node) + source;
                node = self.getParent(node);
            } while (node);

            return false;
        };

        this.setPointer = function (node, name, target) {
            ASSERT(self.isValidNode(node) && typeof name === 'string' && (!target || self.isValidNode(target)));

            var ancestor,
                targetPath,
                sourcePath;

            self.deletePointer(node, name);

            if (target) {
                ancestor = innerCore.getAncestor(node, target);

                sourcePath = innerCore.getPath(node, ancestor);
                targetPath = innerCore.getPath(target, ancestor);

                self.overlayInsert(ancestor, sourcePath, name, targetPath);
            }
        };

        this.getChildrenHashes = function (node) {
            var keys = self.getChildrenRelids(node),
                i, hashes = {};

            for (i = 0; i < keys.length; i++) {
                hashes[keys[i]] = innerCore.getChildHash(node, keys[i]);
            }

            return hashes;
        };

        this.isValidRelid = RANDOM.isValidRelid;

        this.isContainerPath = function (path, parentPath) {
            var pathArray = (path || '').split('/'),
                parentArray = (parentPath || '').split('/'),
                i;

            for (i = 0; i < parentArray.length; i += 1) {
                if (parentArray[i] !== pathArray[i]) {
                    return false;
                }
            }

            return true;
        };
        //</editor-fold>
    }

    return CoreRel;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/setcore',['common/util/assert', 'common/core/constants'], function (ASSERT, CONSTANTS) {
    'use strict';

    function SetCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized SetCore');

        //<editor-fold=Helper Functions>
        function setModified(node) {
            innerCore.setRegistry(node, CONSTANTS.SET_MODIFIED_REGISTRY,
                (innerCore.getRegistry(node, CONSTANTS.SET_MODIFIED_REGISTRY) || 0) + 1);
        }

        function getSetNodeByName(node, setName) {
            return innerCore.getChild(innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY), setName);
        }

        function getSetInfoByName(node, setName) {
            ASSERT(typeof setName === 'string');
            var setsInfo = innerCore.getProperty(node, CONSTANTS.ALL_SETS_PROPERTY);

            return setsInfo && setsInfo[setName];
        }

        function getOwnMemberRelId(node, setName, memberPath) {
            var setInfo,
                keys,
                i;

            setInfo = getSetInfoByName(node, setName);
            if (setInfo) {
                keys = self.getRawKeys(setInfo, self.isValidRelid);
                for (i = 0; i < keys.length; i += 1) {
                    if (innerCore.getPointerPathFrom(node,
                            '/' + CONSTANTS.ALL_SETS_PROPERTY + '/' + setName + '/' + keys[i],
                            CONSTANTS.MEMBER_RELATION) === memberPath) {

                        return keys[i];
                    }
                }
            }

            return null;
        }

        function getMemberRelId(node, setName, memberPath) {
            var relid = null;

            do {
                relid = getOwnMemberRelId(node, setName, memberPath);
                if (relid) {
                    return relid;
                }

                node = self.getBase(node);
            } while (node);

            return relid;
        }

        function getSetMemberNode(node, setName, memberPath) {
            var memberRelId = getMemberRelId(node, setName, memberPath);

            return typeof memberRelId === 'string' && innerCore.getChild(getSetNodeByName(node, setName), memberRelId);
        }

        function getOwnSetMemberNode(node, setName, memberPath) {
            var memberRelId = getOwnMemberRelId(node, setName, memberPath);

            return typeof memberRelId === 'string' && innerCore.getChild(getSetNodeByName(node, setName), memberRelId);
        }

        function collectOwnSetNames(node) {
            var sets = [],
                setsInfo,
                keys,
                i;

            setsInfo = self.getProperty(node, CONSTANTS.ALL_SETS_PROPERTY);
            if (setsInfo &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY] &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY]['']) {

                keys = Object.keys(setsInfo[CONSTANTS.OVERLAYS_PROPERTY]['']);

                for (i = 0; i < keys.length; i += 1) {
                    if (keys[i] !== CONSTANTS.MUTABLE_PROPERTY && sets.indexOf(keys[i]) === -1) {
                        sets.push(keys[i]);
                    }
                }
            }

            return sets;
        }

        function collectSetNames(node) {
            var sets = [],
                keys,
                i;

            do {
                keys = collectOwnSetNames(node);

                for (i = 0; i < keys.length; i += 1) {
                    if (sets.indexOf(keys[i]) === -1) {
                        sets.push(keys[i]);
                    }
                }

                node = self.getBase(node);
            } while (node);

            return sets;
        }

        function hasOwnSet(node, setName) {
            ASSERT(typeof setName === 'string');
            var setsInfo = self.getProperty(node, CONSTANTS.ALL_SETS_PROPERTY);
            if (setsInfo &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY] &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY][''] &&
                setsInfo[CONSTANTS.OVERLAYS_PROPERTY][''][setName]) {

                return true;
            }

            return false;
        }

        function hasSet(node, setName) {
            do {
                if (hasOwnSet(node, setName)) {
                    return true;
                }

                node = self.getBase(node);
            } while (node);

            return false;
        }

        function collectInternalMemberRelids(node, setName) {
            var setInfo,
                relids = [],
                keys,
                i;

            do {
                setInfo = getSetInfoByName(node, setName);
                if (setInfo) {

                    keys = self.getRawKeys(setInfo, self.isValidRelid);

                    for (i = 0; i < keys.length; i += 1) {
                        if (relids.indexOf(keys[i]) === -1) {
                            relids.push(keys[i]);
                        }
                    }
                }

                node = self.getBase(node);
            } while (node);

            return relids;
        }

        function getContainerNodePath(node) {
            var ownPath = self.getPath(node);
            return ownPath.substring(0, ownPath.indexOf('/_'));
        }

        function collectMemberPath(node, setName, innerRelid) {
            var source = '/' + CONSTANTS.ALL_SETS_PROPERTY + '/' + setName + '/' + innerRelid,
                path,
                tempPath;

            do {
                tempPath = innerCore.getPointerPathFrom(node, source, CONSTANTS.MEMBER_RELATION);
                if (tempPath !== undefined) {
                    path = tempPath;
                    if (path !== getContainerNodePath(node)) {
                        break;
                    }
                }

                node = self.getBase(node);
            } while (node);

            return path;
        }

        function getPropertyCollectionInfo(node, propertyCollectionName, setName, memberPath) {
            var setInfo = getSetInfoByName(node, setName),
                propertyCollectionInfo,
                relid;

            if (setInfo) {
                if (typeof memberPath === 'string') {
                    relid = getMemberRelId(node, setName, memberPath);
                    propertyCollectionInfo = relid && setInfo[relid] && setInfo[relid][propertyCollectionName];
                } else {
                    propertyCollectionInfo = setInfo[propertyCollectionName];
                }
            }

            return propertyCollectionInfo;
        }

        function collectOwnPropertyNames(node, propertyCollectionName, setName, memberPath) {
            var propertyCollectionInfo = getPropertyCollectionInfo(node, propertyCollectionName, setName, memberPath);

            return propertyCollectionInfo ? innerCore.getRawKeys(propertyCollectionInfo) : [];
        }

        function collectPropertyNames(node, propertyCollectionName, setName, memberPath) {
            var names = [],
                keys,
                i;

            do {
                keys = collectOwnPropertyNames(node, propertyCollectionName, setName, memberPath);

                for (i = 0; i < keys.length; i += 1) {
                    if (names.indexOf(keys[i]) === -1) {
                        names.push(keys[i]);
                    }
                }

                node = self.getBase(node);
            } while (node);

            return names;
        }

        function getOwnPropertyValue(node,  propertyCollectionName, propertyName, setName, memberPath) {
            var propertyCollectionInfo = getPropertyCollectionInfo(node, propertyCollectionName, setName, memberPath);

            return propertyCollectionInfo ? propertyCollectionInfo[propertyName] : undefined;
        }

        function getPropertyValue(node,  propertyCollectionName, propertyName, setName, memberPath) {
            var value;

            do {
                value = getOwnPropertyValue(node,  propertyCollectionName, propertyName, setName, memberPath);
                if (value !== undefined) {
                    return value;
                }

                node = self.getBase(node);
            } while (node);

            return undefined;
        }

        function createSetOnDemand(node, setName) {
            //the function checks if there is no set defined on the node's level and create it
            var setsNode = innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY);
            if (innerCore.getOwnPointerPath(setsNode, setName) === undefined) {
                self.createSet(node, setName);
            }
        }
        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.getCollectionNames = function (node) {
            var result = innerCore.getCollectionNames(node),
                i;

            for (i = 0; i < result.length; i++) {
                // The member collection is coming from being a member of a set and is not a defined relationship.
                if (result[i] === CONSTANTS.MEMBER_RELATION) {
                    result.splice(i, 1);
                    break;
                }
            }

            return result;
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getSetNames = function (node) {
            return collectSetNames(node);
        };

        this.getOwnSetNames = function (node) {
            return collectOwnSetNames(node);
        };

        this.createSet = function (node, setName) {
            var setNode = getSetNodeByName(node, setName);
            innerCore.setPointer(innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY), setName, null);
            // Ensure the set-node is not deleted at persist.
            innerCore.setRegistry(setNode, '_', '_');
            setModified(node);
        };

        this.deleteSet = function (node, setName) {
            var setsNode = innerCore.getChild(node, CONSTANTS.ALL_SETS_PROPERTY),
                setNode = innerCore.getChild(setsNode, setName);

            innerCore.deletePointer(setsNode, setName);
            innerCore.deleteNode(setNode, true);
        };

        this.isMemberOf = function (node) {
            //TODO we should find a proper way to do this - or at least some support from lower layers would be fine
            var coll = self.getCollectionPaths(node, CONSTANTS.MEMBER_RELATION);
            var sets = {};
            for (var i = 0; i < coll.length; i++) {
                var pathArray = coll[i].split('/');
                if (pathArray.indexOf(CONSTANTS.META_NODE) === -1) {
                    //now we simply skip META sets...
                    var index = pathArray.indexOf(CONSTANTS.ALL_SETS_PROPERTY);
                    if (index > 0 && pathArray.length > index + 1) {
                        //otherwise it is not a real set
                        var ownerPath = pathArray.slice(0, index).join('/');
                        if (sets[ownerPath] === undefined) {
                            sets[ownerPath] = [];
                        }
                        sets[ownerPath].push(pathArray[index + 1]);
                    }
                }
            }
            return sets;
        };

        this.isFullyOverriddenMember = function (node, setName, memberPath) {
            var setNames = collectSetNames(node),
                ownRelId,
                baseRelId;

            if (setNames.indexOf(setName) === -1) {
                return false;
            }

            if (innerCore.getBase(node) === null) {
                return false;
            }

            ownRelId = getMemberRelId(node, setName, memberPath);
            baseRelId = getMemberRelId(innerCore.getBase(node), setName, memberPath);

            if (ownRelId && baseRelId && ownRelId !== baseRelId) {
                return true;
            }

            return false;
        };

        this.getMemberPaths = function (node, setName) {
            var memberRelids = collectInternalMemberRelids(node, setName),
                //pathPrefix = '/' + CONSTANTS.ALL_SETS_PROPERTY + '/' + setName + '/',
                i, path,
                memberPaths = [];
            for (i = 0; i < memberRelids.length; i += 1) {
                path = collectMemberPath(node, setName, memberRelids[i]);
                if (path !== undefined && memberPaths.indexOf(path) === -1) { //null and '' are valid targets
                    memberPaths.push(path);
                }
            }
            return memberPaths;
        };

        this.getOwnMemberPaths = function (node, setName) {
            var setInfo = getSetInfoByName(node, setName),
                relids = setInfo ? self.getRawKeys(setInfo, self.isValidRelid) : [],
                allPaths = self.getMemberPaths(node, setName),
                paths = [],
                i;

            for (i = 0; i < allPaths.length; i += 1) {
                if (relids.indexOf(getMemberRelId(node, setName, allPaths[i])) !== -1) {
                    paths.push(allPaths[i]);
                }
            }

            return paths;
        };

        this.delMember = function (node, setName, memberPath) {
            var setMemberNode;

            setMemberNode = getOwnSetMemberNode(node, setName, memberPath);
            if (setMemberNode) {
                innerCore.deleteNode(setMemberNode, true);
            }
        };

        this.addMember = function (node, setName, member) {
            var setNode = getSetNodeByName(node, setName),
                setMemberRelId = getMemberRelId(node, setName, self.getPath(member)),
                setMemberNode;

            if (setMemberRelId === null) {
                createSetOnDemand(node, setName);
                setMemberNode = innerCore.createChild(setNode, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1);
            } else if (!self.isFullyOverriddenMember(node, setName, self.getPath(member))) {
                //it was an inherited member, now we override it
                // TODO: We pin down the expected behavior here..
                setMemberNode = innerCore.copyNode(innerCore.getChild(setNode, setMemberRelId),
                    setNode, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1);
                innerCore.deleteNode(innerCore.getChild(setNode, setMemberRelId), true);
            }

            if (setMemberNode) {
                innerCore.setPointer(setMemberNode, CONSTANTS.MEMBER_RELATION, member);

                // Ensure the member-node entry is not deleted at persist.
                innerCore.setRegistry(setMemberNode, '_', '_');
                setModified(node);
            } else {
                logger.warn('member already in set');
            }
        };

        this.getMemberAttributeNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName, memberPath);
        };

        this.getMemberOwnAttributeNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectOwnPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName, memberPath);
        };

        this.getMemberAttribute = function (node, setName, memberPath, attrName) {
            ASSERT(typeof memberPath === 'string');
            return getPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName, memberPath);
        };

        this.getMemberOwnAttribute = function (node, setName, memberPath, attrName) {
            ASSERT(typeof memberPath === 'string');
            return getOwnPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName, memberPath);
        };

        this.setMemberAttribute = function (node, setName, memberPath, attrName, attrValue) {
            ASSERT(attrValue !== undefined);
            var setMemberNode = getSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.setAttribute(setMemberNode, attrName, attrValue);
                setModified(node);
            }
        };

        this.delMemberAttribute = function (node, setName, memberPath, attrName) {
            var setMemberNode = getOwnSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.delAttribute(setMemberNode, attrName);
            }
        };

        this.getMemberRegistryNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName, memberPath);
        };

        this.getMemberOwnRegistryNames = function (node, setName, memberPath) {
            ASSERT(typeof memberPath === 'string');
            return collectOwnPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName, memberPath);
        };

        this.getMemberRegistry = function (node, setName, memberPath, regName) {
            ASSERT(typeof memberPath === 'string');
            return getPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName, memberPath);
        };

        this.getMemberOwnRegistry = function (node, setName, memberPath, regName) {
            ASSERT(typeof memberPath === 'string');
            return getOwnPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName, memberPath);
        };

        this.setMemberRegistry = function (node, setName, memberPath, regName, regValue) {
            ASSERT(regValue !== undefined);
            var setMemberNode = getSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.setRegistry(setMemberNode, regName, regValue);
                setModified(node);
            }
        };

        this.delMemberRegistry = function (node, setName, memberPath, regName) {
            var setMemberNode = getOwnSetMemberNode(node, setName, memberPath);

            if (setMemberNode) {
                innerCore.delRegistry(setMemberNode, regName);
            }
        };

        this.getSetAttributeNames = function (node, setName) {
            return collectPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName);
        };

        this.getOwnSetAttributeNames = function (node, setName) {
            return collectOwnPropertyNames(node, CONSTANTS.ATTRIBUTES_PROPERTY, setName);
        };

        this.getSetAttribute = function (node, setName, attrName) {
            return getPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName);
        };

        this.getOwnSetAttribute = function (node, setName, attrName) {
            return getOwnPropertyValue(node, CONSTANTS.ATTRIBUTES_PROPERTY, attrName, setName);
        };

        this.setSetAttribute = function (node, setName, attrName, attrValue) {
            if (hasSet(node, setName)) {
                self.setAttribute(getSetNodeByName(node, setName), attrName, attrValue);
                setModified(node);
            }
        };

        this.delSetAttribute = function (node, setName, attrName) {
            var setInfo = getSetInfoByName(node, setName);
            if (setInfo) {
                self.delAttribute(getSetNodeByName(node, setName), attrName);
            }
        };

        this.getSetRegistryNames = function (node, setName) {
            return collectPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName);
        };

        this.getOwnSetRegistryNames = function (node, setName) {
            return collectOwnPropertyNames(node, CONSTANTS.REGISTRY_PROPERTY, setName);
        };

        this.getSetRegistry = function (node, setName, regName) {
            return getPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName);
        };

        this.getOwnSetRegistry = function (node, setName, regName) {
            return getOwnPropertyValue(node, CONSTANTS.REGISTRY_PROPERTY, regName, setName);
        };

        this.setSetRegistry = function (node, setName, regName, regValue) {
            if (hasSet(node, setName)) {
                self.setRegistry(getSetNodeByName(node, setName), regName, regValue);
                setModified(node);
            }
        };

        this.delSetRegistry = function (node, setName, regName) {
            var setInfo = getSetInfoByName(node, setName);
            if (setInfo) {
                self.delRegistry(getSetNodeByName(node, setName), regName);
            }
        };

        //</editor-fold>
    }

    return SetCore;
});



/*globals define*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/guidcore',[
    'common/util/assert',
    'common/core/tasync',
    'common/regexp',
    'common/util/random',
    'common/core/constants',
], function (ASSERT, TASYNC, REGEXP, RANDOM, CONSTANTS) {

    'use strict';

    var relidToInteger = RANDOM.relidToInteger,
        GUID = RANDOM.generateGuid;

    function GuidCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized GuidCore');

        //<editor-fold=Helper Functions>
        function toInternalGuid(myGuid) {
            return myGuid.replace(/-/g, '');
        }

        function toExternalGuid(myGuid) {
            return myGuid.substr(0, 8) + '-' + myGuid.substr(8, 4) + '-' +
                myGuid.substr(12, 4) + '-' + myGuid.substr(16, 4) + '-' + myGuid.substr(20);
        }

        function guidToArray(guid) {
            if (guid === null || guid === undefined) {
                return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            var array = new Array(8);
            for (var i = 0; i < guid.length / 4; i += 1) {
                array[i] = parseInt(guid.substr(4 * i, 4), 16);
            }
            return array;
        }

        function getRelidGuid(node) {
            //TODO we always should know what structure we should expect as a relid -
            // now we think it is a number so it can be converted to 0xsomething
            var relid = self.getRelid(node);
            //relid = Number(relid);
            relid = relidToInteger(relid);
            if (relid === 'NaN') {
                return null;
            }

            relid = relid.toString(16);

            //now we should fill up with 0's in the beggining
            while (relid.length < 32) {
                relid = relid + '0';
            }
            return relid;
        }

        function xorGuids(a, b) {
            var arrayA = guidToArray(a);
            var arrayB = guidToArray(b);

            ASSERT(arrayA.length === arrayB.length);

            var arrayOut = [];
            for (var i = 0; i < arrayA.length; i++) {
                /*jshint bitwise: false*/
                arrayOut.push(arrayA[i] ^ arrayB[i]);
            }
            for (i = 0; i < arrayOut.length; i++) {
                arrayOut[i] = Number(arrayOut[i]).toString(16);
                var difi = 4 - arrayOut[i].length;
                while (difi > 0) {
                    arrayOut[i] = '0' + arrayOut[i];
                    difi--;
                }
            }
            return arrayOut.join('');
        }

        function setDataGuid(node, guid) {
            self.setAttribute(node, CONSTANTS.OWN_GUID,
                xorGuids(
                    toInternalGuid(guid),
                    xorGuids(
                        getRelidGuid(node),
                        toInternalGuid(
                            self.getGuid(
                                self.getParent(node)
                            )
                        )
                    )
                )
            );
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.createNode = function (parameters) {
            parameters = parameters || {};

            var guid = parameters.guid || GUID(),
                node;

            ASSERT(REGEXP.GUID.test(guid));

            node = innerCore.createNode(parameters);

            setDataGuid(node, guid);

            return node;
        };

        this.moveNode = function (node, parent) {
            var oldGuid = self.getGuid(node);

            node = innerCore.moveNode(node, parent);

            setDataGuid(node, oldGuid);

            return node;
        };
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getGuid = function (node) {
            if (node) {
                return self.getDeducedGuid(node, self.getGuid(self.getParent(node)));
            } else {
                return CONSTANTS.NULL_GUID;
            }
        };

        this.setGuid = function (node, guid) {
            ASSERT(REGEXP.GUID.test(guid));
            return TASYNC.call(function (children) {
                var i,
                    childrenGuids = [];

                //save children guids
                for (i = 0; i < children.length; i += 1) {
                    childrenGuids.push(self.getGuid(children[i]));
                }

                //setting own dataGuid
                setDataGuid(node, guid);

                //changing children data guids
                for (i = 0; i < children.length; i += 1) {
                    setDataGuid(children[i], childrenGuids[i]);
                }
            }, self.loadChildren(node));
        };

        this.getDataGuid = function (node) {
            return toExternalGuid(self.getAttribute(node, CONSTANTS.OWN_GUID));
        };

        this.getDeducedGuid = function (node, baseGuid) {
            if (node && REGEXP.GUID.test(baseGuid)) {
                return toExternalGuid(
                    xorGuids(
                        getRelidGuid(node),
                        xorGuids(
                            self.getAttribute(node, CONSTANTS.OWN_GUID),
                            toInternalGuid(baseGuid)
                        )
                    )
                );
            } else {
                return CONSTANTS.NULL_GUID;
            }
        };
        //</editor-fold>
    }

    return GuidCore;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/nullpointercore',['common/util/assert', 'common/core/constants'], function (ASSERT, CONSTANTS) {
    'use strict';

    function NullPointerCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized NullPointerCore');

        //<editor-fold=Modified Methods>
        this.setPointer = function (node, name, target) {
            if (target === null) {
                var nullChild = innerCore.getChild(node, CONSTANTS.NULLPTR_RELID);
                innerCore.setAttribute(nullChild, 'name', CONSTANTS.NULLPTR_NAME);
                innerCore.setPointer(node, name, nullChild);
            } else {
                innerCore.setPointer(node, name, target);
            }
        };

        this.getPointerPath = function (node, name) {
            var path = innerCore.getPointerPath(node, name);
            if (path && path.indexOf(CONSTANTS.NULLPTR_RELID) !== -1) {
                return null;
            } else {
                return path;
            }
        };

        this.loadPointer = function (node, name) {
            var path = self.getPointerPath(node, name);
            if (path === null) {
                return null;
            } else {
                return innerCore.loadPointer(node, name);
            }
        };
        //</editor-fold>

        return self;
    }

    return NullPointerCore;
});



/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/coreunwrap',['common/util/assert', 'common/core/tasync'], function (ASSERT, TASYNC) {
    'use strict';

    // ----------------- CoreUnwrap -----------------

    var CoreUnwrap = function (innercore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');
        var logger = options.logger.fork('coreunwrap');

        function checkNode(node) {
            if (node === null || innercore.isValidNode(node)) {
                return node;
            } else {
                throw new Error('Invalid result node');
            }
        }

        function checkNodes(nodes) {
            ASSERT(nodes instanceof Array);

            var i;
            for (i = 0; i < nodes.length; ++i) {
                if (!innercore.isValidNode(nodes[i])) {
                    throw new Error('Invalid result node array');
                }
            }

            return nodes;
        }

        // copy all operations
        var core = {};
        for (var key in innercore) {
            core[key] = innercore[key];
        }
        logger.debug('initialized');
        core.loadRoot = TASYNC.unwrap(innercore.loadRoot);
        //core.persist = TASYNC.unwrap(oldcore.persist);

        // core.loadChild = TASYNC.unwrap(oldcore.loadChild);
        core.loadChild = TASYNC.unwrap(function (node, relid) {
            return TASYNC.call(checkNode, innercore.loadChild(node, relid));
        });

        // core.loadByPath = TASYNC.unwrap(oldcore.loadByPath);
        core.loadByPath = TASYNC.unwrap(function (node, path) {
            return TASYNC.call(checkNode, innercore.loadByPath(node, path));
        });

        // core.loadChildren = TASYNC.unwrap(oldcore.loadChildren);
        core.loadChildren = TASYNC.unwrap(function (node) {
            return TASYNC.call(checkNodes, innercore.loadChildren(node));
        });

        // core.loadOwnChildren = TASYNC.unwrap(oldcore.loadOwnChildren);
        core.loadOwnChildren = TASYNC.unwrap(function (node) {
            return TASYNC.call(checkNodes, innercore.loadOwnChildren(node));
        });

        core.loadPointer = TASYNC.unwrap(innercore.loadPointer);
        core.loadCollection = TASYNC.unwrap(innercore.loadCollection);

        core.loadSubTree = TASYNC.unwrap(innercore.loadSubTree);
        core.loadOwnSubTree = TASYNC.unwrap(innercore.loadOwnSubTree);
        core.loadTree = TASYNC.unwrap(innercore.loadTree);
        core.traverse = TASYNC.unwrap(innercore.traverse);

        core.setGuid = TASYNC.unwrap(innercore.setGuid);

        //core diff async functions
        if (typeof innercore.generateTreeDiff === 'function') {
            core.generateTreeDiff = TASYNC.unwrap(innercore.generateTreeDiff);
        }

        if (typeof innercore.generateLightTreeDiff === 'function') {
            core.generateLightTreeDiff = TASYNC.unwrap(innercore.generateLightTreeDiff);
        }

        if (typeof innercore.applyTreeDiff === 'function') {
            core.applyTreeDiff = TASYNC.unwrap(innercore.applyTreeDiff);
        }

        //library functions

        core.addLibrary = TASYNC.unwrap(innercore.addLibrary);
        core.updateLibrary = TASYNC.unwrap(innercore.updateLibrary);

        // core.loadInstances = TASYNC.unwrap(oldcore.loadInstances);
        core.loadInstances = TASYNC.unwrap(function (node) {
            return TASYNC.call(checkNodes, innercore.loadInstances(node));
        });


        return core;
    };

    return CoreUnwrap;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/coretype',[
    'common/util/assert',
    'common/core/tasync',
    'common/core/constants'
], function (ASSERT, TASYNC, CONSTANTS) {
    'use strict';

    var CoreType = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        // //isPointerName should be removed from API at this level
        // delete self.isPointerName;

        logger.debug('initialized CoreType');

        //<editor-fold=Helper Functions>
        function test(text, cond) {
            if (!cond) {
                throw new Error(text);
            }
        }

        function isFalseNode(node) {
            //TODO this hack should be removed, but now it seems just fine :)
            return innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER) === undefined;
        }

        function loadRoot2(node) {
            ASSERT(node.base === undefined || node.base === null);
            //kecso - TODO it should be undefined, but maybe because of the cache it can be null

            node.base = null;
            return node;
        }

        function loadChild(node, relid) {
            var child = null,
                base = self.getBase(node),
                basechild = null;
            if (base) {
                //the parent is inherited
                if (self.getChildrenRelids(base, true)[relid]) {
                    //inherited child
                    if (innerCore.getChildrenRelids(node).indexOf(relid) !== -1) {
                        //but it is overwritten so we should load it
                        child = innerCore.loadChild(node, relid);
                    }
                    basechild = self.loadChild(base, relid);
                    return TASYNC.call(function (b, c, n, r) {
                        if (c) {
                            child = c;
                            child.base = b;
                            return child;
                        } else {
                            child = innerCore.getChild(n, r);
                            self.setHashed(child, true, true);
                            child.base = b;

                            return child;
                        }
                    }, basechild, child, node, relid);
                }
            }
            //normal child - as every node should have a base, it is normally mean a direct child of the ROOT
            if (self.getChildrenRelids(node, true)[relid] !== true) {
                return null;
            }

            return TASYNC.call(loadBase, innerCore.loadChild(node, relid));
        }

        function loadBase(node) {
            var path = innerCore.getPath(node);
            ASSERT(node === null || node.base === undefined || typeof node.base === 'object');

            if (node.base === undefined) {
                if (self.isEmpty(node)) {
                    //empty nodes do not have a base
                    node.base = null;
                    return node;
                } else if (isFalseNode(node)) {
                    innerCore.deleteNode(node);
                    //core.persist(core.getRoot(node));
                    //TODO a notification should be generated towards the user
                    logger.warn('node [' + path + '] removed due to missing base');

                    //TODO check if some identification can be passed
                    return null;
                } else {
                    var basePath = innerCore.getPointerPath(node, CONSTANTS.BASE_POINTER);
                    ASSERT(basePath !== undefined);
                    if (basePath === null) {
                        node.base = null;
                        return node;
                    } else if (self.isContainerPath(basePath, path)) {
                        //contained base error
                        logger.error('node [' + path + '] contains its own base!');
                        innerCore.deleteNode(node);
                        //core.persist(core.getRoot(node));
                        return null;
                    } else {
                        return TASYNC.call(loadBase2, node, self.loadByPath(self.getRoot(node), basePath));
                    }
                }
            } else {
                //TODO can the base change at this point???
                return node;
            }
        }

        function loadBase2(node, target) {
            if (typeof node.base !== null && typeof node.base === 'object' &&
                (innerCore.getPath(node.base) === innerCore.getPath(target))) {
                //TODO somehow the object already loaded properly and we do no know about it!!!
                return node;
            } else {
                ASSERT(node.base === undefined || node.base === null); //kecso

                if (target === null) {
                    // At this point the base node should be a valid node
                    logger.warn('node [' + innerCore.getPath(node) +
                        '] removed due to missing base in inheritance chain');
                    innerCore.deleteNode(node);
                    //core.persist(core.getRoot(node));
                    return null;
                }

                node.base = target;

                return node;
            }
        }

        function loadDescendantByPath(node, pathArray, index) {
            if (node === null || index === pathArray.length) {
                return node;
            }

            var child = self.loadChild(node, pathArray[index]);
            return TASYNC.call(loadDescendantByPath, child, pathArray, index + 1);
        }

        function isInheritedChild(node) {
            var parent = self.getParent(node),
                base = self.getBase(node),
                parentBase = parent ? self.getBase(parent) : null,
                baseParent = base ? self.getParent(base) : null;

            if (baseParent && parentBase && self.getPath(baseParent) === self.getPath(parentBase)) {
                return true;
            }
            return false;
        }

        function getInstanceRoot(node) {

            while (isInheritedChild(node)) {
                node = self.getParent(node);
            }

            return node;
        }

        /**
         * This function collects the inherited collection names.
         * Although there is no collection inheritance, we know that if a model is instantiated its internal structure
         * is not duplicated or no new data will be created. This means that in a sense, to keep the prototypical
         * inheritance correct, we need to build the internal relations on the fly. This means that whenever the user
         * has a question about the inverse relations of an internal part of the instance, we have to check the
         * prototype for such 'internal' relations and provide them - like in case of inherited attributes.
         * The function goes up on the inheritance chain of the questioned node.
         * At every step, it searches the root of instantiation (the node that is the instance) and collect inverse
         * relation names that exist in the prototype structure and has purely internal endpoints.
         *
         * @param node - the node in question
         * @returns {Array} - the list of names of relations that has the node as target
         */
        function getInheritedCollectionNames(node) {
            var names = [],
                startNode = node,
                actualNode = node,
                endNode,
                inverseOverlays,
                name,
                target;

            while (startNode) {
                actualNode = self.getBase(startNode);
                endNode = self.getBase(getInstanceRoot(startNode));
                target = '';
                if (actualNode && endNode) {
                    while (actualNode && actualNode !== self.getParent(endNode)) {
                        inverseOverlays = innerCore.getInverseOverlayOfNode(actualNode);
                        if (inverseOverlays[target]) {
                            for (name in inverseOverlays[target]) {
                                if (names.indexOf(name) === -1) {
                                    names.push(name);
                                }
                            }
                        }
                        target = CONSTANTS.PATH_SEP + self.getRelid(actualNode) + target;
                        actualNode = self.getParent(actualNode);
                    }
                }
                startNode = self.getBase(startNode);
            }

            return names;
        }

        /**
         * This function gathers the paths of the nodes that are pointing to the questioned node. The set of relations
         * that are checked is the 'inherited' inverse relations.
         *
         * The method of this function is identical to getInheritedCollectionNames, except this function collects the
         * sources of the given relations and not just the name of all such relation. To return a correct path (as
         * the data exists in some bases of the actual nodes) the function always convert it back to the place of
         * inquiry.
         * @param node - the node in question
         * @param name - name of the relation that we are interested in
         * @returns {Array} - list of paths of sources of inherited relations by the given name
         */
        function getInheritedCollectionPaths(node, name) {
            var paths = [],
                startNode = node,
                actualNode = node,
                endNode,
                prefixNode,
                i,
                inverseOverlays,
                target;

            while (startNode) {
                actualNode = self.getBase(startNode);
                endNode = self.getBase(getInstanceRoot(startNode));
                target = '';
                if (actualNode && endNode) {
                    prefixNode = node;
                    while (actualNode && actualNode !== self.getParent(endNode)) {
                        inverseOverlays = innerCore.getInverseOverlayOfNode(actualNode);
                        if (inverseOverlays[target] && inverseOverlays[target][name]) {
                            for (i = 0; i < inverseOverlays[target][name].length; i += 1) {
                                paths.push(self.joinPaths(self.getPath(prefixNode), inverseOverlays[target][name][i]));
                            }
                        }
                        target = CONSTANTS.PATH_SEP + self.getRelid(actualNode) + target;
                        actualNode = self.getParent(actualNode);
                        prefixNode = self.getParent(prefixNode);
                    }
                }
                startNode = self.getBase(startNode);
            }

            return paths;
        }

        function inheritedPointerNames(node) {
            var allNames = self.getPointerNames(node),
                ownNames = self.getOwnPointerNames(node),
                names = [],
                i;

            for (i = 0; i < allNames.length; i++) {
                if (ownNames.indexOf(allNames[i]) === -1) {
                    names.push(allNames[i]);
                }
            }

            return names;
        }

        function isValidNodeThrow(node) {
            test('core', innerCore.isValidNode(node));
            test('base', typeof node.base === 'object');
        }

        function getProperty(node, name) {
            var property;
            while (property === undefined && node !== null) {
                property = innerCore.getProperty(node, name);
                node = self.getBase(node);
            }
            return property;
        }

        function getSimpleBasePath(node, source, name) {
            var path = innerCore.getPointerPathFrom(node, source, name);
            if (path === undefined) {
                if (node.base !== null && node.base !== undefined) {
                    return getSimpleBasePath(node.base, source, name);
                } else {
                    return undefined;
                }
            } else {
                return path;
            }
        }

        function getParentOfBasePath(node) {
            var parent;
            if (node.base) {
                parent = self.getParent(node.base);
                if (parent) {
                    return self.getPath(parent);
                } else {
                    return undefined;
                }
            } else {
                return undefined;
            }
        }

        function getBaseOfParentPath(node) {
            var parent = self.getParent(node);
            if (parent) {
                if (parent.base) {
                    return self.getPath(parent.base);
                } else {
                    return undefined;
                }
            } else {
                return undefined;
            }
        }

        function getTargetRelPath(node, relSource, name) {
            var ovr = self.getChild(node, CONSTANTS.OVERLAYS_PROPERTY),
                source = self.getChild(ovr, relSource);
            return getProperty(source, name);
        }

        // function checkCollNames(node, draft) {
        //     var filtered = [],
        //         i, sources;
        //     for (i = 0; i < draft.length; i++) {
        //         sources = self.getCollectionPaths(node, draft[i]);
        //         if (sources.length > 0) {
        //             filtered.push(draft[i]);
        //         }
        //     }
        //     return filtered;
        // }

        function isBase(node, compareNode) {
            while (compareNode) {
                if (compareNode === node) {
                    return true;
                }

                compareNode = self.getBase(compareNode);
            }

            return false;
        }

        function isParent(node, compareNode) {
            while (compareNode) {
                if (compareNode === node) {
                    return true;
                }

                compareNode = self.getParent(compareNode);
            }

            return false;
        }

        function isParentOrBaseRec(node, compareNode, visited, traverseContainment) {
            var comparePath = self.getPath(compareNode);

            if (traverseContainment) {
                if (visited.containment[comparePath]) {
                    //console.log('breaking recursion', traverseContainment, basePath);
                    return false;
                }

                visited.containment[comparePath] = true;
                compareNode = self.getParent(compareNode);
            } else {
                if (visited.inheritance[comparePath]) {
                    //console.log('breaking recursion', traverseContainment, basePath);
                    return false;
                }

                visited.inheritance[comparePath] = true;
                compareNode = self.getBase(compareNode);
            }

            while (compareNode) {
                //console.log('comparing with node', traverseContainment, basePath);
                if (node === compareNode || isParentOrBaseRec(node, compareNode, visited, !traverseContainment)) {
                    //console.log('Found one!');
                    return true;
                }

                if (traverseContainment) {
                    compareNode = self.getParent(compareNode);
                } else {
                    compareNode = self.getBase(compareNode);
                }
            }

            return false;
        }

        function getBaseAncestor(node, otherNode) {
            var bases = [],
                base;

            base = node;
            while (base) {
                bases.push(base);
                base = self.getBase(base);
            }

            base = otherNode;
            while (base) {
                if (bases.indexOf(base) > -1) {
                    return base;
                }

                base = self.getBase(base);
            }

            return null;
        }

        function childHasSameOrigin(node, otherNode, childRelid) {
            var ancestor = getBaseAncestor(node, otherNode),
                result = false;

            if (ancestor) {
                result = self.getChildrenRelids(ancestor, true).hasOwnProperty(childRelid);
            }

            return result;
        }

        function processNewRelidLength(node, newMinLength) {
            var currMinLength;

            if (newMinLength > CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1) {
                logger.debug('Minimum relid length surpassed threshold, not propagating at all', newMinLength);
                return;
            } else if (newMinLength > CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH) {
                newMinLength = CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH;
                logger.debug('Minimum relid length reached threshold, only propagating threshold', newMinLength);
            }

            node = node.base;
            while (node) {
                currMinLength = innerCore.getProperty(node, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY) || 0;
                if (currMinLength >= newMinLength) {
                    return;
                }

                // TODO: Check for library element here??
                innerCore.setProperty(node, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY, newMinLength);
                node = node.base;
            }
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        this.isValidNode = function (node) {
            try {
                isValidNodeThrow(node);
                return true;
            } catch (error) {
                logger.error(error.message, {stack: error.stack, node: node});
                return false;
            }
        };

        this.loadRoot = function (hash) {
            return TASYNC.call(loadRoot2, innerCore.loadRoot(hash));
        };

        this.loadChild = function (node, relid) {
            return TASYNC.call(function (child) {
                if (child && self.isInheritanceContainmentCollision(child, self.getParent(child))) {
                    logger.error('node[' + self.getPath(child) +
                        '] was deleted due to inheritance-containment collision');
                    self.deleteNode(child);
                    //core.persist(core.getRoot(child));
                    return null;
                } else {
                    return child;
                }
            }, loadChild(node, relid));
        };

        this.loadByPath = function (node, path) {
            ASSERT(self.isValidNode(node));
            ASSERT(path === '' || path.charAt(0) === '/');
            path = path.split('/');
            return loadDescendantByPath(node, path, 1);
        };

        this.loadPointer = function (node, name) {
            //TODO the pointer loading is totally based upon the loadByPath...
            var pointerPath = self.getPointerPath(node, name),
                root = self.getRoot(node);

            if (pointerPath === undefined) {
                return undefined;
            }
            if (pointerPath === null) {
                return null;
            }
            return TASYNC.call(function () {
                return self.loadByPath(root, pointerPath);
            }, self.loadPaths(self.getHash(root), [pointerPath]));
        };

        this.getChild = function (node, relid) {
            ASSERT(self.isValidNode(node) && (node.base === undefined || typeof node.base === 'object'));
            var child = innerCore.getChild(node, relid);
            if (node.base !== null && node.base !== undefined) {
                if (child.base === null || child.base === undefined) {
                    child.base = self.getChild(node.base, relid);
                }
            } else {
                child.base = null;
            }
            return child;
        };

        this.getChildrenRelids = function (node, asObject) {
            ASSERT(self.isValidNode(node));
            var base = node,
                relids,
                i;

            function basesHaveSameRelids() {
                var b = node,
                    cnt = 0,
                    len = node.allChildrenRelids.bases.length;

                while (b) {
                    if (cnt === len || b.childrenRelids !== node.allChildrenRelids.bases[cnt]) {
                        return false;
                    }

                    b = b.base;
                    cnt += 1;
                }

                return true;
            }

            if (!node.allChildrenRelids || basesHaveSameRelids() === false) {
                // If there is no cache or the childrenRelids caches are outdated,
                // rebuild the cache.
                node.allChildrenRelids = {
                    cached: {},
                    bases: []
                };

                while (base) {
                    relids = innerCore.getChildrenRelids(base);
                    node.allChildrenRelids.bases.push(relids);

                    for (i = 0; i < relids.length; i += 1) {
                        node.allChildrenRelids.cached[relids[i]] = true;
                    }

                    base = base.base;
                }
            }

            return asObject ? node.allChildrenRelids.cached : Object.keys(node.allChildrenRelids.cached);
        };

        this.loadChildren = function (node) {
            ASSERT(self.isValidNode(node));
            var relids = self.getChildrenRelids(node);
            var children = [];
            for (var i = 0; i < relids.length; i++) {
                children[i] = self.loadChild(node, relids[i]);
            }
            return TASYNC.call(function (n) {
                var newn = [];
                for (var i = 0; i < n.length; i++) {
                    if (n[i] !== null) {
                        newn.push(n[i]);
                    }
                }
                return newn;
            }, TASYNC.lift(children));
        };

        this.setPointer = function (node, name, target) {
            innerCore.setPointer(node, name, target);

            if (isInheritedChild(node)) {
                self.setProperty(node, CONSTANTS.INHERITED_CHILD_HAS_OWN_RELATION_PROPERTY, true);
                // #1232

                self.processRelidReservation(self.getParent(node), self.getRelid(node));
            }

            if (isInheritedChild(target)) {
                self.setProperty(target, CONSTANTS.INHERITED_CHILD_HAS_OWN_RELATION_PROPERTY, true);
                // #1232
                self.processRelidReservation(self.getParent(target), self.getRelid(target));
            }
        };

        this.getCollectionNames = function (node) {
            ASSERT(self.isValidNode(node));
            var ownNames = innerCore.getCollectionNames(node),
                inhNames = getInheritedCollectionNames(node),
                i;
            for (i = 0; i < ownNames.length; i++) {
                if (inhNames.indexOf(ownNames[i]) < 0) {
                    inhNames.push(ownNames[i]);
                }
            }

            return inhNames;
        };

        this.getCollectionPaths = function (node, name) {
            ASSERT(self.isValidNode(node) && name);
            var ownPaths = innerCore.getCollectionPaths(node, name),
                inhPaths = getInheritedCollectionPaths(node, name);

            inhPaths = inhPaths.concat(ownPaths);

            return inhPaths;
        };

        this.loadCollection = function (node, name) {
            var root = self.getRoot(node),
                paths = self.getCollectionPaths(node, name),
                nodes = [],
                i,
                rootHash = self.getHash(root);

            return TASYNC.call(function () {
                for (i = 0; i < paths.length; i += 1) {
                    nodes[i] = self.loadByPath(root, paths[i]);
                }
                return TASYNC.lift(nodes);
            }, self.loadPaths(rootHash, paths));
        };

        this.createChild = function (parent, relidLength) {
            var node = innerCore.createChild(parent, self.getChildrenRelids(parent, true), relidLength);

            this.processRelidReservation(parent, this.getRelid(node));

            return self.getChild(parent, this.getRelid(node));
        };

        this.createNode = function (parameters, relidLength) {
            parameters = parameters || {};
            var base = parameters.base || null,
                parent = parameters.parent,
                node,
                takenRelids;

            ASSERT(!parent || self.isValidNode(parent));
            ASSERT(!base || self.isValidNode(base));
            ASSERT(!base || self.getPath(base) !== self.getPath(parent));

            if (parent) {
                takenRelids = self.getChildrenRelids(parent, true);
                relidLength = relidLength || innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            }

            node = innerCore.createNode(parameters, takenRelids, relidLength);
            node.base = base;
            innerCore.setPointer(node, CONSTANTS.BASE_POINTER, base);

            if (parent) {
                this.processRelidReservation(parent, this.getRelid(node));

                // Addition to #1232
                if (isInheritedChild(parent)) {
                    self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
                }
            }

            return node;
        };

        this.isValidNewParent = function (node, parent) {
            ASSERT(self.isValidNode(node) && self.isValidNode(parent));
            var visited = {
                    containment: {},
                    inheritance: {}
                },
                result = true;

            if (isBase(parent, node)) {
                result = false;
            } else if (isParentOrBaseRec(node, parent, visited, true)) {
                result = false;
            } else if (isParentOrBaseRec(node, parent, visited, false)) {
                result = false;
            }

            return result;
        };

        this.moveNode = function (node, parent, relidLength) {
            ASSERT(self.isValidNewParent(node, parent),
                'New parent would create loop in containment/inheritance tree.');
            var minRelidLength = innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY),
                takenRelids = self.getChildrenRelids(parent, true),
                currRelid = this.getRelid(node),
                base = node.base,
                moved;

            if (typeof minRelidLength === 'number' && currRelid.length < minRelidLength){
                takenRelids[currRelid] = true;
            } else if (typeof relidLength === 'number' && currRelid.length < relidLength){
                takenRelids[currRelid] = true;
            }

            moved = innerCore.moveNode(node, parent, takenRelids, relidLength || minRelidLength);
            moved.base = base;

            this.processRelidReservation(parent, this.getRelid(moved));

            // Addition to #1232
            if (isInheritedChild(parent)) {
                self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
            }

            return moved;
        };

        this.copyNode = function (node, parent, relidLength) {
            ASSERT(!node.base || self.getPath(node.base) !== self.getPath(parent));
            var base = node.base,
                newnode;

            relidLength = relidLength || innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            newnode = innerCore.copyNode(node, parent, self.getChildrenRelids(parent, true), relidLength);
            newnode.base = base;
            innerCore.setPointer(newnode, CONSTANTS.BASE_POINTER, base);

            // The copy does not have any instances at this point -> reset the property.
            innerCore.deleteProperty(newnode, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);

            this.processRelidReservation(parent, this.getRelid(newnode));

            // Addition to #1232
            if (isInheritedChild(parent)) {
                self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
            }

            return newnode;
        };

        this.copyNodes = function (nodes, parent, relidLength) {
            var copiedNodes,
                i, j, index, base,
                relations = [],
                names, pointer,
                longestNewRelid = '',
                paths = [];

            //here we also have to copy the inherited relations which points inside the copy area
            for (i = 0; i < nodes.length; i++) {
                paths.push(self.getPath(nodes[i]));
            }

            for (i = 0; i < nodes.length; i++) {
                names = inheritedPointerNames(nodes[i]);
                pointer = {};
                for (j = 0; j < names.length; j++) {
                    index = paths.indexOf(self.getPointerPath(nodes[i], names[j]));
                    if (index !== -1) {
                        pointer[names[j]] = index;
                    }
                }
                relations.push(pointer);
            }

            relidLength = relidLength || innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            //making the actual copy
            copiedNodes = innerCore.copyNodes(nodes, parent, self.getChildrenRelids(parent, true), relidLength);

            //setting internal-inherited relations
            for (i = 0; i < nodes.length; i++) {
                names = Object.keys(relations[i]);
                for (j = 0; j < names.length; j++) {
                    self.setPointer(copiedNodes[i], names[j], copiedNodes[relations[i][names[j]]]);
                }
            }

            //setting base relation
            for (i = 0; i < nodes.length; i++) {
                base = nodes[i].base;
                copiedNodes[i].base = base;
                innerCore.setPointer(copiedNodes[i], CONSTANTS.BASE_POINTER, base);
                innerCore.deleteProperty(copiedNodes[i], CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY);
            }

            //searching for the longest new relid and then process it towards the bases of the parent
            for (i = 0; i < copiedNodes.length; i += 1) {
                j = this.getRelid(copiedNodes[i]);
                if (j.length > longestNewRelid) {
                    longestNewRelid = j;
                }
            }

            this.processRelidReservation(parent, longestNewRelid);

            // Addition to #1232
            if (isInheritedChild(parent)) {
                self.processRelidReservation(self.getParent(parent), self.getRelid(parent));
            }

            return copiedNodes;
        };

        this.deleteNode = function (node, technical) {
            //currently we only check if the node is inherited from its parents children
            if (node && (node.base !== null || technical === true)) {
                var parent = self.getParent(node),
                    parentsBase = parent ? self.getBase(node) : null,
                    base = self.getBase(node),
                    basesParent = base ? self.getParent(node) : null;

                if (parent && parentsBase && base && basesParent) {
                    if (self.getPath(parentsBase) !== self.getPath(basesParent)) {
                        innerCore.deleteNode(node);
                    }
                } else {
                    innerCore.deleteNode(node);
                }
            }
        };

        this.getAttributeNames = function (node) {
            ASSERT(self.isValidNode(node));

            var merged = {};
            do {
                var names = innerCore.getAttributeNames(node);
                for (var i = 0; i < names.length; ++i) {
                    if (!(names[i] in merged)) {
                        merged[names[i]] = true;
                    }
                }

                node = node.base;
            } while (node);

            return Object.keys(merged);
        };

        this.getRegistryNames = function (node) {
            ASSERT(self.isValidNode(node));

            var merged = {};
            do {
                var names = innerCore.getRegistryNames(node);
                for (var i = 0; i < names.length; ++i) {
                    if (!(names[i] in merged)) {
                        merged[names[i]] = true;
                    }
                }

                node = node.base;
            } while (node);

            return Object.keys(merged);
        };

        this.getAttribute = function (node, name) {
            ASSERT(self.isValidNode(node));
            var value;
            do {
                value = innerCore.getAttribute(node, name);
                node = node.base;
            } while (value === undefined && node !== null);

            return value;
        };

        this.getRegistry = function (node, name) {
            ASSERT(self.isValidNode(node));
            var value;
            do {
                value = innerCore.getRegistry(node, name);
                node = node.base;
            } while (value === undefined && node !== null);

            return value;
        };

        this.getPointerNames = function (node) {
            ASSERT(self.isValidNode(node));

            return self.getPointerNamesFrom(node, '');
            //var merged = {};
            //do {
            //    var names = oldcore.getPointerNames(node);
            //    for (var i = 0; i < names.length; ++i) {
            //        if (!(names[i] in merged)) {
            //            merged[names[i]] = true;
            //        }
            //    }
            //
            //    node = node.base;
            //} while (node);
            //
            //return Object.keys(merged);
        };

        this.getPointerNamesFrom = function (node, source) {
            ASSERT(self.isValidNode(node));

            var merged = {};
            do {
                var names = innerCore.getPointerNamesFrom(node, source);
                for (var i = 0; i < names.length; ++i) {
                    if (!(names[i] in merged)) {
                        merged[names[i]] = true;
                    }
                }

                node = node.base;
            } while (node);

            return Object.keys(merged);
        };

        this.getPointerPathFrom = function (node, source, name) {
            ASSERT(self.isValidNode(node) && typeof name === 'string');

            var ownPointerPath = innerCore.getPointerPathFrom(node, source, name);
            if (ownPointerPath !== undefined) {
                return ownPointerPath;
            }
            var target,
                basePath,
                hasNullTarget = false;

            basePath = node.base ? getSimpleBasePath(node.base, source, name) : undefined;

            while (node) {
                target = getTargetRelPath(node, source, name);
                if (target !== undefined) {
                    if (target.indexOf('_nullptr') !== -1) {
                        hasNullTarget = true;
                        target = undefined;
                    } else {
                        break;
                    }
                }

                source = '/' + self.getRelid(node) + source;
                if (getParentOfBasePath(node) === getBaseOfParentPath(node)) {
                    node = self.getParent(node);
                } else {
                    node = null;
                }
            }

            if (target !== undefined) {
                ASSERT(node);
                target = innerCore.joinPaths(innerCore.getPath(node), target);
            }

            if (typeof target === 'string') {
                return target;
            }
            if (typeof basePath === 'string') {
                return basePath;
            }
            if (hasNullTarget === true) {
                return null;
            }
            return undefined;

        };

        this.getPointerPath = function (node, name) {
            return self.getPointerPathFrom(node, '', name);
        };

        this.getChildrenPaths = function (node) {
            var path = self.getPath(node);

            var relids = self.getChildrenRelids(node);
            // Remark: It's fine to mutate this array since we're using Object.keys on the cached object..
            for (var i = 0; i < relids.length; ++i) {
                relids[i] = path + '/' + relids[i];
            }

            return relids;
        };

        this.setAttribute = function (node, name, value) {
            innerCore.setAttribute(node, name, value);

            // #1232
            if (isInheritedChild(node)) {
                self.processRelidReservation(self.getParent(node), self.getRelid(node));
            }
        };

        this.setRegistry = function (node, name, value) {
            innerCore.setRegistry(node, name, value);

            // #1232
            if (isInheritedChild(node)) {
                self.processRelidReservation(self.getParent(node), self.getRelid(node));
            }
        };

        //</editor-fold>

        //<editor-fold=Added Methods>

        //check of inheritance chain and containment hierarchy collision
        this.isInheritanceContainmentCollision = function (node, parent) {
            var bases = [];

            while (node) {
                bases.push(self.getPath(node));
                node = self.getBase(node);
            }

            while (parent) {
                if (bases.indexOf(self.getPath(parent)) !== -1) {
                    return true;
                }
                parent = self.getParent(parent);
            }
            return false;
        };

        this.getBase = function (node) {
            ASSERT(self.isValidNode(node));

            // TODO: check if base has moved
            return node.base;
        };

        this.isValidNewBase = function (node, base) {
            ASSERT(self.isValidNode(node) && (base === undefined || base === null || self.isValidNode(base)));
            var visited = {
                    containment: {},
                    inheritance: {}
                },
                result = true;

            if (!base) {
                result = true;
            } else if (isParent(base, node)) {
                result = false;
            } else if (isParentOrBaseRec(node, base, visited, true)) {
                result = false;
            } else if (isParentOrBaseRec(node, base, visited, false)) {
                result = false;
            }

            return result;
        };

        this.setBase = function (node, base) {
            ASSERT(self.isValidNewBase(node, base),
                'New base would create loop in containment/inheritance tree.');

            if (base) {
                //TODO maybe this is not the best way, needs to be double checked
                var parent = self.getParent(node),
                    nodeChildren = self.getOwnChildrenRelids(node), // We're only interested in the children with data.
                    minRelidLength = innerCore.getProperty(node, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY) || 0,
                    baseChildren = self.getChildrenRelids(base, true),
                    parentBase,
                    baseParent,
                    i;

                if (parent) {
                    parentBase = self.getBase(parent);
                    baseParent = self.getParent(base);
                    if (self.getPath(parentBase) !== self.getPath(baseParent)) {
                        //we have to set an exact pointer only if it is not inherited child
                        innerCore.setPointer(node, CONSTANTS.BASE_POINTER, base);

                        for (i = 0; i < nodeChildren.length; i += 1) {
                            if (baseChildren[nodeChildren[i]] && childHasSameOrigin(node, base, nodeChildren[i])) {
                                // Currently we only keep the children data for children with same origin.
                                // Meaning we delete all other children (including those that were created in node).
                            } else {
                                innerCore.deleteChild(node, nodeChildren[i]);
                            }
                        }
                    } else {
                        innerCore.deletePointer(node, CONSTANTS.BASE_POINTER); //we remove the pointer just in case
                    }
                } else {
                    //if for some reason the node doesn't have a parent it is surely not an inherited child
                    innerCore.setPointer(node, CONSTANTS.BASE_POINTER, base);
                }

                node.base = base;

                // Handle the minimal new length propagation to the new base chain.
                for (i = 0; i < nodeChildren.length; i += 1) {
                    // Do not account for old relids..
                    if (nodeChildren[i].length <= CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH) {
                        minRelidLength = nodeChildren[i].length + 1 > minRelidLength ?
                        nodeChildren[i].length + 1 : minRelidLength;
                    }
                }

                if (minRelidLength >= 2) {
                    processNewRelidLength(node, minRelidLength);
                }
            } else {
                innerCore.setPointer(node, CONSTANTS.BASE_POINTER, null);
                node.base = null;
            }
        };

        this.getBaseRoot = function (node) {
            ASSERT(self.isValidNode(node));
            while (node.base !== null) {
                node = node.base;
            }

            return node;
        };

        this.getTypeRoot = function (node) {
            if (node.base) {
                while (node.base !== null) {
                    node = self.getBase(node);
                }
                return node;
            } else {
                return null;
            }
        };

        this.getOwnChildrenRelids = function (node) {
            return innerCore.getChildrenRelids(node);
        };

        this.loadOwnChildren = function (node) {
            ASSERT(self.isValidNode(node));
            var relids = self.getOwnChildrenRelids(node);
            var children = [];
            for (var i = 0; i < relids.length; i++) {
                children[i] = self.loadChild(node, relids[i]);
            }
            return TASYNC.call(function (n) {
                var newn = [];
                for (var i = 0; i < n.length; i++) {
                    if (n[i] !== null) {
                        newn.push(n[i]);
                    }
                }
                return newn;
            }, TASYNC.lift(children));
        };

        this.getOwnAttributeNames = function (node) {
            return innerCore.getAttributeNames(node);
        };

        this.getOwnRegistryNames = function (node) {
            return innerCore.getRegistryNames(node);
        };

        this.getOwnAttribute = function (node, name) {
            return innerCore.getAttribute(node, name);
        };

        this.getOwnRegistry = function (node, name) {
            return innerCore.getRegistry(node, name);
        };

        this.getOwnPointerNames = function (node) {
            ASSERT(self.isValidNode(node));
            return innerCore.getPointerNames(node);
        };

        this.getOwnPointerNamesFrom = function (node, source) {
            return innerCore.getPointerNamesFrom(node, source);
        };

        this.getOwnPointerPath = function (node, name) {
            innerCore.getPointerPath(node, name);
        };

        this.getOwnPointerPathFrom = function (node, source, name) {
            innerCore.getPointerPathFrom(node, source, name);
        };

        this.getOwnChildrenPaths = function (node) {
            return innerCore.getChildrenPaths(node);
        };

        this.processRelidReservation = function (node, relid) {
            if (!CONSTANTS.DOES_NOT_HAVE_RELID_CHILDREN[self.getRelid(node)] && innerCore.isValidRelid(relid)) {
                // We do not process relids for e.g. _sets and _meta.
                processNewRelidLength(node, relid.length + 1);
            }
        };

        this.getInstancePaths = function (node) {
            var instances = [],
                directCollectionPaths,
                relPath = '',
                i;

            while (node) {
                directCollectionPaths = innerCore.getCollectionPaths(node, CONSTANTS.BASE_POINTER);
                for (i = 0; i < directCollectionPaths.length; i += 1) {
                    instances.push(directCollectionPaths[i] + relPath);
                }
                relPath = CONSTANTS.PATH_SEP + innerCore.getRelid(node) + relPath;
                node = innerCore.getParent(node);
            }

            return instances;
        };

        this.loadInstances = function (node) {
            ASSERT(self.isValidNode(node));

            var instancePaths = self.getInstancePaths(node),
                instances = [],
                root = self.getRoot(node),
                i;

            for (i = 0; i < instancePaths.length; i += 1) {
                instances[i] = self.loadByPath(root, instancePaths[i]);
            }

            return TASYNC.lift(instances);
        };
        //</editor-fold>
    };

    return CoreType;
})
;

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 *
 * example constraint structure for the outside world:
 * {
 *  script:string,
 *  priority:integer,
 *  name:string,
 *  message:string
 * }
 * provided API:
 * getConstraint(node,name) -> constraintObj
 * setConstraint(node,constraintObj)
 * getConstraintNames(node)
 * delConstraint(node,name)
 */

define('common/core/constraintcore',['common/util/assert', 'common/core/constants'], function (ASSERT, CONSTANTS) {
    'use strict';

    function ConstraintCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized ConstraintCore');

        //<editor-fold=Helper Functions>
        function getConstraintRelId(constraintsNode, name) {
            var relIds = innerCore.getChildrenRelids(constraintsNode);
            var relId;
            for (var i = 0; i < relIds.length; i++) {
                if (name === innerCore.getAttribute(innerCore.getChild(constraintsNode, relIds[i]), 'name')) {
                    relId = relIds[i];
                    break;
                }
            }
            return relId;
        }

        function getRegConstName(name) {
            return CONSTANTS.CONSTRAINT_REGISTRY_PREFIX + name;
        }

        function getContraintNames(node, onlyOwn) {
            ASSERT(self.isValidNode(node));
            var constraintsNode = self.getChild(node, CONSTANTS.CONSTRAINTS_RELID),
                relIds = onlyOwn ? self.getOwnChildrenRelids(constraintsNode) : self.getChildrenRelids(constraintsNode),
                names = [];

            for (var i = 0; i < relIds.length; i += 1) {
                names.push(self.getAttribute(self.getChild(constraintsNode, relIds[i]), 'name'));
            }
            return names;
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.getConstraint = function (node, name) {
            ASSERT(innerCore.isValidNode(node));
            var constraintsNode = innerCore.getChild(node, CONSTANTS.CONSTRAINTS_RELID);
            var constRelId = getConstraintRelId(constraintsNode, name);
            if (constRelId) {
                var constraintNode = innerCore.getChild(constraintsNode, constRelId);
                return {
                    script: innerCore.getAttribute(constraintNode, 'script'),
                    priority: innerCore.getAttribute(constraintNode, 'priority'),
                    info: innerCore.getAttribute(constraintNode, 'info')
                };
            } else {
                return null;
            }
        };

        this.setConstraint = function (node, name, constraintObj) {
            ASSERT(innerCore.isValidNode(node));
            ASSERT(typeof constraintObj === 'object' && typeof name === 'string');
            var constraintsNode = innerCore.getChild(node, CONSTANTS.CONSTRAINTS_RELID),
                constRelId = getConstraintRelId(constraintsNode, name),
                constraintNode;

            if (constRelId) {
                constraintNode = innerCore.getChild(constraintsNode, constRelId);
            } else {
                constraintNode = innerCore.createChild(constraintsNode, CONSTANTS.MAXIMUM_STARTING_RELID_LENGTH + 1);
            }

            constraintObj.priority = constraintObj.priority || CONSTANTS.C_DEF_PRIORITY;
            constraintObj.script = constraintObj.script || 'console.log("empty constraint");';
            constraintObj.info = constraintObj.info || '';
            innerCore.setAttribute(constraintNode, 'name', name);
            innerCore.setAttribute(constraintNode, 'script', constraintObj.script);
            innerCore.setAttribute(constraintNode, 'priority', constraintObj.priority);
            innerCore.setAttribute(constraintNode, 'info', constraintObj.info);
            innerCore.setRegistry(node, getRegConstName(name),
                (innerCore.getRegistry(node, getRegConstName(name)) || 0) + 1);
        };

        this.delConstraint = function (node, name) {
            ASSERT(innerCore.isValidNode(node));
            var constraintsNode = innerCore.getChild(node, CONSTANTS.CONSTRAINTS_RELID);
            var constRelId = getConstraintRelId(constraintsNode, name);
            if (constRelId) {
                var constraintNode = innerCore.getChild(constraintsNode, constRelId);
                innerCore.deleteNode(constraintNode, true);
            }

            innerCore.delRegistry(node, getRegConstName(name));
        };

        this.getConstraintNames = function (node) {
            return getContraintNames(node, false);
        };

        //TODO this means we always have to have this layer above type/inheritance layer
        this.getOwnConstraintNames = function (node) {
            return getContraintNames(node, true);
        };
        //</editor-fold>
    }

    return ConstraintCore;
});

/*globals define*/
/*jshint node:true, browser: true*/
/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/core/convertData',['common/core/constants', 'common/storage/constants'], function (CORE_CONSTANTS, STORAGE_CONSTANTS) {
    'use strict';

    var dataConverters,
        APP_VERSION = STORAGE_CONSTANTS.VERSION,
        MAJOR_APP_VERSION = APP_VERSION.split('.')[0];

    function isCollectionName(name) {
        if (name.length > CORE_CONSTANTS.COLLECTION_NAME_SUFFIX.length &&
            CORE_CONSTANTS.COLLECTION_NAME_SUFFIX === name.slice(-CORE_CONSTANTS.COLLECTION_NAME_SUFFIX.length)) {
            return true;
        }
        return false;
    }

    function clearOvrOfInvRelations(overlay) {
        var sourcePath,
            relationName;

        for (sourcePath in overlay) {
            for (relationName in overlay[sourcePath]) {
                if (isCollectionName(relationName)) {
                    delete overlay[sourcePath][relationName];
                }
            }

            // Remove all empty overlay entries
            if (Object.keys(overlay[sourcePath]).length === 0) {
                delete overlay[sourcePath];
            }
        }
    }

    // 0.0.0 --> 1.0.0
    // - every inverse relation has to be removed from the overlay
    function zeroToOne(dataObject) {

        clearOvrOfInvRelations(dataObject[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});

        dataObject.__v = '1.0.0';
        return dataObject;
    }

    function oneToOnePointOne(dataObject) {
        var currentSet,
            metaEntry,
            key;

        // Clear direct _sets of inverse overlay relations.
        currentSet = dataObject[CORE_CONSTANTS.ALL_SETS_PROPERTY] || {};
        clearOvrOfInvRelations(currentSet[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});

        metaEntry = dataObject[CORE_CONSTANTS.META_NODE] || {};
        clearOvrOfInvRelations(metaEntry[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});

        for (key in metaEntry) {
            currentSet = metaEntry[key];
            currentSet = currentSet[CORE_CONSTANTS.ALL_SETS_PROPERTY] || {};
            clearOvrOfInvRelations(currentSet[CORE_CONSTANTS.OVERLAYS_PROPERTY] || {});
        }

        dataObject.__v = '1.1.0';

        return dataObject;
    }

    dataConverters = {
        '0.0.0': {
            '1.0.0': zeroToOne,
            '1.1.0': function (dataObject) {
                return oneToOnePointOne(zeroToOne(dataObject));
            }
        },
        '1.0.0': {
            '1.1.0': oneToOnePointOne
        }
    };

    /**
     * Converts the passed dataObject to an object (a copy) of the current app version unless the same version.
     * @param {object} dataObject
     * @returns {object} A new object if converted, otherwise the passed dataObject.
     */
    function convertData(dataObject) {
        var dataVersion = dataObject.__v || '0.0.0',
            majorDataVersion = dataVersion.split('.')[0];

        if (majorDataVersion > MAJOR_APP_VERSION) {
            throw new Error('Trying to load data of incompatible version. Current version "' +
                APP_VERSION + '", data version "' + dataVersion + '".');
        }

        if (dataVersion !== APP_VERSION &&
            dataConverters[dataVersion] &&
            typeof dataConverters[dataVersion][APP_VERSION] === 'function') {

            return dataConverters[dataVersion][APP_VERSION](JSON.parse(JSON.stringify(dataObject)));
        }

        return dataObject;
    }

    return convertData;
});
/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/coretree',[
    'common/util/assert',
    'common/util/key',
    'common/core/tasync',
    'common/util/random',
    'common/regexp',
    'common/core/constants',
    'common/core/convertData'
], function (ASSERT, GENKEY, TASYNC, RANDOM, REGEXP, CONSTANTS, convertData) {

    'use strict';

    var rootCounter = 0;

    function CoreTree(storage, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var gmeConfig = options.globConf,
            logger = options.logger.fork('core'),
            ID_NAME = storage.ID_NAME,
            roots = [],
            ticks = 0,
            mutateCount = 0,
            stackedObjects = {},
            self = this;

        storage.loadObject = TASYNC.wrap(storage.loadObject);

        this.loadPaths = TASYNC.wrap(storage.loadPaths);
        this.logger = logger;

        function ASSERT_IS_OBJECT(value) {
            ASSERT(value !== null && typeof value === 'object' && value instanceof Array === false);
        }

        // ------- memory management

        function __detachChildren(node) {
            ASSERT_IS_OBJECT(node.children);
            ASSERT(node.age >= CONSTANTS.MAX_AGE - 1);

            var children = node.children;
            node.children = null;
            node.age = CONSTANTS.MAX_AGE;

            for (var child in children) {
                __detachChildren(children[child]);
            }
        }

        function __ageNodes(nodes) {
            ASSERT_IS_OBJECT(nodes);

            var keys = Object.keys(nodes),
                node,
                i;

            for (i = 0; i < keys.length; i += 1) {
                node = nodes[keys[i]];
                ASSERT(node.age < CONSTANTS.MAX_AGE);
                if (++node.age >= CONSTANTS.MAX_AGE) {
                    delete nodes[keys[i]];
                    __detachChildren(node);
                } else {
                    __ageNodes(node.children);
                }
            }
        }

        function __ageRoots() {
            var root,
                i;
            if (++ticks >= CONSTANTS.MAX_TICKS) {
                ticks = 0;
                i = roots.length;
                while (--i >= 0) {
                    root = roots[i];
                    ASSERT(root.age < CONSTANTS.MAX_AGE);
                    if (++root.age >= CONSTANTS.MAX_AGE) {
                        roots.splice(i, 1);
                        __detachChildren(root);
                    } else {
                        __ageNodes(root.children);
                    }
                }
            }
        }

        function __getChildNode(children, relid) {
            ASSERT_IS_OBJECT(children);
            ASSERT(typeof relid === 'string');

            if (children.hasOwnProperty(relid)) {
                children[relid].age = 0;
                return children[relid];
            }

            return null;
        }

        function __getChildData(data, relid) {
            ASSERT(typeof relid === 'string');

            if (typeof data === 'object' && data !== null) {
                data = data[relid];
                return data === undefined ? __getEmptyData() : data;
            } else {
                return null;
            }
        }

        function __isMutableData(data) {
            return typeof data === 'object' && data !== null && data[CONSTANTS.MUTABLE_PROPERTY] === true;
        }

        function __isEmptyData(data) {
            if (typeof data === 'string') {
                return false;
            } else if (typeof data === 'object' && Object.keys(data).length === 0) {
                return true;
            } else {
                return false;
            }
        }

        function __getEmptyData() {
            return {};
        }

        function __areEquivalent(data1, data2) {
            return data1 === data2 || (typeof data1 === 'string' && data1 === __getChildData(data2, ID_NAME)) ||
                (__isEmptyData(data1) && __isEmptyData(data2));
        }

        function __reloadChildrenData(node) {
            var key,
                child;

            for (key in node.children) {
                child = node.children[key];

                var data = __getChildData(node.data, child.relid);
                if (!REGEXP.DB_HASH.test(data) || data !== __getChildData(child.data, ID_NAME)) {
                    child.data = data;
                    __reloadChildrenData(child);
                }
            }
        }

        function __noUnderscore(relid) {
            ASSERT(typeof relid === 'string');
            return relid.charAt(0) !== '_';
        }

        function __saveData(data, root, path) {
            ASSERT(__isMutableData(data));
            var cleanData;

            var done = __getEmptyData(),
                keys,
                key,
                i, child, sub, hash;

            delete data[CONSTANTS.MUTABLE_PROPERTY];
            keys = Object.keys(data);

            for (i = 0; i < keys.length; i++) {
                key = keys[i];
                child = data[key];
                if (__isMutableData(child)) {
                    sub = __saveData(child, root, path + '/' + key);
                    if (JSON.stringify(sub) === JSON.stringify(__getEmptyData())) {
                        delete data[key];
                    } else {
                        done = sub;
                        if (typeof child[ID_NAME] === 'string') {
                            data[key] = child[ID_NAME];
                        }
                    }
                } else {
                    done = undefined;
                }
            }

            if (done !== __getEmptyData()) {
                hash = data[ID_NAME];
                ASSERT(hash === '' || hash === undefined);

                if (hash === '') {
                    //TODO: This is a temporary fix. We should modify CANON.
                    cleanData = JSON.parse(JSON.stringify(data));
                    hash = '#' + GENKEY(cleanData, gmeConfig);
                    data[ID_NAME] = hash;
                    cleanData[ID_NAME] = hash;

                    done = cleanData;

                    storage.insertObject(cleanData, stackedObjects);
                    stackedObjects[hash] = {
                        newHash: hash,
                        newData: cleanData,
                        oldHash: root.initial[path] && root.initial[path].hash,
                        oldData: root.initial[path] && root.initial[path].data
                    };

                    root.initial[path] = {
                        hash: hash,
                        data: cleanData
                    };
                    //stackedObjects[hash] = data;
                }
            }

            return done;
        }

        function __loadRoot2(data) {
            var root = {
                parent: null,
                relid: null,
                age: 0,
                children: {},
                data: null,
                initial: {
                    '': {
                        hash: data[storage.ID_NAME],
                        data: data
                    }
                },
                rootid: ++rootCounter
            };

            // Ensure we get the correct version of the data.
            root.data = convertData(data);

            roots.push(root);

            __ageRoots();
            return root;
        }

        function __loadChild2(node, newdata) {
            var root = self.getRoot(node),
                path = self.getPath(node);

            node = self.normalize(node);

            // TODO: this is a hack, we should avoid loading it multiple times
            if (REGEXP.DB_HASH.test(node.data)) {
                ASSERT(node.data === newdata[ID_NAME]);

                root.initial[path] = {
                    hash: node.data,
                    data: newdata
                };

                // Ensure we get the correct version of the data.
                node.data = convertData(newdata);
                __reloadChildrenData(node);
            } else {
                // TODO: if this bites you, use the Cache
                /*if(node.data !== newdata){
                 console.log('kecso',node);
                 }
                 ASSERT(node.data === newdata);*/
            }

            return node;
        }

        function __loadDescendantByPath2(node, path, index) {
            if (node === null || index === path.length) {
                return node;
            }

            var child = self.loadChild(node, path[index]);
            return TASYNC.call(__loadDescendantByPath2, child, path, index + 1);
        }

        // function __printNode(node) {
        //     var str = '{';
        //     str += 'age:' + node.age;
        //
        //     if (typeof node.relid === 'string') {
        //         str += ', relid: "' + node.relid + '"';
        //     }
        //
        //     str += ', children:';
        //     if (node.children === null) {
        //         str += 'null';
        //     } else {
        //         str += '[';
        //         for (var i = 0; i < node.children.length; ++i) {
        //             if (i !== 0) {
        //                 str += ', ';
        //             }
        //             str += __printNode(node.children[i]);
        //         }
        //         str += ']';
        //     }
        //
        //     str += '}';
        //     return str;
        // }

        function __test(text, cond) {
            if (!cond) {
                throw new Error(text);
            }
        }

        function isValidNodeThrow(node) {
            __test('object', typeof node === 'object' && node !== null);
            __test('object 2', node.hasOwnProperty('parent') && node.hasOwnProperty('relid'));
            __test('parent', typeof node.parent === 'object');
            __test('relid', typeof node.relid === 'string' || node.relid === null);
            __test('parent 2', (node.parent === null) === (node.relid === null));
            __test('age', node.age >= 0 && node.age <= CONSTANTS.MAX_AGE);
            //__test('children', node.children === null || node.children instanceof Array);
            __test('children 2', (node.age === CONSTANTS.MAX_AGE) === (node.children === null));
            __test('data', typeof node.data === 'object' || typeof node.data === 'string' ||
                typeof node.data === 'number');

            if (node.parent !== null) {
                __test('age 2', node.age >= node.parent.age);
                __test('mutable', !__isMutableData(node.data) || __isMutableData(node.parent.data));
            }
        }

        // ------- static methods
        this.getParent = function (node) {
            ASSERT(typeof node.parent === 'object');

            return node.parent;
        };

        this.getRelid = function (node) {
            ASSERT(node.relid === null || typeof node.relid === 'string');

            return node.relid;
        };

        this.getLevel = function (node) {
            var level = 0;
            while (node.parent !== null) {
                ++level;
                node = node.parent;
            }
            return level;
        };

        this.getRoot = function (node) {
            while (node.parent !== null) {
                node = node.parent;
            }
            return node;
        };

        this.getPath = function (node, base) {
            if (node === null) {
                return null;
            }

            var path = '';
            while (node.relid !== null && node !== base) {
                path = '/' + node.relid + path;
                node = node.parent;
            }
            return path;
        };

        this.isValidPath = function (path) {
            return typeof path === 'string' && (path === '' || path.charAt(0) === '/');
        };

        this.splitPath = function (path) {
            ASSERT(self.isValidPath(path));

            path = path.split('/');
            path.splice(0, 1);

            return path;
        };

        this.buildPath = function (path) {
            ASSERT(path instanceof Array);

            return path.length === 0 ? '' : '/' + path.join('/');
        };

        this.joinPaths = function (first, second) {
            ASSERT(self.isValidPath(first) && self.isValidPath(second));

            return first + second;
        };

        this.getCommonPathPrefixData = function (first, second) {
            ASSERT(typeof first === 'string' && typeof second === 'string');

            first = self.splitPath(first);
            second = self.splitPath(second);

            var common = [];
            for (var i = 0; first[i] === second[i] && i < first.length; ++i) {
                common.push(first[i]);
            }

            return {
                common: self.buildPath(common),
                first: self.buildPath(first.slice(i)),
                firstLength: first.length - i,
                second: self.buildPath(second.slice(i)),
                secondLength: second.length - i
            };
        };

        this.normalize = function (node) {
            ASSERT(self.isValidNode(node));
            // console.log('normalize start', printNode(getRoot(node)));

            var parent;

            if (node.children === null) {
                ASSERT(node.age === CONSTANTS.MAX_AGE);

                if (node.parent !== null) {
                    parent = self.normalize(node.parent);

                    var temp = __getChildNode(parent.children, node.relid);
                    if (temp !== null) {
                        // TODO: make the current node close to the returned one

                        // console.log('normalize end1',
                        // printNode(getRoot(temp)));
                        return temp;
                    }

                    ASSERT(node.parent.children === null || __getChildNode(node.parent.children, node.relid) === null);
                    ASSERT(__getChildNode(parent.children, node.relid) === null);

                    node.parent = parent;
                    parent.children[node.relid] = node;

                    temp = __getChildData(parent.data, node.relid);
                    if (!REGEXP.DB_HASH.test(temp) || temp !== __getChildData(node.data, ID_NAME)) {
                        node.data = temp;
                    }
                } else {
                    roots.push(node);
                }

                node.age = 0;
                node.children = {};
            } else if (node.age !== 0) {
                parent = node;
                do {
                    parent.age = 0;
                    parent = parent.parent;
                } while (parent !== null && parent.age !== 0);
            }

            // console.log('normalize end2', printNode(getRoot(node)));
            return node;
        };

        // ------- hierarchy

        this.getAncestor = function (first, second) {
            ASSERT(self.getRoot(first) === self.getRoot(second));

            first = self.normalize(first);
            second = self.normalize(second);

            var a = [];
            do {
                a.push(first);
                first = first.parent;
            } while (first !== null);

            var b = [];
            do {
                b.push(second);
                second = second.parent;
            } while (second !== null);

            var i = a.length - 1;
            var j = b.length - 1;
            while (i !== 0 && j !== 0 && a[i - 1] === b[j - 1]) {
                --i;
                --j;
            }

            ASSERT(a[i] === b[j]);
            return a[i];
        };

        this.isAncestor = function (node, ancestor) {
            ASSERT(self.getRoot(node) === self.getRoot(ancestor));

            node = self.normalize(node);
            ancestor = self.normalize(ancestor);

            do {
                if (node === ancestor) {
                    return true;
                }

                node = node.parent;
            } while (node !== null);

            return false;
        };

        this.createRoot = function () {
            var root = {
                parent: null,
                relid: null,
                age: 0,
                children: {},
                data: {
                    _mutable: true
                },
                initial: {
                    '': null
                },
                rootid: ++rootCounter
            };
            root.data[ID_NAME] = '';
            roots.push(root);

            __ageRoots();
            return root;
        };

        this.getChild = function (node, relid) {
            ASSERT(typeof relid === 'string' && relid !== ID_NAME);

            node = self.normalize(node);

            var child = __getChildNode(node.children, relid);
            if (child !== null) {
                return child;
            }

            child = {
                parent: node,
                relid: relid,
                age: 0,
                children: {},
                data: __getChildData(node.data, relid)
            };
            node.children[relid] = child;

            __ageRoots();
            return child;
        };

        this.createChild = function (node, takenRelids, minimumLength) {
            node = self.normalize(node);

            if (typeof node.data !== 'object' || node.data === null) {
                throw new Error('invalid node data');
            }

            return self.getChild(node, RANDOM.generateRelid(takenRelids || node.data, minimumLength));
        };

        // ------- data manipulation

        this.isMutable = function (node) {
            node = self.normalize(node);
            return __isMutableData(node.data);
        };

        this.isEmpty = function (node) {
            node = self.normalize(node);
            if (typeof node.data !== 'object' || node.data === null) {
                return false;
            } else if (node.data === __getEmptyData()) {
                return true;
            }

            return __isEmptyData(node.data);
        };

        this.mutate = function (node) {
            ASSERT(self.isValidNode(node));

            node = self.normalize(node);
            var data = node.data;

            if (typeof data !== 'object' || data === null) {
                return false;
            } else if (data[CONSTANTS.MUTABLE_PROPERTY] === true) {
                return true;
            }

            // TODO: infinite cycle if MAX_MUTATE is smaller than depth!
            // gmeConfig.storage.autoPersist is removed and always false
            if (false && ++mutateCount > CONSTANTS.MAX_MUTATE) {
                mutateCount = 0;

                for (var i = 0; i < roots.length; ++i) {
                    if (__isMutableData(roots[i].data)) {
                        __saveData(roots[i].data, roots[i], '');
                    }
                }
            }

            if (node.parent !== null && !self.mutate(node.parent)) {
                // this should never happen
                return false;
            }

            var copy = __getEmptyData();

            for (var key in data) {
                copy[key] = data[key];
            }
            copy[CONSTANTS.MUTABLE_PROPERTY] = true;

            if (typeof data[ID_NAME] === 'string') {
                copy[ID_NAME] = '';
            }

            if (node.parent !== null) {
                //inherited child doesn't have an entry in the parent as long as it has not been modified
                ASSERT(node.parent.data[node.relid] === undefined ||
                    __areEquivalent(__getChildData(node.parent.data, node.relid), node.data));
                node.parent.data[node.relid] = copy;
            }

            node.data = copy;
            return true;
        };

        this.getData = function (node) {
            node = self.normalize(node);

            ASSERT(!__isMutableData(node.data));
            return node.data;
        };

        this.setData = function (node, data) {
            ASSERT(data !== null && typeof data !== 'undefined');

            node = self.normalize(node);
            if (node.parent !== null) {
                if (!self.mutate(node.parent)) {
                    throw new Error('incorrect node data');
                }

                node.parent.data[node.relid] = data;
            }

            node.data = data;
            __reloadChildrenData(node);
        };

        this.deleteData = function (node) {
            node = self.normalize(node);

            if (node.parent !== null) {
                if (!self.mutate(node.parent)) {
                    throw new Error('incorrect node data');
                }

                delete node.parent.data[node.relid];
            }

            var data = node.data;

            node.data = __getEmptyData();
            __reloadChildrenData(node);

            return data;
        };

        this.copyData = function (node) {
            node = self.normalize(node);

            if (typeof node.data !== 'object' || node.data === null) {
                return node.data;
            }

            // TODO: return immutable data without coping
            return JSON.parse(JSON.stringify(node.data));
        };

        this.getProperty = function (node, name) {
            ASSERT(typeof name === 'string' && name !== ID_NAME);

            var data;
            node = self.normalize(node);

            if (typeof node.data === 'object' && node.data !== null) {
                data = node.data[name];
            }

            // TODO: corerel uses getProperty to get the overlay content which can get mutable
            // ASSERT(!__isMutableData(data));
            return data;
        };

        this.setProperty = function (node, name, data) {
            ASSERT(typeof name === 'string' && name !== ID_NAME);
            ASSERT(!__isMutableData(data) /*&& data !== null*/ && data !== undefined);
            //TODO is the 'null' really can be a value of a property???

            node = self.normalize(node);
            if (!self.mutate(node)) {
                throw new Error('incorrect node data');
            }

            node.data[name] = data;

            var child = __getChildNode(node.children, name);
            if (child !== null) {
                child.data = data;
                __reloadChildrenData(child);
            }
        };

        this.deleteProperty = function (node, name) {
            ASSERT(typeof name === 'string' && name !== ID_NAME);

            node = self.normalize(node);
            if (!self.mutate(node)) {
                throw new Error('incorrect node data');
            }

            delete node.data[name];

            var child = __getChildNode(node.children, name);
            if (child !== null) {
                child.data = __getEmptyData();
                __reloadChildrenData(child);
            }
        };

        this.getKeys = function (node, predicate) {
            var result;
            node = self.normalize(node);

            if (typeof node.data !== 'object' || node.data === null) {
                return null;
            }

            result = this.getRawKeys(node.data, predicate);
            return result;
        };

        this.getRawKeys = function (object, predicate) {
            predicate = predicate || __noUnderscore;

            var keys = Object.keys(object);

            var i = keys.length;
            while (--i >= 0 && !predicate(keys[i])) {
                keys.pop();
            }

            while (--i >= 0) {
                if (!predicate(keys[i])) {
                    keys[i] = keys.pop();
                }
            }

            return keys;
        };

        // ------- persistence

        this.getHash = function (node) {
            if (node === null) {
                return null;
            }

            var hash;
            node = self.normalize(node);
            if (typeof node.data === 'object' && node.data !== null) {
                hash = node.data[ID_NAME];
            }

            ASSERT(typeof hash === 'string' || hash === undefined);
            return hash;
        };

        this.isHashed = function (node) {
            node = self.normalize(node);
            return typeof node.data === 'object' && node.data !== null && typeof node.data[ID_NAME] === 'string';
        };

        this.setHashed = function (node, hashed, noMutate) {
            ASSERT(typeof hashed === 'boolean');

            node = self.normalize(node);
            if (!noMutate) {
                if (!self.mutate(node)) {
                    throw new Error('incorrect node data');
                }
            }

            if (hashed) {
                node.data[ID_NAME] = '';
            } else {
                delete node.data[ID_NAME];
            }

            ASSERT(node.children[ID_NAME] === undefined);
        };

        this.persist = function (node) {
            var updated = false,
                result;

            node = self.normalize(node);

            //currently there is no reason to call the persist on a non-root object
            node = self.getRoot(node);

            if (!__isMutableData(node.data)) {
                return {rootHash: node.data[ID_NAME], objects: {}};
            }

            updated = __saveData(node.data, node, '');
            if (updated !== __getEmptyData()) {
                result = {};
                result.objects = stackedObjects;
                stackedObjects = {};
                result.rootHash = node.data[ID_NAME];
            } else {
                result = {rootHash: node.data[ID_NAME], objects: {}};
            }

            return result;
        };

        this.loadRoot = function (hash) {
            ASSERT(REGEXP.DB_HASH.test(hash));

            return TASYNC.call(__loadRoot2, storage.loadObject(hash));
        };

        this.loadChild = function (node, relid) {
            ASSERT(self.isValidNode(node));

            node = self.getChild(node, relid);

            if (typeof node.data === 'object') {
                return node.data !== null ? node : null;
            } else if (REGEXP.DB_HASH.test(node.data)) {
                // TODO: this is a hack, we should avoid loading it multiple
                // times
                return TASYNC.call(__loadChild2, node, storage.loadObject(node.data));
            } else {
                return null;
            }
        };

        this.getChildHash = function (node, relid) {
            ASSERT(self.isValidNode(node));

            node = self.getChild(node, relid);

            if (typeof node.data === 'object') {
                return node.data !== null ? self.getHash(node) : null;
            } else if (REGEXP.DB_HASH.test(node.data)) {
                // TODO: this is a hack, we should avoid loading it multiple
                // times
                return node.data;
            } else {
                return null;
            }
        };

        this.loadByPath = function (node, path) {
            ASSERT(self.isValidNode(node));
            ASSERT(path === '' || path.charAt(0) === '/');

            path = path.split('/');
            return __loadDescendantByPath2(node, path, 1);
        };

        // ------- valid -------
        this.isValidNode = function (node) {
            try {
                isValidNodeThrow(node);
                return true;
            } catch (error) {
                logger.error(error.message, {stack: error.stack, node: node});
                return false;
            }
        };

        this.removeChildFromCache = function (node, relid) {
            delete node.children[relid];

            return node;
        };
    }

    return CoreTree;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author mmaroti / https://github.com/mmaroti
 */

define('common/core/metacore',[
    'common/util/assert',
    'common/core/tasync',
    'common/util/canon',
    'common/core/constants'
], function (ASSERT, TASYNC, CANON, CONSTANTS) {
    'use strict';

    var MetaCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MetaCore');

        //<editor-fold=Helper Functions>
        function sameNode(nodeA, nodeB) {
            if (self.getPath(nodeA) === self.getPath(nodeB)) {
                return true;
            }
            return false;
        }

        function getMetaNode(node) {
            return self.getChild(node, CONSTANTS.META_NODE);
        }

        function getMetaChildrenNode(node) {
            return self.getChild(getMetaNode(node), CONSTANTS.META_CHILDREN);
        }

        function getMetaPointerNode(node, name) {
            var meta = getMetaNode(node),
                pointerNames = self.getPointerNames(meta) || [];
            if (pointerNames.indexOf(name) !== -1) {
                return self.getChild(meta, CONSTANTS.META_POINTER_PREFIX + name);
            }
            return null;
        }

        function metaPointerNode(node, name) {
            //this function always gives back a node, use this if you just want to create the node as well
            self.setPointer(getMetaNode(node), name, null);
            return self.getChild(getMetaNode(node), CONSTANTS.META_POINTER_PREFIX + name);
        }

        function getMetaAspectsNode(node) {
            return self.getChild(getMetaNode(node), CONSTANTS.META_ASPECTS);
        }

        function getMetaAspectNode(node, name) {
            var aspectNode = getMetaAspectsNode(node),
                names = self.getPointerNames(aspectNode) || [];
            if (names.indexOf(name) !== -1) {
                return self.getChild(aspectNode, CONSTANTS.META_ASPECT_PREFIX + name);
            }
            return null;
        }

        function metaAspectNode(node, name) {
            //this function always gives back a node, use this if you just want to create the node as well
            var aspectNode = self.getChild(getMetaNode(node), CONSTANTS.META_ASPECTS);

            self.setPointer(aspectNode, name, null);
            return self.getChild(aspectNode, CONSTANTS.META_ASPECT_PREFIX + name);
        }

        function getMetaObjectDiff(bigger, smaller) {
            //TODO this is a specific diff calculation for META rule JSONs
            var diff = {},
                names, i,
                itemedElementDiff = function (bigItem, smallItem) {
                    var diffItems = {},
                        diff, i, index, names;
                    for (i = 0; i < bigItem.items.length; i++) {
                        if (smallItem.items.indexOf(bigItem.items[i]) === -1) {
                            diffItems[bigItem.items[i]] = true;
                        }
                    }
                    names = Object.keys(diffItems);
                    for (i = 0; i < names.length; i++) {
                        diff = diff || {items: [], minItems: [], maxItems: []};
                        index = bigItem.items.indexOf(names[i]);
                        diff.items.push(bigItem.items[index]);
                        diff.minItems.push(bigItem.minItems[index]);
                        diff.maxItems.push(bigItem.maxItems[index]);

                    }
                    if (bigItem.min && ((smallItem.min && bigItem.min !== smallItem.min) || !smallItem.min)) {
                        diff = diff || {};
                        diff.min = bigItem.min;
                    }
                    if (bigItem.max && ((smallItem.max && bigItem.max !== smallItem.max) || !smallItem.max)) {
                        diff = diff || {};
                        diff.max = bigItem.max;
                    }
                    return diff || {};
                };
            //attributes
            if (smaller.attributes) {
                names = Object.keys(bigger.attributes);
                for (i = 0; i < names.length; i++) {
                    if (smaller.attributes[names[i]]) {
                        //they both have the attribute - if it differs we keep the whole of the bigger
                        if (CANON.stringify(smaller.attributes[names[i]]) !==
                            CANON.stringify(bigger.attributes[names[i]])) {

                            diff.attributes = diff.attributes || {};
                            diff.attributes[names[i]] = bigger.attributes[names[i]];
                        }
                    } else {
                        diff.attributes = diff.attributes || {};
                        diff.attributes[names[i]] = bigger.attributes[names[i]];
                    }
                }
            } else if (bigger.attributes) {
                diff.attributes = bigger.attributes;
            }
            //children
            if (smaller.children) {
                diff.children = itemedElementDiff(bigger.children, smaller.children);
                if (Object.keys(diff.children).length < 1) {
                    delete diff.children;
                }
            } else if (bigger.children) {
                diff.children = bigger.children;
            }
            //pointers
            if (smaller.pointers) {
                diff.pointers = {};
                names = Object.keys(bigger.pointers);
                for (i = 0; i < names.length; i++) {
                    if (smaller.pointers[names[i]]) {
                        diff.pointers[names[i]] = itemedElementDiff(bigger.pointers[names[i]],
                            smaller.pointers[names[i]]);
                        if (Object.keys(diff.pointers[names[i]]).length < 1) {
                            delete diff.pointers[names[i]];
                        }
                    } else {
                        diff.pointers[names[i]] = bigger.pointers[names[i]];
                    }
                }
            } else if (bigger.pointers) {
                diff.pointers = bigger.pointers;
            }
            if (Object.keys(diff.pointers).length < 1) {
                delete diff.pointers;
            }
            //aspects
            if (smaller.aspects) {
                diff.aspects = {};
                names = Object.keys(bigger.aspects);
                for (i = 0; i < names.length; i++) {
                    if (smaller.aspects[names[i]]) {
                        smaller.aspects[names[i]] = smaller.aspects[names[i]].sort();
                        bigger.aspects[names[i]] = bigger.aspects[names[i]].sort();
                        if (bigger.aspects[names[i]].length > smaller.aspects[names[i]].length) {
                            diff.aspects[names[i]] = bigger.aspects[names[i]].slice(smaller.aspects[names[i]].length);
                        }
                    } else {
                        diff.aspects[names[i]] = bigger.aspects[names[i]];
                    }
                }
            } else if (bigger.aspects) {
                diff.aspects = bigger.aspects;
            }

            if (Object.keys(diff.aspects).length < 1) {
                delete diff.aspects;
            }
            return diff;
        }

        //type related extra query functions
        function isOnMetaSheet(node) {
            //MetaAspectSet
            var sets = self.isMemberOf(node);

            if (sets && sets[''] && sets[''].indexOf(CONSTANTS.META_SET_NAME) !== -1) {
                return true;
            }
            return false;
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.isTypeOf = function (node, typeNode) {
            while (node) {
                if (sameNode(node, typeNode)) {
                    return true;
                }
                node = self.getBase(node);
            }
            return false;
        };

        this.isValidChildOf = function (node, parentNode) {
            var validChildTypePaths = self.getMemberPaths(getMetaChildrenNode(parentNode), CONSTANTS.SET_ITEMS) || [];
            while (node) {
                if (validChildTypePaths.indexOf(self.getPath(node)) !== -1) {
                    return true;
                }
                node = self.getBase(node);
            }
            return false;
        };

        this.getValidPointerNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getPointerNames(metaDefNode) || [],
                i,
                validPointerNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);
                if (max === 1) {
                    //TODO Specify what makes something a pointer and what a set???
                    //TODO Can you extend a pointer to a set????
                    validPointerNames.push(validNames[i]);
                }
            }

            return validPointerNames;
        };

        this.getOwnValidPointerNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getOwnPointerNames(metaDefNode) || [],
                i,
                validPointerNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getOwnAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);
                if (max === 1) {
                    //TODO Specify what makes something a pointer and what a set???
                    //TODO Can you extend a pointer to a set????
                    validPointerNames.push(validNames[i]);
                }
            }

            return validPointerNames;
        };

        this.getValidSetNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getPointerNames(metaDefNode) || [],
                i,
                validSetNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);

                // FIXME: max seems to always be undefined - there is no such attribute on the set definitions
                if (max === undefined || max === -1 || max > 1) {
                    //TODO specify what makes something a pointer and what a set???
                    //TODO can you extend a pointer to a set????
                    validSetNames.push(validNames[i]);
                }
            }

            return validSetNames;
        };

        this.getOwnValidSetNames = function (node) {
            var metaDefNode = getMetaNode(node),
                validNames = self.getOwnPointerNames(metaDefNode) || [],
                i,
                validSetNames = [],
                metaPointerNode, max;

            for (i = 0; i < validNames.length; i++) {
                metaPointerNode = self.getChild(metaDefNode, CONSTANTS.META_POINTER_PREFIX + validNames[i]);
                max = self.getOwnAttribute(metaPointerNode, CONSTANTS.SET_ITEMS_MAX);

                // FIXME: max seems to always be undefined - there is no such attribute on the set definitions
                if (max === undefined || max === -1 || max > 1) {
                    //TODO specify what makes something a pointer and what a set???
                    //TODO can you extend a pointer to a set????
                    validSetNames.push(validNames[i]);
                }
            }

            return validSetNames;
        };

        this.isValidTargetOf = function (node, source, name) {
            var pointerMetaNode = getMetaPointerNode(source, name);

            if (pointerMetaNode) {
                var validTargetTypePaths = self.getMemberPaths(pointerMetaNode, CONSTANTS.SET_ITEMS) || [];
                while (node) {
                    if (validTargetTypePaths.indexOf(self.getPath(node)) !== -1) {
                        return true;
                    }
                    node = self.getBase(node);
                }
            }
            return false;
        };

        this.getValidAttributeNames = function (node) {
            return self.getAttributeNames(getMetaNode(node)) || [];
        };

        this.getOwnValidAttributeNames = function (node) {
            return self.getOwnAttributeNames(getMetaNode(node)) || [];
        };

        this.isValidAttributeValueOf = function (node, name, value) {
            var typedValue;

            if (self.getValidAttributeNames(node).indexOf(name) === -1) {
                return false;
            }
            var meta = self.getAttribute(getMetaNode(node), name);

            if (meta.enum && meta.enum instanceof Array) {
                return meta.enum.indexOf(value) !== -1; //TODO should we check type beforehand?
            }

            switch (meta.type) {
                case CONSTANTS.ATTRIBUTE_TYPES.BOOLEAN:
                    if (value === true || value === false) {
                        return true;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.STRING:
                    if (typeof value === 'string') {
                        if (meta.regexp) {
                            return (new RegExp(meta.regexp).test(value));
                        }
                        return true;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.ASSET:
                    if (typeof value === 'string') {
                        return true;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.INTEGER:
                    typedValue = parseInt(value);
                    if (!isNaN(typedValue) && parseFloat(value) === typedValue) {
                        if ((typeof meta.min !== 'number' || typedValue >= meta.min) &&
                            (typeof meta.max !== 'number' || typedValue <= meta.max)) {
                            return true;
                        }
                        return false;
                    }
                    break;
                case CONSTANTS.ATTRIBUTE_TYPES.FLOAT:
                    typedValue = parseFloat(value);
                    if (!isNaN(typedValue)) {
                        if ((typeof meta.min !== 'number' || typedValue >= meta.min) &&
                            (typeof meta.max !== 'number' || typedValue <= meta.max)) {
                            return true;
                        }
                        return false;
                    }
                    break;
                default:
                    break;
            }

            return false;
        };

        this.getValidAspectNames = function (node) {
            return self.getPointerNames(getMetaAspectsNode(node)) || [];
        };

        this.getOwnValidAspectNames = function (node) {
            return self.getOwnPointerNames(getMetaAspectsNode(node)) || [];
        };

        this.getAspectMeta = function (node, name) {
            return self.getMemberPaths(getMetaAspectNode(node, name), CONSTANTS.SET_ITEMS);
        };

        //additional meta functions for getting meta definitions
        this.getJsonMeta = function (node) {
            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},
                tempNode,
                names,
                pointer,
                i, j;

            //fill children part
            tempNode = getMetaChildrenNode(node);

            meta.children.minItems = [];
            meta.children.maxItems = [];
            meta.children.items = self.getMemberPaths(tempNode, CONSTANTS.SET_ITEMS);
            for (i = 0; i < meta.children.items.length; i++) {
                meta.children.minItems.push(
                    self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                        CONSTANTS.SET_ITEMS_MIN) || -1);

                meta.children.maxItems.push(
                    self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                        CONSTANTS.SET_ITEMS_MAX) || -1);
            }
            meta.children.min = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MIN);
            meta.children.max = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MAX);

            //attributes
            names = self.getValidAttributeNames(node);
            for (i = 0; i < names.length; i++) {
                meta.attributes[names[i]] = self.getAttribute(getMetaNode(node), names[i]);
            }

            //pointers
            names = self.getPointerNames(getMetaNode(node));
            for (i = 0; i < names.length; i++) {
                tempNode = getMetaPointerNode(node, names[i]);
                pointer = {};

                pointer.items = self.getMemberPaths(tempNode, CONSTANTS.SET_ITEMS);
                pointer.min = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MIN);
                pointer.max = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MAX);
                pointer.minItems = [];
                pointer.maxItems = [];

                for (j = 0; j < pointer.items.length; j++) {
                    pointer.minItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                            CONSTANTS.SET_ITEMS_MIN) || -1);
                    pointer.maxItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                            CONSTANTS.SET_ITEMS_MAX) || -1);

                }

                meta.pointers[names[i]] = pointer;
            }

            //aspects
            names = self.getValidAspectNames(node);

            for (i = 0; i < names.length; i++) {
                tempNode = getMetaAspectNode(node, names[i]);
                meta.aspects[names[i]] = self.getMemberPaths(tempNode, CONSTANTS.SET_ITEMS) || [];
            }

            //constraints
            names = self.getConstraintNames(node);
            for (i = 0; i < names.length; i++) {
                meta.constraints[names[i]] = self.getConstraint(node, names[i]);
            }

            return meta;
        };

        //this.getOwnJsonMeta = function (node) {
        //    var base = self.getBase(node),
        //        baseMeta = base ? self.getJsonMeta(base) : {},
        //        meta = self.getJsonMeta(node);
        //
        //    return getMetaObjectDiff(meta, baseMeta);
        //};

        this.getOwnJsonMeta = function (node) {
            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},
                tempNode,
                metaNode = getMetaNode(node),
                childrenNode = self.getChild(metaNode, CONSTANTS.META_CHILDREN),
                aspectsNode = self.getChild(metaNode, CONSTANTS.META_ASPECTS),
                names,
                pointer,
                i, j;

            //fill children part

            meta.children.minItems = [];
            meta.children.maxItems = [];
            meta.children.items = self.getOwnMemberPaths(childrenNode, CONSTANTS.SET_ITEMS);
            if (meta.children.items.length > 0) {
                for (i = 0; i < meta.children.items.length; i++) {
                    meta.children.minItems.push(
                        self.getMemberAttribute(childrenNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                            CONSTANTS.SET_ITEMS_MIN) || -1);

                    meta.children.maxItems.push(
                        self.getMemberAttribute(childrenNode, CONSTANTS.SET_ITEMS, meta.children.items[i],
                            CONSTANTS.SET_ITEMS_MAX) || -1);
                }
                names = self.getOwnAttributeNames(childrenNode);
                if (names.indexOf('min') !== -1) {
                    meta.children.min = self.getAttribute(childrenNode, CONSTANTS.SET_ITEMS_MIN);
                }
                if (names.indexOf('max') !== -1) {
                    meta.children.max = self.getAttribute(childrenNode, CONSTANTS.SET_ITEMS_MAX);
                }
            } else {
                delete meta.children;
            }
            //attributes
            names = self.getOwnAttributeNames(metaNode) || [];
            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    meta.attributes[names[i]] = self.getOwnAttribute(metaNode, names[i]);
                }
            } else {
                delete meta.attributes;
            }

            //pointers
            names = self.getOwnPointerNames(metaNode);
            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    tempNode = self.getChild(metaNode, CONSTANTS.META_POINTER_PREFIX + names[i]);
                    pointer = {};

                    pointer.items = self.getOwnMemberPaths(tempNode, CONSTANTS.SET_ITEMS);
                    pointer.min = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MIN);
                    pointer.max = self.getAttribute(tempNode, CONSTANTS.SET_ITEMS_MAX);
                    pointer.minItems = [];
                    pointer.maxItems = [];

                    for (j = 0; j < pointer.items.length; j++) {
                        pointer.minItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                                CONSTANTS.SET_ITEMS_MIN) || -1);
                        pointer.maxItems.push(self.getMemberAttribute(tempNode, CONSTANTS.SET_ITEMS, pointer.items[j],
                                CONSTANTS.SET_ITEMS_MAX) || -1);

                    }

                    meta.pointers[names[i]] = pointer;
                }
            } else {
                delete meta.pointers;
            }

            //aspects
            names = self.getOwnPointerNames(aspectsNode) || [];

            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    tempNode = self.getChild(aspectsNode, CONSTANTS.META_ASPECT_PREFIX + names[i]);
                    meta.aspects[names[i]] = self.getOwnMemberPaths(tempNode, CONSTANTS.SET_ITEMS) || [];
                }
            } else {
                delete meta.aspects;
            }

            //constraints
            names = self.getOwnConstraintNames(node);

            if (names.length > 0) {
                for (i = 0; i < names.length; i++) {
                    meta.constraints[names[i]] = self.getConstraint(node, names[i]);
                }
            } else {
                delete meta.constraints;
            }

            return meta;
        };

        this.clearMetaRules = function (node) {
            self.deleteNode(getMetaNode(node), true);
        };

        this.setAttributeMeta = function (node, name, value) {
            ASSERT(typeof value === 'object' && typeof name === 'string' && name);
            var defaultValue;

            if (value.hasOwnProperty('default')) {
                defaultValue = value.default;
                value = JSON.parse(JSON.stringify(value));
                delete value.default;
            }

            self.setAttribute(getMetaNode(node), name, value);

            if (typeof defaultValue !== 'undefined') {
                self.setAttribute(node, name, defaultValue);
            }
        };

        this.delAttributeMeta = function (node, name) {
            self.delAttribute(getMetaNode(node), name);
        };

        this.getAttributeMeta = function (node, name) {
            return self.getAttribute(getMetaNode(node), name);
        };

        this.getValidChildrenPaths = function (node) {
            return self.getMemberPaths(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS);
        };

        this.getOwnValidChildrenPaths = function (node) {
            return self.getOwnMemberPaths(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS);
        };

        this.getChildrenMeta = function (node) {
            var cMetaNode = getMetaChildrenNode(node),
                childrenMeta = {
                    min: self.getAttribute(cMetaNode, CONSTANTS.SET_ITEMS_MIN),
                    max: self.getAttribute(cMetaNode, CONSTANTS.SET_ITEMS_MAX)
                },
                paths = self.getMemberPaths(cMetaNode, CONSTANTS.SET_ITEMS),
                i;

            for (i = 0; i < paths.length; i += 1) {
                childrenMeta[paths[i]] = {
                    min: self.getMemberAttribute(cMetaNode, CONSTANTS.SET_ITEMS, paths[i], CONSTANTS.SET_ITEMS_MIN),
                    max: self.getMemberAttribute(cMetaNode, CONSTANTS.SET_ITEMS, paths[i], CONSTANTS.SET_ITEMS_MAX)
                };
            }

            if (paths.length > 0) {
                return childrenMeta;
            }

            return null;
        };

        this.setChildMeta = function (node, child, min, max) {
            self.addMember(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, child);
            min = min || -1;
            max = max || -1;
            self.setMemberAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, self.getPath(child),
                CONSTANTS.SET_ITEMS_MIN, min);
            self.setMemberAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, self.getPath(child),
                CONSTANTS.SET_ITEMS_MAX, max);
        };

        this.delChildMeta = function (node, childPath) {
            self.delMember(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS, childPath);
        };

        this.setChildrenMetaLimits = function (node, min, max) {
            if (min) {
                self.setAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS_MIN, min);
            }
            if (max) {
                self.setAttribute(getMetaChildrenNode(node), CONSTANTS.SET_ITEMS_MAX, max);
            }
        };

        this.setPointerMetaTarget = function (node, name, target, min, max) {
            self.addMember(metaPointerNode(node, name), CONSTANTS.SET_ITEMS, target);
            min = min || -1;
            self.setMemberAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS, self.getPath(target),
                CONSTANTS.SET_ITEMS_MIN, min);
            max = max || -1;
            self.setMemberAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS, self.getPath(target),
                CONSTANTS.SET_ITEMS_MAX, max);
        };

        this.delPointerMetaTarget = function (node, name, targetPath) {
            var metaNode = getMetaPointerNode(node, name);
            if (metaNode) {
                self.delMember(metaNode, CONSTANTS.SET_ITEMS, targetPath);
            }
        };

        this.setPointerMetaLimits = function (node, name, min, max) {
            if (min) {
                self.setAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS_MIN, min);
            }
            if (max) {
                self.setAttribute(metaPointerNode(node, name), CONSTANTS.SET_ITEMS_MAX, max);
            }
        };

        this.delPointerMeta = function (node, name) {
            self.deleteNode(metaPointerNode(node, name), true);
            self.deletePointer(getMetaNode(node), name);
        };

        this.getPointerMeta = function (node, name) {
            var pointerMeta = {},
                members,
                member,
                i,
                pointerMetaNode = getMetaPointerNode(node, name);

            if (pointerMetaNode === null) {
                return null;
            }

            //min
            pointerMeta.min = self.getAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS_MIN);
            if (pointerMeta.min === undefined) {
                pointerMeta.min = -1;
            }

            //max
            pointerMeta.max = self.getAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS_MAX);
            if (pointerMeta.max === undefined) {
                pointerMeta.max = -1;
            }

            members = self.getMemberPaths(pointerMetaNode, CONSTANTS.SET_ITEMS);
            for (i = 0; i < members.length; i++) {
                member = {
                    min: self.getMemberAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS, members[i],
                        CONSTANTS.SET_ITEMS_MIN),
                    max: self.getMemberAttribute(pointerMetaNode, CONSTANTS.SET_ITEMS, members[i],
                        CONSTANTS.SET_ITEMS_MAX)
                };
                if (member.min === undefined) {
                    member.min = -1;
                }
                if (member.max === undefined) {
                    member.max = -1;
                }

                pointerMeta[members[i]] = member;
            }

            return pointerMeta;
        };

        this.getValidTargetPaths = function (node, name) {
            var pointerNode = getMetaPointerNode(node, name);
            if (pointerNode === null) {
                return [];
            }
            return self.getMemberPaths(pointerNode, CONSTANTS.SET_ITEMS);
        };

        this.getOwnValidTargetPaths = function (node, name) {
            var pointerNode = getMetaPointerNode(node, name);
            if (pointerNode === null) {
                return [];
            }
            return self.getOwnMemberPaths(pointerNode, CONSTANTS.SET_ITEMS);
        };

        this.setAspectMetaTarget = function (node, name, target) {
            self.addMember(metaAspectNode(node, name), CONSTANTS.SET_ITEMS, target);
        };

        this.delAspectMetaTarget = function (node, name, targetPath) {
            var metaNode = getMetaAspectNode(node, name);
            if (metaNode) {
                self.delMember(metaNode, CONSTANTS.SET_ITEMS, targetPath);
            }
        };

        this.delAspectMeta = function (node, name) {
            self.deleteNode(metaAspectNode(node, name), true);
            self.deletePointer(getMetaAspectsNode(node), name);
        };

        this.getBaseType = function (node) {
            //TODO this functions now uses the fact that we think of META as the MetaSetContainer of the ROOT
            while (node) {
                if (isOnMetaSheet(node)) {
                    return node;
                }
                node = self.getBase(node);
            }
            return null;
        };

        this.isInstanceOf = function (node, name) {
            //TODO this is name based query - doesn't check the node's own name
            node = self.getBase(node);
            while (node) {
                if (self.getAttribute(node, 'name') === name) {
                    return true;
                }
                node = self.getBase(node);
            }

            return false;
        };
        //</editor-fold>
    };

    return MetaCore;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/coretreeloader',['common/util/assert', 'common/core/tasync'], function (ASSERT, TASYNC) {
    'use strict';

    var CoreTreeLoader = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized CoreTreeLoader');

        //<editor-fold=Helper Functions>
        function loadSubTree(root, own) {
            var loadSubTrees = function (nodes) {
                    for (var i = 0; i < nodes.length; i++) {
                        nodes[i] = self.loadSubTree(nodes[i], own);
                    }
                    return TASYNC.lift(nodes);

                },
                childLoading = own === true ? self.loadOwnChildren : self.loadChildren;
            return TASYNC.call(function (children) {
                if (children.length < 1) {
                    return [root];
                } else {
                    return TASYNC.call(function (subArrays) {
                        var nodes = [],
                            i;
                        for (i = 0; i < subArrays.length; i++) {
                            nodes = nodes.concat(subArrays[i]);
                        }
                        nodes.unshift(root);
                        return nodes;
                    }, loadSubTrees(children));
                }
            }, childLoading(root));
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.loadTree = function (rootHash) {
            return TASYNC.call(self.loadSubTree, self.loadRoot(rootHash));
        };

        this.loadSubTree = function (root) {
            return loadSubTree(root, false);
        };

        this.loadOwnSubTree = function (root) {
            return loadSubTree(root, true);
        };

        function traverse(root, options, visitFn, callback) {
            ASSERT(self.isValidNode(root) && typeof visitFn === 'function' && typeof callback === 'function');

            var loadQueue = [],
                ongoingVisits = 0,
                error = null,
                projectRoot = self.getRoot(root),
                timerId,
                addToQueue,
                loadByPath = TASYNC.unwrap(self.loadByPath),
                extendLoadQueue = function (node) {
                    var keys = self.getChildrenPaths(node),
                        i;

                    if (self.getPath(node) !== self.getPath(root)) {
                        for (i = 0; i < keys.length; i += 1) {
                            addToQueue.call(loadQueue, keys[i]);
                        }
                    }

                },
                nodeLoaded = function (err, node) {
                    error = error || err;
                    if (!err && node) {
                        extendLoadQueue(node);
                    }
                    visitFn(node, visitNext);
                },
                visitNext = function (err) {
                    error = error || err;
                    ongoingVisits -= 1;
                    if (error && options.stopOnError) {
                        loadQueue = [];
                    }
                };

            options = options || {};
            options.maxParallelLoad = options.maxParallelLoad || 100; //the amount of nodes we preload
            options.excludeRoot = options.excludeRoot === true || false;
            options.stopOnError = options.stopOnError === false ? false : true;

            if (options.order === 'DFS') {
                addToQueue = loadQueue.unshift;
            } else {
                addToQueue = loadQueue.push;
            }

            if (options.maxParallelLoad < 1 || options.order === 'DFS') {
                options.maxParallelLoad = 1;
            }

            loadQueue = self.getChildrenPaths(root);

            if (options.excludeRoot === false) {
                loadQueue.unshift(self.getPath(root));
            }

            timerId = setInterval(function () {
                if (loadQueue.length === 0 && ongoingVisits === 0) {
                    clearInterval(timerId);
                    callback(error);
                } else if (loadQueue.length > 0 && ongoingVisits < options.maxParallelLoad &&
                    (!error || options.stopOnError === false)) {
                    ongoingVisits += 1;
                    loadByPath(projectRoot, loadQueue.shift(), nodeLoaded);
                }
            }, 0);

        }

        this.traverse = TASYNC.wrap(traverse);
        //</editor-fold>
    };

    return CoreTreeLoader;
});

/*globals define*/
/*jshint node: true, browser: true*/

// TODO: This files needs refactoring

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/corediff',['common/util/canon',
    'common/core/tasync',
    'common/util/assert',
    'common/regexp',
    'common/util/random',
    'common/core/constants',
], function (CANON, TASYNC, ASSERT, REGEXP, RANDOM, CONSTANTS) {
    'use strict';

    function DiffCore(innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key,
            //FIXME: There shouldn't be state.
            _yetToCompute = {},
            _DIFF = {},
            _needChecking = true,
            _rounds = 0,
            _concatResult,
            _diffMoves = {},
            _conflictItems = [],
            _conflictMine,
            _conflictTheirs,
            _concatBase,
            _concatExtension,
            _concatBaseRemovals,
            _concatMoves;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized DiffCore');

        //<editor-fold=Helper Functions>
        function normalize(obj) {
            if (!obj) {
                return obj;
            }
            var keys = Object.keys(obj),
                i;
            if (JSON.stringify(obj.set) === JSON.stringify({})) {
                delete obj.set;
            }

            for (i = 0; i < keys.length; i++) {
                /*if (Array.isArray(obj[keys[i]])) {
                 if (obj[keys[i]].length === 0) {
                 delete obj[keys[i]];
                 }*/
                if (Array.isArray(obj[keys[i]])) {
                    //do nothing, leave the array as is
                } else if (obj[keys[i]] === undefined) {
                    delete obj[keys[i]]; //there cannot be undefined in the object
                } else if (keys[i] === 'set') {
                    //do nothing with set as it can include empty set's as well
                } else if (typeof obj[keys[i]] === 'object') {
                    normalize(obj[keys[i]]);
                    if (obj[keys[i]] && Object.keys(obj[keys[i]]).length === 0) {
                        delete obj[keys[i]];
                    }
                }
            }
            keys = Object.keys(obj);
            if (keys.length === 1) {
                //it only has the GUID, so the node doesn't changed at all
                delete obj.guid;
            }
        }

        function attrDiff(source, target) {
            var sNames = self.getOwnAttributeNames(source),
                tNames = self.getOwnAttributeNames(target),
                i,
                diff = {};

            for (i = 0; i < sNames.length; i++) {
                if (tNames.indexOf(sNames[i]) === -1) {
                    diff[sNames[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }

            for (i = 0; i < tNames.length; i++) {
                if (self.getAttribute(source, tNames[i]) === undefined) {
                    diff[tNames[i]] = self.getAttribute(target, tNames[i]);
                } else {
                    if (CANON.stringify(self.getAttribute(source, tNames[i])) !==
                        CANON.stringify(self.getAttribute(target, tNames[i]))) {

                        diff[tNames[i]] = self.getAttribute(target, tNames[i]);
                    }
                }
            }

            return diff;
        }

        function regDiff(source, target) {
            var sNames = self.getOwnRegistryNames(source),
                tNames = self.getOwnRegistryNames(target),
                i,
                diff = {};

            for (i = 0; i < sNames.length; i++) {
                if (tNames.indexOf(sNames[i]) === -1) {
                    diff[sNames[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }

            for (i = 0; i < tNames.length; i++) {
                if (self.getRegistry(source, tNames[i]) === undefined) {
                    diff[tNames[i]] = self.getRegistry(target, tNames[i]);
                } else {
                    if (CANON.stringify(self.getRegistry(source, tNames[i])) !==
                        CANON.stringify(self.getRegistry(target, tNames[i]))) {

                        diff[tNames[i]] = self.getRegistry(target, tNames[i]);
                    }
                }
            }

            return diff;
        }

        function childrenDiff(source, target) {
            var sRelids = self.getChildrenRelids(source, true),
                tRelids = self.getChildrenRelids(target, true),
                tHashes = self.getChildrenHashes(target),
                sHashes = self.getChildrenHashes(source),
                relid,
                diff = {added: [], removed: []};

            for (relid in sRelids) {
                if (tRelids.hasOwnProperty(relid) === false) {
                    diff.removed.push({relid: relid, hash: sHashes[relid]});
                }
            }

            for (relid in tRelids) {
                if (sRelids.hasOwnProperty(relid) === false) {
                    diff.added.push({relid: relid, hash: tHashes[relid]});
                }
            }

            return diff;

        }

        function pointerDiff(source, target) {
            var getPointerData = function (node) {
                    var data = {},
                        names = self.getPointerNames(node),
                        i;
                    for (i = 0; i < names.length; i++) {
                        data[names[i]] = self.getPointerPath(node, names[i]);
                    }
                    return data;
                },
                sPointer = getPointerData(source),
                tPointer = getPointerData(target);

            if (CANON.stringify(sPointer) !== CANON.stringify(tPointer)) {
                return {source: sPointer, target: tPointer};
            }
            return {};
        }

        function setDiff(source, target) {
            var getSetData = function (node) {
                    var data = {},
                        names, targets, keys, i, j, k;

                    names = self.getSetNames(node);
                    for (i = 0; i < names.length; i++) {
                        data[names[i]] = {};
                        targets = self.getMemberPaths(node, names[i]);
                        for (j = 0; j < targets.length; j++) {
                            data[names[i]][targets[j]] = {attr: {}, reg: {}};
                            keys = self.getMemberOwnAttributeNames(node, names[i], targets[j]);
                            for (k = 0; k < keys.length; k++) {
                                data[names[i]][targets[j]].attr[keys[k]] = self.getMemberAttribute(node,
                                    names[i], targets[j], keys[k]);
                            }
                            keys = self.getMemberRegistryNames(node, names[i], targets[j]);
                            for (k = 0; k < keys.length; k++) {
                                data[names[i]][targets[j]].reg[keys[k]] = self.getMemberRegistry(node,
                                    names[i], targets[j], keys[k]);
                            }
                        }
                    }

                    return data;

                },
                sSet = getSetData(source),
                tSet = getSetData(target);

            if (CANON.stringify(sSet) !== CANON.stringify(tSet)) {
                return {source: sSet, target: tSet};
            }
            return {};
        }

        function ovrDiff(source, target) {
            var getOvrData = function (node) {
                    var paths, names, i, j,
                        ovr = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY) || {},
                        data = {},
                        base = self.getPath(node);

                    paths = Object.keys(ovr);
                    for (i = 0; i < paths.length; i++) {
                        if (paths[i].indexOf('_') === -1) {
                            data[paths[i]] = {};
                            names = Object.keys(ovr[paths[i]]);
                            for (j = 0; j < names.length; j++) {
                                if (ovr[paths[i]][names[j]] === '/_nullptr') {
                                    data[paths[i]][names[j]] = null;
                                } else if (names[j].slice(-4) !== '-inv' && names[j].indexOf('_') === -1 &&
                                    ovr[paths[i]][names[j]].indexOf('_') === -1) {
                                    data[paths[i]][names[j]] = self.joinPaths(base, ovr[paths[i]][names[j]]);
                                }
                            }
                        }
                    }
                    return data;
                },
                sOvr = getOvrData(source),
                tOvr = getOvrData(target);

            if (CANON.stringify(sOvr) !== CANON.stringify(tOvr)) {
                return {source: sOvr, target: tOvr};
            }
            return {};
        }

        function metaDiff(source, target) {
            //TODO jsonMeta format should be changed in all places!!!
            var convertJsonMeta = function (jsonMeta) {
                    var i, j, names, itemsObject;
                    //children
                    if (jsonMeta.children) {
                        itemsObject = jsonMeta.children;
                        for (i = 0; i < itemsObject.items.length; i += 1) {
                            itemsObject[itemsObject.items[i]] = {
                                min: itemsObject.minItems[i],
                                max: itemsObject.maxItems[i]
                            };
                        }
                        delete itemsObject.items;
                        delete itemsObject.minItems;
                        delete itemsObject.maxItems;
                    }
                    //ptr
                    if (jsonMeta.pointers) {
                        names = Object.keys(jsonMeta.pointers);

                        for (j = 0; j < names.length; j += 1) {
                            itemsObject = jsonMeta.pointers[names[j]];
                            for (i = 0; i < itemsObject.items.length; i += 1) {
                                itemsObject[itemsObject.items[i]] = {
                                    min: itemsObject.minItems[i],
                                    max: itemsObject.maxItems[i]
                                };
                            }
                            delete itemsObject.items;
                            delete itemsObject.minItems;
                            delete itemsObject.maxItems;
                        }
                    }
                    return jsonMeta;
                },
                sMeta = convertJsonMeta(self.getOwnJsonMeta(source)),
                tMeta = convertJsonMeta(self.getOwnJsonMeta(target));
            if (CANON.stringify(sMeta) !== CANON.stringify(tMeta)) {
                return {source: sMeta, target: tMeta};
            }
            return {};
        }

        function combineMoveIntoMetaDiff(diff) {
            var keys = Object.keys(diff),
                i;
            for (i = 0; i < keys.length; i++) {
                if (_diffMoves[keys[i]]) {
                    diff[_diffMoves[keys[i]]] = diff[keys[i]];
                    delete diff[keys[i]];
                } else if (typeof diff[keys[i]] === 'object') {
                    combineMoveIntoMetaDiff(diff[keys[i]]);
                }
            }
        }

        function combineMoveIntoPointerDiff(diff) {
            var keys = Object.keys(diff),
                i;
            for (i = 0; i < keys.length; i++) {
                if (_diffMoves[diff[keys[i]]]) {
                    diff[keys[i]] = _diffMoves[diff[keys[i]]];
                }
            }
        }

        function finalizeDiff() {
            finalizeMetaDiff(_DIFF);
            finalizePointerDiff(_DIFF);
            finalizeSetDiff(_DIFF);
            normalize(_DIFF);
        }

        function finalizeMetaDiff(diff) {
            //at this point _DIFF is ready and the _diffMoves is complete...
            var relids = getDiffChildrenRelids(diff),
                i, sMeta, tMeta;
            if (diff.meta) {
                sMeta = diff.meta.source || {};
                tMeta = diff.meta.target || {};
                combineMoveIntoMetaDiff(sMeta);
                diff.meta = diffObjects(sMeta, tMeta);
            }
            for (i = 0; i < relids.length; i++) {
                finalizeMetaDiff(diff[relids[i]]);
            }
        }

        function finalizePointerDiff(diff) {
            var relids = getDiffChildrenRelids(diff),
                i, sPointer, tPointer;
            if (diff.pointer) {
                sPointer = diff.pointer.source || {};
                tPointer = diff.pointer.target || {};
                /*if(diff.movedFrom && !sPointer.base && tPointer.base){
                 delete tPointer.base;
                 }*/
                combineMoveIntoPointerDiff(sPointer);
                diff.pointer = diffObjects(sPointer, tPointer);
            }
            for (i = 0; i < relids.length; i++) {
                finalizePointerDiff(diff[relids[i]]);
            }
        }

        function finalizeSetDiff(diff) {
            var relids = getDiffChildrenRelids(diff),
                i, sSet, tSet;
            if (diff.set) {
                sSet = diff.set.source || {};
                tSet = diff.set.target || {};
                combineMoveIntoMetaDiff(sSet);
                diff.set = diffObjects(sSet, tSet);
            }
            for (i = 0; i < relids.length; i++) {
                finalizeSetDiff(diff[relids[i]]);
            }
        }

        function isEmptyNodeDiff(diff) {
            if (
                Object.keys(diff.children || {}).length > 0 ||
                Object.keys(diff.attr || {}).length > 0 ||
                Object.keys(diff.reg || {}).length > 0 ||
                Object.keys(diff.pointer || {}).length > 0 ||
                Object.keys(diff.set || {}).length > 0 ||
                diff.meta
            ) {
                return false;
            }
            return true;
        }

        function getPathOfDiff(diff, path) {
            var pathArray = path.split('/'),
                i;
            pathArray.shift();
            for (i = 0; i < pathArray.length; i++) {
                diff[pathArray[i]] = diff[pathArray[i]] || {};
                diff = diff[pathArray[i]];
            }

            return diff;
        }

        function extendDiffWithOvr(diff, oDiff) {
            var i, paths, names, j, tDiff,
                onlyBaseRemoved = function (path) {
                    var sCopy = JSON.parse(JSON.stringify(oDiff.source[path] || {})),
                        tCopy = JSON.parse(JSON.stringify(oDiff.target[path] || {}));

                    if (tCopy['base']) {
                        return false;
                    }

                    delete sCopy['base'];

                    return CANON.stringify(sCopy) === CANON.stringify(tCopy);
                };

            //first extend sources
            paths = Object.keys(oDiff.source || {});
            for (i = 0; i < paths.length; i++) {
                tDiff = getPathOfDiff(diff, paths[i]);
                if (tDiff.removed !== true && !onlyBaseRemoved(paths[i])) {
                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};
                    tDiff.pointer.source = tDiff.pointer.source || {};
                    tDiff.pointer.target = tDiff.pointer.target || {};
                    names = Object.keys(oDiff.source[paths[i]]);
                    for (j = 0; j < names.length; j++) {
                        tDiff.pointer.source[names[j]] = oDiff.source[paths[i]][names[j]];
                    }
                }
            }
            //then targets
            paths = Object.keys(oDiff.target || {});
            for (i = 0; i < paths.length; i++) {
                tDiff = getPathOfDiff(diff, paths[i]);
                if (tDiff.removed !== true && !onlyBaseRemoved(paths[i])) {
                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};
                    names = Object.keys(oDiff.target[paths[i]]);
                    for (j = 0; j < names.length; j++) {
                        tDiff.pointer.target[names[j]] = oDiff.target[paths[i]][names[j]];
                    }
                }
            }
        }

        function updateDiff(sourceRoot, targetRoot) {
            var diff = self.nodeDiff(sourceRoot, targetRoot) || {},
                oDiff = ovrDiff(sourceRoot, targetRoot),
                getChild = function (childArray, relid) {
                    for (var i = 0; i < childArray.length; i++) {
                        if (self.getRelid(childArray[i]) === relid) {
                            return childArray[i];
                        }
                    }
                    return null;
                };
            return TASYNC.call(function (sChildren, tChildren) {
                ASSERT(sChildren.length >= 0 && tChildren.length >= 0);
                function compareRelids(a, b) {
                    var aRel = self.getRelid(a),
                        bRel = self.getRelid(b);

                    if (aRel < bRel) {
                        return -1;
                    } else if (aRel > bRel) {
                        return 1;
                    } else {
                        return 0;
                    }
                }

                sChildren.sort(compareRelids);
                tChildren.sort(compareRelids);

                var i, child, done, tDiff, guid, base,
                    childComputationFinished = function (cDiff, relid/*, d*/) {
                        diff[relid] = cDiff;
                        return null;
                    };

                tDiff = diff.children ? diff.children.removed || [] : [];
                for (i = 0; i < tDiff.length; i++) {
                    diff.childrenListChanged = true;
                    child = getChild(sChildren, tDiff[i].relid);
                    if (child) {
                        guid = self.getGuid(child);
                        diff[tDiff[i].relid] = {guid: guid, removed: true, hash: self.getHash(child)};
                        _yetToCompute[guid] = _yetToCompute[guid] || {};
                        _yetToCompute[guid].from = child;
                        _yetToCompute[guid].fromExpanded = false;
                    }
                }

                tDiff = diff.children ? diff.children.added || [] : [];
                for (i = 0; i < tDiff.length; i++) {
                    diff.childrenListChanged = true;
                    child = getChild(tChildren, tDiff[i].relid);
                    if (child) {
                        guid = self.getGuid(child);
                        base = self.getBase(child);
                        diff[tDiff[i].relid] = {
                            guid: guid,
                            removed: false,
                            hash: self.getHash(child),
                            pointer: {source: {}, target: {base: base === null ? null : self.getPath(base)}}
                        };
                        _yetToCompute[guid] = _yetToCompute[guid] || {};
                        _yetToCompute[guid].to = child;
                        _yetToCompute[guid].toExpanded = false;
                    }
                }

                for (i = 0; i < tChildren.length; i++) {
                    child = getChild(sChildren, self.getRelid(tChildren[i]));
                    if (child && self.getHash(tChildren[i]) !== self.getHash(child)) {
                        done = TASYNC.call(childComputationFinished,
                            updateDiff(child, tChildren[i]), self.getRelid(child), done);
                    }
                }
                return TASYNC.call(function () {
                    delete diff.children;
                    extendDiffWithOvr(diff, oDiff);

                    normalize(diff);

                    if (Object.keys(diff).length > 0) {
                        diff.guid = self.getGuid(targetRoot);
                        diff.hash = self.getHash(targetRoot);
                        diff.oGuids = gatherObstructiveGuids(targetRoot);
                        return TASYNC.call(function (finalDiff) {
                            return finalDiff;
                        }, fillMissingGuid(targetRoot, sourceRoot, '', diff));
                    } else {
                        return diff;
                    }

                }, done);
            }, self.loadChildren(sourceRoot), self.loadChildren(targetRoot));
        }

        function gatherObstructiveGuids(node) {
            var result = {},
                putParents = function (n) {
                    while (n) {
                        result[self.getGuid(n)] = true;
                        n = self.getParent(n);
                    }
                };
            while (node) {
                putParents(node);
                node = self.getBase(node);
            }
            return result;
        }

        function fillMissingGuid(root, sRoot, path, diff) {
            var relids = getDiffChildrenRelids(diff),
                i,
                done,
                subComputationFinished = function (cDiff, relid) {
                    diff[relid] = cDiff;
                    return null;
                };

            for (i = 0; i < relids.length; i++) {
                done = TASYNC.call(subComputationFinished,
                    fillMissingGuid(root, sRoot, path + '/' + relids[i], diff[relids[i]]), relids[i]);
            }

            return TASYNC.call(function () {
                // if (diff.guid) {
                //     return diff;
                // } else {
                //     return TASYNC.call(function (child) {
                //         diff.guid = self.getGuid(child);
                //         diff.hash = self.getHash(child);
                //         diff.oGuids = gatherObstructiveGuids(child);
                //         return diff;
                //     }, self.loadByPath(root, path));
                // }
                return TASYNC.call(function (child, sChild) {
                    if (!child) {
                        child = sChild;
                    }
                    diff.guid = self.getGuid(child);
                    diff.hash = self.getHash(child);
                    diff.oGuids = gatherObstructiveGuids(child);
                    return diff;
                }, self.loadByPath(root, path), self.loadByPath(sRoot, path));
            }, done);
        }

        function expandDiff(root, isDeleted) {
            var diff = {
                guid: self.getGuid(root),
                hash: self.getHash(root),
                removed: isDeleted === true
            };
            return TASYNC.call(function (children) {
                var guid;
                for (var i = 0; i < children.length; i++) {
                    guid = self.getGuid(children[i]);
                    diff[self.getRelid(children[i])] = {
                        guid: guid,
                        hash: self.getHash(children[i]),
                        removed: isDeleted === true
                    };

                    if (isDeleted) {
                        _yetToCompute[guid] = _yetToCompute[guid] || {};
                        _yetToCompute[guid].from = children[i];
                        _yetToCompute[guid].fromExpanded = false;
                    } else {
                        _yetToCompute[guid] = _yetToCompute[guid] || {};
                        _yetToCompute[guid].to = children[i];
                        _yetToCompute[guid].toExpanded = false;
                    }
                }
                return diff;
            }, self.loadChildren(root));
        }

        function insertIntoDiff(path, diff) {
            var pathArray = path.split('/'),
                relid = pathArray.pop(),
                sDiff = _DIFF,
                i;
            pathArray.shift();
            for (i = 0; i < pathArray.length; i++) {
                sDiff = sDiff[pathArray[i]];
            }
            //sDiff[relid] = diff;
            sDiff[relid] = mergeObjects(sDiff[relid], diff);
        }

        function diffObjects(source, target) {
            var diff = {},
                sKeys = Object.keys(source),
                tKeys = Object.keys(target),
                tDiff, i;
            for (i = 0; i < sKeys.length; i++) {
                if (tKeys.indexOf(sKeys[i]) === -1) {
                    diff[sKeys[i]] = CONSTANTS.TO_DELETE_STRING;
                }
            }
            for (i = 0; i < tKeys.length; i++) {
                if (sKeys.indexOf(tKeys[i]) === -1) {
                    diff[tKeys[i]] = target[tKeys[i]];
                } else {
                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&
                        typeof target[tKeys[i]] === 'object' &&
                        (target[tKeys[i]] !== null && source[tKeys[i]] !== null)) {
                        tDiff = diffObjects(source[tKeys[i]], target[tKeys[i]]);
                        if (Object.keys(tDiff).length > 0) {
                            diff[tKeys[i]] = tDiff;
                        }
                    } else if (source[tKeys[i]] !== target[tKeys[i]]) {
                        diff[tKeys[i]] = target[tKeys[i]];
                    }
                }
            }
            return diff;
        }

        function mergeObjects(source, target) {
            var merged = {},
                sKeys = Object.keys(source),
                tKeys = Object.keys(target),
                i;
            for (i = 0; i < sKeys.length; i++) {
                merged[sKeys[i]] = source[sKeys[i]];
            }
            for (i = 0; i < tKeys.length; i++) {
                if (sKeys.indexOf(tKeys[i]) === -1) {
                    merged[tKeys[i]] = target[tKeys[i]];
                } else {
                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&
                        typeof target[tKeys[i]] === 'object' && !(target instanceof Array)) {
                        merged[tKeys[i]] = mergeObjects(source[tKeys[i]], target[tKeys[i]]);
                    } else {
                        merged[tKeys[i]] = target[tKeys[i]];
                    }
                }
            }

            return merged;
        }

        function removePathFromDiff(diff, path) {
            var relId, i, pathArray;
            if (path === '') {
                diff = null;
            } else {
                pathArray = path.split('/');
                pathArray.shift();
                relId = pathArray.pop();
                for (i = 0; i < pathArray.length; i++) {
                    diff = diff[pathArray[i]];
                }
                delete diff[relId];
            }
        }

        function shrinkDiff(rootDiff) {
            var _shrink = function (diff) {
                if (diff) {
                    var keys = getDiffChildrenRelids(diff),
                        i;
                    if (typeof diff.movedFrom === 'string') {
                        removePathFromDiff(rootDiff, diff.movedFrom);
                    }

                    if (diff.removed !== false || typeof diff.movedFrom === 'string') {
                        delete diff.hash;
                    }

                    if (diff.removed === true) {
                        for (i = 0; i < keys.length; i++) {
                            delete diff[keys[i]];
                        }
                    } else {

                        for (i = 0; i < keys.length; i++) {
                            _shrink(diff[keys[i]]);
                        }
                    }
                }
            };
            _shrink(rootDiff);
        }

        function checkRound() {
            var guids = Object.keys(_yetToCompute),
                done, ytc,
                i,
                computingMove = function (mDiff, info) {
                    mDiff.guid = self.getGuid(info.from);
                    mDiff.movedFrom = self.getPath(info.from);
                    mDiff.ooGuids = gatherObstructiveGuids(info.from);
                    _diffMoves[self.getPath(info.from)] = self.getPath(info.to);
                    insertAtPath(_DIFF, self.getPath(info.to), mDiff);
                    return null;
                },
                expandFrom = function (mDiff, info) {
                    mDiff.hash = self.getHash(info.from);
                    mDiff.removed = true;
                    insertIntoDiff(self.getPath(info.from), mDiff);
                    return null;
                },
                expandTo = function (mDiff, info) {
                    if (!mDiff.hash) {
                        mDiff.hash = self.getHash(info.to);
                    }
                    mDiff.removed = false;
                    insertIntoDiff(self.getPath(info.to), mDiff);
                    return null;
                };

            if (_needChecking !== true || guids.length < 1) {
                shrinkDiff(_DIFF);
                finalizeDiff();
                return JSON.parse(JSON.stringify(_DIFF));
            }

            _needChecking = false;
            for (i = 0; i < guids.length; i++) {
                ytc = _yetToCompute[guids[i]];
                if (ytc.from && ytc.to) {
                    //move
                    _needChecking = true;
                    delete _yetToCompute[guids[i]];
                    done = TASYNC.call(computingMove, updateDiff(ytc.from, ytc.to), ytc);
                } else {
                    if (ytc.from && ytc.fromExpanded === false) {
                        //expand from
                        ytc.fromExpanded = true;
                        _needChecking = true;
                        done = TASYNC.call(expandFrom, expandDiff(ytc.from, true), ytc);
                    } else if (ytc.to && ytc.toExpanded === false) {
                        //expand to
                        ytc.toExpanded = true;
                        _needChecking = true;
                        done = TASYNC.call(expandTo, expandDiff(ytc.to, false), ytc);
                    }
                }
            }
            return TASYNC.call(checkRound, done);
        }

        function hasRealChange(diffNode) {
            var keys = Object.keys(diffNode || {}),
                searchedKeywords = {
                    hash: true,
                    attr: true,
                    reg: true,
                    pointer: true,
                    set: true,
                    meta: true,
                    movedFrom: true,
                    removed: true
                },
                i;

            for (i = 0; i < keys.length; i += 1) {
                if (searchedKeywords[keys[i]]) {
                    return true;
                }
            }

            return false;
        }

        function getDiffChildrenRelids(diff) {
            var keys = Object.keys(diff || {}),
                i,
                filteredKeys = [],
                forbiddenWords = {
                    guid: true,
                    hash: true,
                    attr: true,
                    reg: true,
                    pointer: true,
                    set: true,
                    meta: true,
                    removed: true,
                    movedFrom: true,
                    childrenListChanged: true,
                    oGuids: true,
                    ooGuids: true,
                    min: true,
                    max: true
                };
            for (i = 0; i < keys.length; i++) {
                if (!forbiddenWords[keys[i]]) {
                    filteredKeys.push(keys[i]);
                }
            }
            return filteredKeys;
        }

        function getMoveSources(diff, path, toFrom, fromTo) {
            var relids = getDiffChildrenRelids(diff),
                i;

            for (i = 0; i < relids.length; i++) {
                getMoveSources(diff[relids[i]], path + '/' + relids[i], toFrom, fromTo);
            }

            if (typeof diff.movedFrom === 'string') {
                toFrom[path] = diff.movedFrom;
                fromTo[diff.movedFrom] = path;
            }
        }

        function getParentPath(path) {
            path = path.split('/');
            path.splice(-1, 1);
            return path.join('/');
        }

        function fixCollision(path, relid, diffBase, diffExtension) {
            //a generic approach, to check if both diff has the same path
            // but for a different node
            //there is three types of path equality:
            //1. same guids -> same node
            //2. both was moved -> different nodes
            //3. one was moved and the other is created ->different nodes (here we always have to generate
            // new relid to the moved one)
            var i,
                keys = getDiffChildrenRelids(diffBase),
                globalDiff,
                newRelid,
                newPath,
                nodeDiff,
                relids,
                dst2src,
                src2dst,
                relidObj = {},
                parent;

            if (diffBase.guid !== diffExtension.guid &&
                (typeof diffBase.guid === 'string' && typeof diffExtension.guid === 'string')) {
                if (diffBase.movedFrom && diffExtension.movedFrom) {
                    //relocate the extension
                    globalDiff = _concatExtension;
                    nodeDiff = diffExtension;
                    dst2src = _concatMoves.getExtensionSourceFromDestination;
                    src2dst = _concatMoves.getExtensionDestinationFromSource;
                } else if (diffBase.movedFrom && diffExtension.removed === false) {
                    globalDiff = _concatBase;
                    nodeDiff = diffBase;
                    dst2src = _concatMoves.getBaseSourceFromDestination;
                    src2dst = _concatMoves.getBaseDestinationFromSource;
                } else if (diffExtension.movedFrom && diffBase.removed === false) {
                    globalDiff = _concatExtension;
                    nodeDiff = diffExtension;
                    dst2src = _concatMoves.getExtensionSourceFromDestination;
                    src2dst = _concatMoves.getExtensionDestinationFromSource;
                } else {
                    throw new Error('there is a guid mismatch among the two diffs: ' +
                        diffBase.guid + ' vs ' + diffExtension.guid);
                }

                relids = getDiffChildrenRelids(getPathOfDiff(_concatBase, getParentPath(path)))
                    .concat(getDiffChildrenRelids(getPathOfDiff(_concatExtension, getParentPath(path))));

                relidObj = {};
                for (i = 0; i < relids.length; i += 1) {
                    relidObj[relids[i]] = {};
                }
                // TODO: Could this lead to collisions on bases/instances?
                newRelid = RANDOM.generateRelid(relidObj);
                newPath = getParentPath(path) + '/' + newRelid;

                //now the actual place switching
                parent = getPathOfDiff(globalDiff, getParentPath(path));
                parent[newRelid] = nodeDiff;
                delete parent[relid];
                dst2src[newPath] = dst2src[path];
                delete dst2src[path];
                src2dst[dst2src[newPath]] = newPath;
            }

            //recursive calls - only if there were no replacement due to collision
            for (i = 0; i < keys.length; i += 1) {
                if (diffExtension[keys[i]]) {
                    fixCollision(path + '/' + keys[i], keys[i], diffBase[keys[i]], diffExtension[keys[i]]);
                }
            }
        }

        function getAncestorPath(onePath, otherPath) {
            var ancestorPath = '',
                onePathArray = onePath.split('/'),
                otherPathArray = otherPath.split('/'),
                i = 0;
            onePathArray.shift();
            otherPathArray.shift();
            if (onePathArray.length > 0 && otherPathArray.length > 0) {
                while (i < onePathArray.length && onePathArray[i] === otherPathArray[i]) {
                    ancestorPath += '/' + onePathArray[i];
                    i += 1;
                }
            }
            return ancestorPath;
        }

        function setBaseOfNewNode(root, nodePath, basePath) {
            var ancestorPath = getAncestorPath(nodePath, basePath);
            return TASYNC.call(function (node) {
                var sourcePath = nodePath.substr(ancestorPath.length),
                    targetPath = basePath.substr(ancestorPath.length);
                innerCore.overlayInsert(node, sourcePath, 'base', targetPath);
            }, self.loadByPath(root, ancestorPath));
        }

        function getOrderedRelids(diffObject) {
            //those nodes that were changing relid as a result of move should be handled last
            var keys = getDiffChildrenRelids(diffObject),
                i,
                ordered = [],
                sourceRelid;
            for (i = 0; i < keys.length; i += 1) {
                if (diffObject[keys[i]].movedFrom) {
                    sourceRelid = diffObject[keys[i]].movedFrom;
                    sourceRelid = sourceRelid.split('/');
                    sourceRelid = sourceRelid[sourceRelid.length - 1];
                    if (sourceRelid !== keys[i]) {
                        ordered.push(keys[i]);
                    } else {
                        ordered.unshift(keys[i]);
                    }
                } else {
                    ordered.unshift(keys[i]);
                }
            }
            return ordered;
        }

        function makeInitialContainmentChanges(node, diff) {
            var relids = getOrderedRelids(diff),
                i, done, child, moved,
                moving = function (n, di, r, p, m, a/*, d*/) {
                    var nRelid;
                    if (m === true) {
                        n = self.moveNode(n, p);
                        nRelid = self.getRelid(n);

                        if (r !== nRelid) {
                            //we have to make additional changes to our move table
                            diff[nRelid] = JSON.parse(JSON.stringify(diff[r]));
                            delete diff[r];
                        }
                    }
                    return makeInitialContainmentChanges(n, di, a);
                };

            for (i = 0; i < relids.length; i++) {
                moved = false;
                if (diff[relids[i]].movedFrom) {
                    //moved node
                    moved = true;
                    child = self.loadByPath(self.getRoot(node), diff[relids[i]].movedFrom);
                    done = TASYNC.call(moving, child, diff[relids[i]], relids[i], node, moved, done);
                } else if (diff[relids[i]].removed === false) {
                    //added node
                    if (diff[relids[i]].hash) {
                        self.setProperty(node, relids[i], diff[relids[i]].hash);
                        node.childrenRelids = null;
                    }
                } else {
                    //simple node
                    child = self.loadChild(node, relids[i]);
                    done = TASYNC.call(moving, child, diff[relids[i]], relids[i], node, moved, done);
                }
            }

            return TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function setBaseRelationsOfNewNodes(root, path, diff, added) {
            var relids = getOrderedRelids(diff),
                i,
                children = [],
                newNode = false;

            for (i = 0; i < relids.length; i += 1) {
                if ((diff[relids[i]].removed === false || added)
                    && diff[relids[i]].pointer && diff[relids[i]].pointer.base) {
                    newNode = true;
                    children[i] = TASYNC.join(
                        setBaseOfNewNode(root, path + '/' + relids[i], diff[relids[i]].pointer.base),
                        setBaseRelationsOfNewNodes(root, path + '/' + relids[i], diff[relids[i]], added || newNode)
                    );
                } else {
                    children[i] = TASYNC.call(
                        setBaseRelationsOfNewNodes, root, path + '/' + relids[i], diff[relids[i]], added
                    );
                }
            }

            return TASYNC.lift(children);
        }

        function applyNodeChange(root, path, nodeDiff) {
            //check for move
            var node;

            node = self.loadByPath(root, path);

            return TASYNC.call(function (n) {
                var done,
                    relids = getDiffChildrenRelids(nodeDiff),
                    i;
                if (n === null) {
                    logger.warn('Missing node [' + path + '] during patch application. ' +
                        'Could be a conflicting conflict resolution.');
                    return;
                }
                if (nodeDiff.removed === true) {
                    self.deleteNode(n);
                    return;
                }
                applyAttributeChanges(n, nodeDiff.attr || {});
                applyRegistryChanges(n, nodeDiff.reg || {});
                done = applyPointerChanges(n, nodeDiff);
                done = TASYNC.call(applySetChanges, n, nodeDiff.set || {}, done);
                if (nodeDiff.meta) {
                    delete nodeDiff.meta.empty;
                    done = TASYNC.call(applyMetaChanges, n, nodeDiff.meta, done);
                }
                for (i = 0; i < relids.length; i++) {
                    done = TASYNC.call(function () {
                        return null;
                    }, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]), done);
                    // done = TASYNC.join(done, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]));
                }
                /*TASYNC.call(function (d) {
                 return done;
                 }, done);*/

                //we should check for possible guid change and restore the expected guid
                if (self.getGuid(n) !== nodeDiff.guid && nodeDiff.guid) {
                    done = TASYNC.call(function () {
                        return null;
                    }, self.setGuid(n, nodeDiff.guid), done);
                }
                return done;
            }, node);
        }

        function applyAttributeChanges(node, attrDiff) {
            var i, keys;
            keys = Object.keys(attrDiff);
            for (i = 0; i < keys.length; i++) {
                if (attrDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delAttribute(node, keys[i]);
                } else {
                    self.setAttribute(node, keys[i], attrDiff[keys[i]]);
                }
            }
        }

        function applyRegistryChanges(node, regDiff) {
            var i, keys;
            keys = Object.keys(regDiff);
            for (i = 0; i < keys.length; i++) {
                if (regDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delRegistry(node, keys[i]);
                } else {
                    self.setRegistry(node, keys[i], regDiff[keys[i]]);
                }
            }
        }

        function setPointer(node, name, target) {
            var targetNode;
            if (target === null) {
                targetNode = null;
            } else {
                targetNode = self.loadByPath(self.getRoot(node), target);
            }
            return TASYNC.call(function (t) {
                //TODO watch if handling of base changes!!!
                self.setPointer(node, name, t);
                return;
            }, targetNode);
        }

        function applyPointerChanges(node, diff) {
            var done,
                pointerDiff = diff.pointer || {},
                keys = Object.keys(pointerDiff),
                i;
            for (i = 0; i < keys.length; i++) {
                if (pointerDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.deletePointer(node, keys[i]);
                } else if (diff.removed !== false || keys[i] !== 'base') {
                    done = setPointer(node, keys[i], pointerDiff[keys[i]]);
                }
            }

            return TASYNC.call(function (/*d*/) {
                return null;
            }, done);

        }

        function addMember(node, name, target, data) {
            var memberAttrSetting = function (diff) {
                    var keys = self.getMemberOwnAttributeNames(node, name, target),
                        i;
                    for (i = 0; i < keys.length; i++) {
                        self.delMemberAttribute(node, name, target, keys[i]);
                    }

                    keys = Object.keys(diff);
                    for (i = 0; i < keys.length; i++) {
                        self.setMemberAttribute(node, name, target, keys[i], diff[keys[i]]);
                    }
                },
                memberRegSetting = function (diff) {
                    var keys = self.getMemberOwnRegistryNames(node, name, target),
                        i;
                    for (i = 0; i < keys.length; i++) {
                        self.delMemberRegistry(node, name, target, keys[i]);
                    }

                    keys = Object.keys(diff);
                    for (i = 0; i < keys.length; i++) {
                        self.setMemberRegistry(node, name, target, keys[i], diff[keys[i]]);
                    }
                };
            return TASYNC.call(function (t) {
                self.addMember(node, name, t);
                memberAttrSetting(data.attr || {});
                memberRegSetting(data.reg || {});
                return;
            }, self.loadByPath(self.getRoot(node), target));
        }

        function applySetChanges(node, setDiff) {
            var done,
                setNames = Object.keys(setDiff),
                elements, i, j;
            for (i = 0; i < setNames.length; i++) {
                if (setDiff[setNames[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.deleteSet(node, setNames[i]);
                } else {
                    self.createSet(node, setNames[i]);
                    elements = Object.keys(setDiff[setNames[i]]);
                    for (j = 0; j < elements.length; j++) {
                        if (setDiff[setNames[i]][elements[j]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delMember(node, setNames[i], elements[j]);
                        } else {
                            done = addMember(node, setNames[i], elements[j], setDiff[setNames[i]][elements[j]]);
                        }
                    }
                }
            }

            return TASYNC.call(function (/*d*/) {
                return null;
            }, done);

        }

        function applyMetaAttributes(node, metaAttrDiff) {
            var i, keys, newValue;
            if (metaAttrDiff === CONSTANTS.TO_DELETE_STRING) {
                //we should delete all MetaAttributes
                keys = self.getValidAttributeNames(node);
                for (i = 0; i < keys.length; i++) {
                    self.delAttributeMeta(node, keys[i]);
                }
            } else {
                keys = Object.keys(metaAttrDiff);
                for (i = 0; i < keys.length; i++) {
                    if (metaAttrDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                        self.delAttributeMeta(node, keys[i]);
                    } else {
                        newValue = jsonConcat(self.getAttributeMeta(node, keys[i]) || {}, metaAttrDiff[keys[i]]);
                        self.setAttributeMeta(node, keys[i], newValue);
                    }
                }
            }
        }

        function applyMetaConstraints(node, metaConDiff) {
            var keys, i;
            if (metaConDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all constraints
                keys = self.getConstraintNames(node);
                for (i = 0; i < keys.length; i++) {
                    self.delConstraint(node, keys[i]);
                }
            } else {
                keys = Object.keys(metaConDiff);
                for (i = 0; i < keys.length; i++) {
                    if (metaConDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                        self.delConstraint(node, keys[i]);
                    } else {
                        self.setConstraint(node, keys[i], jsonConcat(self.getConstraint(node, keys[i]) || {},
                            metaConDiff[keys[i]]));
                    }
                }
            }
        }

        function applyMetaChildren(node, metaChildrenDiff) {
            var keys, i, done,
                setChild = function (target, data/*, d*/) {
                    self.setChildMeta(node, target, data.min, data.max);
                };
            if (metaChildrenDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all valid child
                keys = self.getValidChildrenPaths(node);
                for (i = 0; i < keys.length; i++) {
                    self.delChildMeta(node, keys[i]);
                }
            } else {
                self.setChildrenMetaLimits(node, metaChildrenDiff.min, metaChildrenDiff.max);
                delete metaChildrenDiff.max; //TODO we do not need it anymore, but maybe there is a better way
                delete metaChildrenDiff.min;
                keys = Object.keys(metaChildrenDiff);
                for (i = 0; i < keys.length; i++) {
                    if (metaChildrenDiff[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                        self.delChildMeta(node, keys[i]);
                    } else {
                        done = TASYNC.call(setChild, self.loadByPath(self.getRoot(node), keys[i]),
                            metaChildrenDiff[keys[i]], done);
                    }
                }
            }

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyMetaPointers(node, metaPointerDiff) {
            var names, targets, i, j, done,
                setPointer = function (name, target, data/*, d*/) {
                    self.setPointerMetaTarget(node, name, target, data.min, data.max);
                };
            if (metaPointerDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all pointers,sets and their targets
                names = self.getValidPointerNames(node);
                for (i = 0; i < names.length; i++) {
                    self.delPointerMeta(node, names[i]);
                }

                names = self.getValidSetNames(node);
                for (i = 0; i < names.length; i++) {
                    self.delPointerMeta(node, names[i]);
                }
                return;
            }

            names = Object.keys(metaPointerDiff);
            for (i = 0; i < names.length; i++) {
                if (metaPointerDiff[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delPointerMeta(node, names[i]);
                } else {
                    self.setPointerMetaLimits(node, names[i], metaPointerDiff[names[i]].min,
                        metaPointerDiff[names[i]].max);
                    //TODO we do not need it anymore, but maybe there is a better way
                    delete metaPointerDiff[names[i]].max;
                    delete metaPointerDiff[names[i]].min;
                    targets = Object.keys(metaPointerDiff[names[i]]);
                    for (j = 0; j < targets.length; j++) {
                        if (metaPointerDiff[names[i]][targets[j]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delPointerMetaTarget(node, names[i], targets[j]);
                        } else {
                            done = TASYNC.call(setPointer, names[i], self.loadByPath(self.getRoot(node), targets[j]),
                                metaPointerDiff[names[i]][targets[j]], done);
                        }
                    }
                }
            }

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyMetaAspects(node, metaAspectsDiff) {
            var names, targets, i, j, done,
                setAspect = function (name, target/*, d*/) {
                    self.setAspectMetaTarget(node, name, target);
                };
            if (metaAspectsDiff === CONSTANTS.TO_DELETE_STRING) {
                //remove all aspects
                names = self.getValidAspectNames(node);
                for (i = 0; i < names.length; i++) {
                    self.delAspectMeta(node, names[i]);
                }
                return;
            }

            names = Object.keys(metaAspectsDiff);
            for (i = 0; i < names.length; i++) {
                if (metaAspectsDiff[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                    self.delAspectMeta(node, names[i]);
                } else {
                    targets = metaAspectsDiff[names[i]];
                    for (j = 0; j < targets.length; j++) {
                        if (metaAspectsDiff[names[i]][targets[j]] === CONSTANTS.TO_DELETE_STRING) {
                            self.delAspectMetaTarget(node, names[i], targets[j]);
                        } else {
                            done = TASYNC.call(setAspect, names[i], self.loadByPath(self.getRoot(node), targets[j]),
                                done);
                        }
                    }
                }
            }

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function applyMetaChanges(node, metaDiff) {
            var done;
            applyMetaAttributes(node, metaDiff.attributes || CONSTANTS.TO_DELETE_STRING);
            applyMetaConstraints(node, metaDiff.constraints || CONSTANTS.TO_DELETE_STRING);
            done = applyMetaChildren(node, metaDiff.children || CONSTANTS.TO_DELETE_STRING);
            done = TASYNC.call(applyMetaPointers, node, metaDiff.pointers || CONSTANTS.TO_DELETE_STRING, done);
            done = TASYNC.call(applyMetaAspects, node, metaDiff.aspects || CONSTANTS.TO_DELETE_STRING, done);

            TASYNC.call(function (/*d*/) {
                return null;
            }, done);
        }

        function getNodeByGuid(diff, guid) {
            var relids, i, node;

            if (REGEXP.GUID.test(guid) !== true) {
                return null;
            }

            if (diff.guid === guid) {
                return diff;
            }

            relids = getDiffChildrenRelids(diff);
            for (i = 0; i < relids.length; i++) {
                node = getNodeByGuid(diff[relids[i]], guid);
                if (node) {
                    return node;
                }
            }
            return null;
        }

        function insertAtPath(diff, path, object) {
            ASSERT(typeof path === 'string');
            var i, base, relid, nodepath;

            if (path === '') {
                _concatResult = JSON.parse(JSON.stringify(object));
                return;
            }
            nodepath = path.match(/\/\/.*\/\//) || [];
            nodepath = nodepath[0] || 'there is no nodepath in the path';
            path = path.replace(nodepath, '/*nodepath*/');
            nodepath = nodepath.replace(/\/\//g, '/');
            nodepath = nodepath.slice(0, -1);
            path = path.split('/');
            path.shift();
            if (path.indexOf('*nodepath*') !== -1) {
                path[path.indexOf('*nodepath*')] = nodepath;
            }
            relid = path.pop();
            base = diff;
            for (i = 0; i < path.length; i++) {
                base[path[i]] = base[path[i]] || {};
                base = base[path[i]];
            }
            base[relid] = JSON.parse(JSON.stringify(object));
            return;
        }

        function getSingleNode(node) {
            //removes the children from the node
            var result = JSON.parse(JSON.stringify(node)),
                keys = getDiffChildrenRelids(result),
                i;
            for (i = 0; i < keys.length; i++) {
                delete result[keys[i]];
            }
            //changeMovedPaths(result);
            return result;
        }

        function jsonConcat(base, extension) {
            var baseKeys = Object.keys(base),
                extKeys = Object.keys(extension),
                concat = JSON.parse(JSON.stringify(base)),
                i;
            for (i = 0; i < extKeys.length; i++) {
                if (baseKeys.indexOf(extKeys[i]) === -1) {
                    concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));
                } else {
                    if (typeof base[extKeys[i]] === 'object' && typeof extension[extKeys[i]] === 'object') {
                        concat[extKeys[i]] = jsonConcat(base[extKeys[i]], extension[extKeys[i]]);
                    } else { //either from value to object or object from value we go with the extension
                        concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));
                    }
                }
            }
            return concat;
        }

        //FIXME are we going to use this function
        //function getConflictByGuid(conflict, guid) {
        //    var relids, i, result;
        //    if (conflict.guid === guid) {
        //        return conflict;
        //    }
        //    relids = getDiffChildrenRelids(conflict);
        //    for (i = 0; i < relids.length; i++) {
        //        result = getConflictByGuid(conflict[relids[i]], guid);
        //        if (result) {
        //            return result;
        //        }
        //    }
        //    return null;
        //}

        function getPathByGuid(conflict, guid, path) {
            var relids, i, result;

            if (REGEXP.GUID.test(guid) !== true) {
                return null;
            }

            if (conflict.guid === guid) {
                return path;
            }
            relids = getDiffChildrenRelids(conflict);
            for (i = 0; i < relids.length; i++) {
                result = getPathByGuid(conflict[relids[i]], guid, path + '/' + relids[i]);
                if (result) {
                    return result;
                }
            }
            return null;
        }

        //now we try a different approach, which maybe more simple
        function getCommonPathForConcat(path) {
            if (_concatMoves.getExtensionSourceFromDestination[path]) {
                path = _concatMoves.getExtensionSourceFromDestination[path];
            }
            if (_concatMoves.getBaseDestinationFromSource[path]) {
                path = _concatMoves.getBaseDestinationFromSource[path];
            }
            return path;
        }

        function getConcatBaseRemovals(diff) {
            var relids = getDiffChildrenRelids(diff),
                i;
            if (diff.removed !== true) {
                if (diff.movedFrom) {
                    if (_concatBaseRemovals[diff.guid] !== undefined) {
                        delete _concatBaseRemovals[diff.guid];
                    } else {
                        _concatBaseRemovals[diff.guid] = false;
                    }
                }
                for (i = 0; i < relids.length; i++) {
                    getConcatBaseRemovals(diff[relids[i]]);
                }
            } else {
                if (_concatBaseRemovals[diff.guid] === false) {
                    delete _concatBaseRemovals[diff.guid];
                } else {
                    _concatBaseRemovals[diff.guid] = true;
                }
            }
        }

        function completeConcatBase(baseDiff, extensionDiff) {
            var recursiveComplete = function (base, extension, newItem) {
                var i, keys;
                if (newItem === true) {
                    if (extension.guid) {
                        base.guid = extension.guid;
                    }
                    if (extension.oGuids) {
                        base.oGuids = extension.oGuids;
                    }
                    if (extension.ooGuids) {
                        base.ooGuids = extension.ooGuids;
                    }

                    if (typeof extension.removed === 'boolean' && !extension.removed) {
                        base.removed = extension.removed;
                    }

                    if (extension.hash) {
                        base.hash = extension.hash;
                    }

                    if (extension.childrenListChanged) {
                        base.childrenListChanged = true;
                    }
                }

                keys = getDiffChildrenRelids(extension);
                for (i = 0; i < keys.length; i += 1) {
                    if (base[keys[i]] === undefined) {
                        if (typeof extension[keys[i]].movedFrom !== 'string') {
                            base[keys[i]] = {};
                            recursiveComplete(base[keys[i]], extension[keys[i]], true);
                        }
                    } else {
                        recursiveComplete(base[keys[i]], extension[keys[i]], false);
                    }
                }
            };

            recursiveComplete(baseDiff, extensionDiff, Object.keys(baseDiff).length === 0);
        }

        function getObstructiveGuids(diffNode) {
            var result = [],
                keys, i;
            keys = Object.keys(diffNode.oGuids || {});
            for (i = 0; i < keys.length; i++) {
                if (_concatBaseRemovals[keys[i]]) {
                    result.push(keys[i]);
                }
            }
            keys = Object.keys(diffNode.ooGuids || {});
            for (i = 0; i < keys.length; i++) {
                if (_concatBaseRemovals[keys[i]]) {
                    result.push(keys[i]);
                }
            }
            return result;
        }

        function getWhomIObstructGuids(guid) {
            //this function is needed when the extension contains a deletion where the base did not delete the node
            var guids = [],
                checkNode = function (diffNode) {
                    var relids, i;
                    if ((diffNode.oGuids && diffNode.oGuids[guid]) || (diffNode.ooGuids && diffNode.ooGuids[guid])) {
                        guids.push(diffNode.guid);
                    }

                    relids = getDiffChildrenRelids(diffNode);
                    for (i = 0; i < relids.length; i++) {
                        checkNode(diffNode[relids[i]]);
                    }
                };
            checkNode(_concatBase);
            return guids;
        }

        function gatherFullNodeConflicts(diffNode, mine, path, opposingPath) {
            var conflict,
                opposingConflict,
                keys, i,
                createSingleKeyValuePairConflicts = function (pathBase, data) {
                    var keys, i;
                    keys = Object.keys(data);
                    for (i = 0; i < keys.length; i++) {
                        conflict[pathBase + '/' + keys[i]] = conflict[pathBase + '/' + keys[i]] || {
                                value: data[keys[i]],
                                conflictingPaths: {}
                            };
                        conflict[pathBase + '/' + keys[i]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[pathBase + '/' + keys[i]] = true;
                    }
                };

            //setting the conflicts
            if (mine === true) {
                conflict = _conflictMine;
                opposingConflict = _conflictTheirs[opposingPath];
            } else {
                conflict = _conflictTheirs;
                opposingConflict = _conflictMine[opposingPath];
            }
            ASSERT(opposingConflict);
            //if the node was moved we should make a conflict for the whole node as well
            if (diffNode.movedFrom) {
                conflict[path] = conflict[path] || {value: path, conflictingPaths: {}};
                conflict[path].conflictingPaths[opposingPath] = true;
                opposingConflict.conflictingPaths[path] = true;
            }
            createSingleKeyValuePairConflicts(path + '/attr', diffNode.attr || {});
            createSingleKeyValuePairConflicts(path + '/reg', diffNode.reg || {});
            createSingleKeyValuePairConflicts(path + '/pointer', diffNode.pointer || {});

            if (diffNode.set) {
                if (diffNode.set === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/set'] = conflict[path + '/set'] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                    conflict[path + '/set'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/set'] = true;
                } else {
                    keys = Object.keys(diffNode.set);
                    for (i = 0; i < keys.length; i++) {
                        if (diffNode.set[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                            conflict[path + '/set/' + keys[i]] = conflict[path + '/set/' + keys[i]] || {
                                    value: CONSTANTS.TO_DELETE_STRING,
                                    conflictingPaths: {}
                                };
                            conflict[path + '/set/' + keys[i]].conflictingPaths[opposingPath] = true;
                            opposingConflict.conflictingPaths[path + '/set/' + keys[i]] = true;
                        } else {
                            gatherFullSetConflicts(diffNode.set[keys[i]], mine, path + '/set/' + keys[i], opposingPath);
                        }
                    }
                }
            }

            if (diffNode.meta) {
                gatherFullMetaConflicts(diffNode.meta, mine, path + '/meta', opposingPath);
            }

            //if the opposing item is theirs, we have to recursively go down in our changes
            if (mine) {
                keys = getDiffChildrenRelids(diffNode);
                for (i = 0; i < keys.length; i++) {
                    gatherFullNodeConflicts(diffNode[keys[i]], true, path + '/' + keys[i], opposingPath);
                }
            }

        }

        function gatherFullSetConflicts(diffSet, mine, path, opposingPath) {
            var relids = getDiffChildrenRelids(diffSet),
                i, keys, j, conflict, opposingConflict;

            //setting the conflicts
            if (mine === true) {
                conflict = _conflictMine;
                opposingConflict = _conflictTheirs[opposingPath];
            } else {
                conflict = _conflictTheirs;
                opposingConflict = _conflictMine[opposingPath];
            }
            for (i = 0; i < relids.length; i++) {
                if (diffSet[relids[i]] === CONSTANTS.TO_DELETE_STRING) {
                    //single conflict as the element was removed
                    conflict[path + '/' + relids[i] + '/'] = conflict[path + '/' + relids[i] + '/'] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                    conflict[path + '/' + relids[i] + '/'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/' + relids[i] + '/'] = true;
                } else {
                    keys = Object.keys(diffSet[relids[i]].attr || {});
                    for (j = 0; j < keys.length; j++) {
                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]] =
                            conflict[path + '/' + relids[i] + '//attr/' + keys[j]] || {
                                value: diffSet[relids[i]].attr[keys[j]],
                                conflictingPaths: {}
                            };
                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//attr/' + keys[j]] = true;
                    }
                    keys = Object.keys(diffSet[relids[i]].reg || {});
                    for (j = 0; j < keys.length; j++) {
                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]] =
                            conflict[path + '/' + relids[i] + '//reg/' + keys[j]] || {
                                value: diffSet[relids[i]].reg[keys[j]],
                                conflictingPaths: {}
                            };
                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//reg/' + keys[j]] = true;
                    }
                }
            }
        }

        function concatSingleKeyValuePairs(path, base, extension) {
            var keys, i, temp;
            keys = Object.keys(extension);
            for (i = 0; i < keys.length; i++) {
                temp = extension[keys[i]];
                if (typeof temp === 'string' && temp !== CONSTANTS.TO_DELETE_STRING) {
                    temp = getCommonPathForConcat(temp);
                }
                if (base[keys[i]] !== undefined && CANON.stringify(base[keys[i]]) !== CANON.stringify(temp)) {
                    //conflict
                    _conflictMine[path + '/' + keys[i]] = {value: base[keys[i]], conflictingPaths: {}};
                    _conflictTheirs[path + '/' + keys[i]] = {value: extension[keys[i]], conflictingPaths: {}};
                    _conflictMine[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;
                    _conflictTheirs[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;
                } else {
                    base[keys[i]] = extension[keys[i]];
                }
            }
        }

        function concatSet(path, base, extension) {
            var names = Object.keys(extension),
                members, i, j, memberPath;

            for (i = 0; i < names.length; i++) {
                if (base[names[i]]) {
                    if (base[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                        if (extension[names[i]] !== CONSTANTS.TO_DELETE_STRING) {
                            //whole set conflict
                            _conflictMine[path + '/' + names[i]] = {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                            gatherFullSetConflicts(extension[names[i]],
                                false, path + '/' + names[i], path + '/' + names[i]);
                        }
                    } else {
                        if (extension[names[i]] === CONSTANTS.TO_DELETE_STRING) {
                            //whole set conflict
                            _conflictTheirs[path + '/' + names[i]] = {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                            gatherFullSetConflicts(base[names[i]], true, path + '/' + names[i], path + '/' + names[i]);
                        } else {
                            //now we can only have member or sub-member conflicts...
                            members = getDiffChildrenRelids(extension[names[i]]);
                            for (j = 0; j < members.length; j++) {
                                memberPath = getCommonPathForConcat(members[j]);
                                if (base[names[i]][memberPath]) {
                                    if (base[names[i]][memberPath] === CONSTANTS.TO_DELETE_STRING) {
                                        if (extension[names[i]][members[j]] !== CONSTANTS.TO_DELETE_STRING) {
                                            //whole member conflict
                                            _conflictMine[path + '/' + names[i] + '/' + memberPath + '//'] = {
                                                value: CONSTANTS.TO_DELETE_STRING,
                                                conflictingPaths: {}
                                            };
                                            gatherFullNodeConflicts(extension[names[i]][members[j]],
                                                false,
                                                path + '/' + names[i] + '/' + memberPath + '//', path +
                                                '/' + names[i] + '/' + memberPath + '//');
                                        }
                                    } else {
                                        if (extension[names[i]][members[j]] === CONSTANTS.TO_DELETE_STRING) {
                                            //whole member conflict
                                            _conflictTheirs[path + '/' + names[i] + '/' + memberPath + '//'] = {
                                                value: CONSTANTS.TO_DELETE_STRING,
                                                conflictingPaths: {}
                                            };
                                            gatherFullNodeConflicts(base[names[i]][memberPath],
                                                true,
                                                path + '/' + names[i] + '/' + memberPath + '//', path +
                                                '/' + names[i] + '/' + memberPath + '//');
                                        } else {
                                            if (extension[names[i]][members[j]].attr) {
                                                if (base[names[i]][memberPath].attr) {
                                                    concatSingleKeyValuePairs(path + '/' +
                                                        names[i] + '/' + memberPath + '/' + '/attr',
                                                        base[names[i]][memberPath].attr,
                                                        extension[names[i]][members[j]].attr);
                                                } else {
                                                    base[names[i]][memberPath].attr =
                                                        extension[names[i]][members[j]].attr;
                                                }
                                            }
                                            if (extension[names[i]][members[j]].reg) {
                                                if (base[names[i]][memberPath].reg) {
                                                    concatSingleKeyValuePairs(path + '/' +
                                                        names[i] + '/' + memberPath + '/' + '/reg',
                                                        base[names[i]][memberPath].reg,
                                                        extension[names[i]][members[j]].reg);
                                                } else {
                                                    base[names[i]][memberPath].reg =
                                                        extension[names[i]][members[j]].reg;
                                                }
                                            }

                                        }
                                    }
                                } else {
                                    //concat
                                    base[names[i]][memberPath] = extension[names[i]][members[j]];
                                }
                            }
                        }
                    }
                } else {
                    //simple concatenation
                    //TODO the path for members should be replaced here as well...
                    base[names[i]] = extension[names[i]];
                }
            }
        }

        function gatherFullMetaConflicts(diffMeta, mine, path, opposingPath) {
            var conflict, opposingConflict,
                relids, i, j, keys, tPath, key;

            if (mine) {
                conflict = _conflictMine;
                opposingConflict = _conflictTheirs[opposingPath];
            } else {
                conflict = _conflictTheirs;
                opposingConflict = _conflictMine[opposingPath];
            }

            if (diffMeta === CONSTANTS.TO_DELETE_STRING) {
                conflict[path] = conflict[path] || {value: CONSTANTS.TO_DELETE_STRING, conflictingPaths: {}};
                conflict[path].conflictingPaths[opposingPath] = true;
                opposingConflict.conflictingPaths[path] = true;
                return; //there is no other conflict
            }

            //children
            if (diffMeta.children) {
                if (diffMeta.children === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/children'] = conflict[path + '/children'] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                    conflict[path + '/children'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/children'] = true;
                } else {
                    if (diffMeta.children.max) {
                        conflict[path + '/children/max'] = conflict[path + '/children/max'] || {
                                value: diffMeta.children.max,
                                conflictingPaths: {}
                            };
                        conflict[path + '/children/max'].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/children/max'] = true;
                    }
                    if (diffMeta.children.min) {
                        conflict[path + '/children/min'] = conflict[path + '/children/min'] || {
                                value: diffMeta.children.min,
                                conflictingPaths: {}
                            };
                        conflict[path + '/children/min'].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/children/min'] = true;
                    }
                    relids = getDiffChildrenRelids(diffMeta.children);
                    for (i = 0; i < relids.length; i++) {
                        conflict[path + '/children/' + relids[i]] = conflict[path + '/children/' + relids[i]] || {
                                value: diffMeta.children[relids[i]],
                                conflictingPaths: {}
                            };
                        conflict[path + '/children/' + relids[i]].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[path + '/children/' + relids[i]] = true;
                    }
                }
            }
            //attributes
            if (diffMeta.attributes) {
                if (diffMeta.attributes === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/attributes'] = conflict[path + '/attributes'] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                    conflict[path + '/attributes'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/attributes'] = true;
                } else {
                    keys = Object.keys(diffMeta.attributes);
                    for (i = 0; i < keys.length; i++) {
                        key = path + '/attributes/' + keys[i];
                        conflict[key] = conflict[key] || {
                                value: diffMeta.attributes[keys[i]],
                                conflictingPaths: {}
                            };
                        conflict[key].conflictingPaths[opposingPath] = true;
                        opposingConflict.conflictingPaths[key] = true;
                    }
                }
            }
            //pointers
            if (diffMeta.pointers) {
                if (diffMeta.pointers === CONSTANTS.TO_DELETE_STRING) {
                    conflict[path + '/pointers'] = conflict[path + '/pointers'] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                    conflict[path + '/pointers'].conflictingPaths[opposingPath] = true;
                    opposingConflict.conflictingPaths[path + '/pointers'] = true;
                } else {
                    keys = Object.keys(diffMeta.pointers);
                    for (i = 0; i < keys.length; i++) {
                        if (diffMeta.pointers[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                            conflict[path + '/pointers/' + keys[i]] = conflict[path + '/pointers/' + keys[i]] || {
                                    value: CONSTANTS.TO_DELETE_STRING,
                                    conflictingPaths: {}
                                };
                            conflict[path + '/pointers/' + keys[i]].conflictingPaths[opposingPath] = true;
                            opposingConflict.conflictingPaths[path + '/pointers/' + keys[i]] = true;
                        } else {
                            if (diffMeta.pointers[keys[i]].max) {
                                conflict[path + '/pointers/' + keys[i] + '/max'] =
                                    conflict[path + '/pointers/' + keys[i] + '/max'] || {
                                        value: diffMeta.pointers[keys[i]].max,
                                        conflictingPaths: {}
                                    };
                                conflict[path + '/pointers/' + keys[i] + '/max'].conflictingPaths[opposingPath] = true;
                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/max'] = true;
                            }
                            if (diffMeta.pointers[keys[i]].min) {
                                conflict[path + '/pointers/' + keys[i] + '/min'] =
                                    conflict[path + '/pointers/' + keys[i] + '/min'] || {
                                        value: diffMeta.pointers[keys[i]].min,
                                        conflictingPaths: {}
                                    };
                                conflict[path + '/pointers/' + keys[i] + '/min'].conflictingPaths[opposingPath] = true;
                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/min'] = true;
                            }
                            relids = getDiffChildrenRelids(diffMeta.pointers[keys[i]]);
                            for (j = 0; j < relids.length; j++) {
                                tPath = getCommonPathForConcat(relids[j]);
                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] =
                                    conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] || {
                                        value: diffMeta.pointers[keys[i]][relids[j]],
                                        conflictingPaths: {}
                                    };
                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//']
                                    .conflictingPaths[opposingPath] = true;
                                opposingConflict.conflictingPaths[path + '/pointers/' +
                                keys[i] + '/' + tPath + '//'] = true;
                            }
                        }
                    }
                }
            }
            //aspects
            //TODO
        }

        function concatMeta(path, base, extension) {
            var keys, i, tPath, j, paths, t2Path,
                mergeMetaItems = function (bPath, bData, eData) {
                    var bKeys, tKeys, i, tPath, t2Path;
                    //delete checks
                    if (bData === CONSTANTS.TO_DELETE_STRING || eData === CONSTANTS.TO_DELETE_STRING) {
                        if (CANON.stringify(bData) !== CANON.stringify(eData)) {
                            _conflictMine[bPath] = _conflictMine[bPath] || {value: bData, conflictingPaths: {}};
                            _conflictMine[bPath].conflictingPaths[bPath] = true;
                            _conflictTheirs[bPath] = _conflictTheirs[bPath] || {value: eData, conflictingPaths: {}};
                            _conflictTheirs[bPath].conflictingPaths[bPath] = true;
                        }
                    } else {
                        //max
                        if (eData.max) {
                            if (bData.max && bData.max !== eData.max) {
                                tPath = bPath + '/max';
                                _conflictMine[tPath] = _conflictMine[tPath] || {
                                        value: bData.max,
                                        conflictingPaths: {}
                                    };
                                _conflictMine[tPath].conflictingPaths[tPath] = true;
                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                        value: eData.max,
                                        conflictingPaths: {}
                                    };
                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                            } else {
                                bData.max = eData.max;
                            }
                        }
                        //min
                        if (eData.min) {
                            if (bData.min && bData.min !== eData.min) {
                                tPath = bPath + '/min';
                                _conflictMine[tPath] = _conflictMine[tPath] || {
                                        value: bData.min,
                                        conflictingPaths: {}
                                    };
                                _conflictMine[tPath].conflictingPaths[tPath] = true;
                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                        value: eData.min,
                                        conflictingPaths: {}
                                    };
                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                            } else {
                                bData.min = eData.min;
                            }
                        }
                        //targets
                        bKeys = getDiffChildrenRelids(bData);
                        tKeys = getDiffChildrenRelids(eData);
                        for (i = 0; i < tKeys.length; i++) {
                            tPath = getCommonPathForConcat(tKeys[i]);
                            if (bKeys.indexOf(tPath) !== -1 && CANON.stringify(bData[tPath]) !==
                                CANON.stringify(eData[tKeys[i]])) {

                                t2Path = tPath;
                                tPath = bPath + '/' + tPath + '//';
                                _conflictMine[tPath] = _conflictMine[tPath] || {
                                        value: bData[t2Path],
                                        conflictingPaths: {}
                                    };
                                _conflictMine[tPath].conflictingPaths[tPath] = true;
                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                        value: eData[tKeys[i]],
                                        conflictingPaths: {}
                                    };
                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                            } else {
                                bData[tPath] = eData[tKeys[i]];
                            }
                        }
                    }
                };
            if (CANON.stringify(base) !== CANON.stringify(extension)) {
                if (base === CONSTANTS.TO_DELETE_STRING) {
                    _conflictMine[path] = _conflictMine[path] || {
                            value: CONSTANTS.TO_DELETE_STRING,
                            conflictingPaths: {}
                        };
                    gatherFullMetaConflicts(extension, false, path, path);
                } else {
                    if (extension === CONSTANTS.TO_DELETE_STRING) {
                        _conflictTheirs[path] = _conflictTheirs[path] || {
                                value: CONSTANTS.TO_DELETE_STRING,
                                conflictingPaths: {}
                            };
                        gatherFullMetaConflicts(base, true, path, path);
                    } else {
                        //now check for sub-meta conflicts

                        //children
                        if (extension.children) {
                            if (base.children) {
                                mergeMetaItems(path + '/children', base.children, extension.children);
                            } else {
                                //we just simply merge the extension's
                                base.children = extension.children;
                            }
                        }
                        //pointers
                        if (extension.pointers) {
                            if (base.pointers) {
                                //complete deletion
                                if (base.pointers === CONSTANTS.TO_DELETE_STRING ||
                                    extension.pointers === CONSTANTS.TO_DELETE_STRING) {
                                    if (CANON.stringify(base.pointers) !== CANON.stringify(extension.pointers)) {
                                        tPath = path + '/pointers';
                                        _conflictMine[tPath] = _conflictMine[tPath] || {
                                                value: base.pointers,
                                                conflictingPaths: {}
                                            };
                                        _conflictMine[tPath].conflictingPaths[tPath] = true;
                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                value: extension.pointers,
                                                conflictingPaths: {}
                                            };
                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                    }
                                } else {
                                    keys = Object.keys(extension.pointers);
                                    for (i = 0; i < keys.length; i++) {
                                        if (base.pointers[keys[i]]) {
                                            mergeMetaItems(path + '/pointers/' + keys[i], base.pointers[keys[i]],
                                                extension.pointers[keys[i]]);
                                        } else {
                                            base.pointers[keys[i]] = extension.pointers[keys[i]];
                                        }
                                    }
                                }
                            } else {
                                base.pointers = extension.pointers;
                            }
                        }
                        //attributes
                        if (extension.attributes) {
                            if (base.attributes) {
                                if (extension.attributes === CONSTANTS.TO_DELETE_STRING ||
                                    base.attributes === CONSTANTS.TO_DELETE_STRING) {
                                    if (CANON.stringify(base.attributes) !== CANON.stringify(extension.attributes)) {
                                        tPath = path + '/attributes';
                                        _conflictMine[tPath] = _conflictMine[tPath] || {
                                                value: base.attributes,
                                                conflictingPaths: {}
                                            };
                                        _conflictMine[tPath].conflictingPaths[tPath] = true;
                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                value: extension.attributes,
                                                conflictingPaths: {}
                                            };
                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                    }
                                } else {
                                    keys = Object.keys(extension.attributes);
                                    for (i = 0; i < keys.length; i++) {
                                        if (base.attributes[keys[i]]) {
                                            if (extension.attributes[keys[i]] === CONSTANTS.TO_DELETE_STRING ||
                                                base.attributes[keys[i]] === CONSTANTS.TO_DELETE_STRING) {

                                                if (CANON.stringify(base.attributes[keys[i]]) !==
                                                    CANON.stringify(extension.attributes[keys[i]])) {

                                                    tPath = path + '/attributes/' + [keys[i]];
                                                    _conflictMine[tPath] = _conflictMine[tPath] || {
                                                            value: base.attributes[keys[i]],
                                                            conflictingPaths: {}
                                                        };
                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;
                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                            value: extension.attributes[keys[i]],
                                                            conflictingPaths: {}
                                                        };
                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                                }
                                            } else {
                                                concatSingleKeyValuePairs(path + '/attributes/' + keys[i],
                                                    base.attributes[keys[i]], extension.attributes[keys[i]]);
                                            }
                                        } else {
                                            base.attributes[keys[i]] = extension.attributes[keys[i]];
                                        }
                                    }

                                }
                            } else {
                                base.attributes = extension.attributes;
                            }
                        }

                        //aspects
                        if (extension.aspects) {
                            if (base.aspects) {
                                if (extension.aspects === CONSTANTS.TO_DELETE_STRING ||
                                    base.aspects === CONSTANTS.TO_DELETE_STRING) {
                                    if (CANON.stringify(base.aspects) !== CANON.stringify(extension.aspects)) {
                                        tPath = path + '/aspects';
                                        _conflictMine[tPath] = _conflictMine[tPath] || {
                                                value: base.aspects,
                                                conflictingPaths: {}
                                            };
                                        _conflictMine[tPath].conflictingPaths[tPath] = true;
                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                value: extension.aspects,
                                                conflictingPaths: {}
                                            };
                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                    }
                                } else {
                                    keys = Object.keys(extension.aspects);
                                    for (i = 0; i < keys.length; i++) {
                                        if (base.aspects[keys[i]]) {
                                            if (extension.aspects[keys[i]] === CONSTANTS.TO_DELETE_STRING ||
                                                base.aspects[keys[i]] === CONSTANTS.TO_DELETE_STRING) {
                                                if (CANON.stringify(base.aspects[keys[i]]) !==
                                                    CANON.stringify(extension.aspects[keys[i]])) {
                                                    tPath = path + '/aspects/' + keys[i];
                                                    _conflictMine[tPath] = _conflictMine[tPath] || {
                                                            value: base.aspects[keys[i]],
                                                            conflictingPaths: {}
                                                        };
                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;
                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                            value: extension.aspects[keys[i]],
                                                            conflictingPaths: {}
                                                        };
                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                                }
                                            } else {
                                                paths = Object.keys(extension.aspects[keys[i]]);
                                                for (j = 0; j < paths.length; j++) {
                                                    tPath = getCommonPathForConcat(paths[j]);
                                                    if (base.aspects[keys[i]][tPath]) {
                                                        if (CANON.stringify(base.aspects[keys[i]][tPath]) !==
                                                            CANON.stringify(extension.aspects[keys[i]][paths[j]])) {
                                                            t2Path = tPath;
                                                            tPath = path + '/aspects/' + keys[i] + '/' + tPath + '//';
                                                            _conflictMine[tPath] = _conflictMine[tPath] || {
                                                                    value: base.aspects[keys[i]][t2Path],
                                                                    conflictingPaths: {}
                                                                };
                                                            _conflictMine[tPath].conflictingPaths[tPath] = true;
                                                            _conflictTheirs[tPath] = _conflictTheirs[tPath] || {
                                                                    value: extension.aspects[keys[i]][paths[j]],
                                                                    conflictingPaths: {}
                                                                };
                                                            _conflictTheirs[tPath].conflictingPaths[tPath] = true;
                                                        }
                                                    } else {
                                                        base.aspects[keys[i]][tPath] =
                                                            extension.aspects[keys[i]][paths[j]];
                                                    }
                                                }
                                            }
                                        } else {
                                            base.aspects[keys[i]] = extension.aspects[keys[i]];
                                        }
                                    }
                                }
                            } else {
                                base.aspects = extension.aspects;
                            }
                        }
                    }
                }
            }
        }

        function tryToConcatNodeChange(extNode, path) {
            var guid = extNode.guid,
                oGuids = getObstructiveGuids(extNode),
                baseNode = getNodeByGuid(_concatBase, guid),
                basePath = getPathByGuid(_concatBase, guid, ''),
                realBaseNode = baseNode,
                i, tPath,
                relids = getDiffChildrenRelids(extNode);

            if (extNode.removed === true) {
                if (baseNode && baseNode.removed !== true && hasRealChange(baseNode)) {
                    tPath = basePath + '/removed';
                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {value: true, conflictingPaths: {}};
                    oGuids = getWhomIObstructGuids(guid);
                    ASSERT(oGuids.length > 0);
                    for (i = 0; i < oGuids.length; i++) {
                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);
                        basePath = getPathByGuid(_concatBase, oGuids[i], '');
                        gatherFullNodeConflicts(baseNode, true, basePath, tPath);
                    }
                } else {
                    //we simply concat the deletion
                    insertAtPath(_concatBase, path, extNode);
                }
            } else {
                if (oGuids.length > 0) {
                    for (i = 0; i < oGuids.length; i++) {
                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);
                        basePath = getPathByGuid(_concatBase, oGuids[i], '');
                        if (hasRealChange(extNode)) {
                            _conflictMine[basePath + '/removed'] = _conflictMine[basePath + '/removed'] || {
                                    value: true,
                                    conflictingPaths: {}
                                };
                            gatherFullNodeConflicts(extNode, false, path, basePath + '/removed');
                        } else {
                            _conflictTheirs[basePath + '/removed'] = _conflictTheirs[basePath + '/removed'] || {
                                    value: true,
                                    conflictingPaths: {}
                                };
                            gatherFullNodeConflicts(realBaseNode, true, path, basePath + '/removed');
                        }
                    }
                } else if (baseNode) {
                    //here we are able to check the sub-node conflicts
                    //check double moves - we do not care if they moved under the same parent
                    if (extNode.movedFrom) {
                        if (baseNode.movedFrom && path !== basePath) {
                            _conflictMine[basePath] = _conflictMine[basePath] || {
                                    value: 'move',
                                    conflictingPaths: {}
                                };
                            _conflictTheirs[path] = _conflictTheirs[path] || {value: 'move', conflictingPaths: {}};
                            _conflictMine[basePath].conflictingPaths[path] = true;
                            _conflictTheirs[path].conflictingPaths[basePath] = true;
                            //we keep the node where it is, but synchronize the paths
                            path = basePath;
                        } else if (path !== basePath) {
                            //first we move the base object to its new path
                            //we copy the moved from information right here
                            baseNode.movedFrom = extNode.movedFrom;
                            insertAtPath(_concatBase, path, baseNode);
                            removePathFromDiff(_concatBase, basePath);
                            baseNode = getNodeByGuid(_concatBase, guid);
                            basePath = getPathByGuid(_concatBase, guid, '');
                            ASSERT(path === basePath);
                        }
                    }

                    ASSERT(basePath === path || baseNode.movedFrom === path);
                    path = basePath; //the base was moved

                    //and now the sub-node conflicts
                    if (extNode.attr) {
                        if (baseNode.attr) {
                            concatSingleKeyValuePairs(path + '/attr', baseNode.attr, extNode.attr);
                        } else {
                            insertAtPath(_concatBase, path + '/attr', extNode.attr);
                        }
                    }
                    if (extNode.reg) {
                        if (baseNode.reg) {
                            concatSingleKeyValuePairs(path + '/reg', baseNode.reg, extNode.reg);
                        } else {
                            insertAtPath(_concatBase, path + '/reg', extNode.reg);
                        }
                    }
                    if (extNode.pointer) {
                        if (baseNode.pointer) {
                            concatSingleKeyValuePairs(path + '/pointer', baseNode.pointer, extNode.pointer);
                        } else {
                            insertAtPath(_concatBase, path + '/pointer', extNode.pointer);
                        }
                    }
                    if (extNode.set) {
                        if (baseNode.set) {
                            concatSet(path + '/set', baseNode.set, extNode.set);
                        } else {
                            insertAtPath(_concatBase, path + '/set', extNode.set);
                        }
                    }
                    if (extNode.meta) {
                        if (baseNode.meta) {
                            concatMeta(path + '/meta', baseNode.meta, extNode.meta);
                        } else {
                            insertAtPath(_concatBase, path + '/meta', extNode.meta);
                        }
                    }
                } else {
                    //there is no basenode so we can concat the whole node
                    insertAtPath(_concatBase, path, getSingleNode(extNode));
                }
            }

            //here comes the recursion
            for (i = 0; i < relids.length; i++) {
                tryToConcatNodeChange(extNode[relids[i]], path + '/' + relids[i]);
            }

        }

        function generateConflictItems() {
            var items = [],
                keys, i, j, conflicts;
            keys = Object.keys(_conflictMine);

            for (i = 0; i < keys.length; i++) {
                conflicts = Object.keys(_conflictMine[keys[i]].conflictingPaths || {});
                ASSERT(conflicts.length > 0);
                for (j = 0; j < conflicts.length; j++) {
                    items.push({
                        selected: 'mine',
                        mine: {
                            path: keys[i],
                            info: keys[i].replace(/\//g, ' / '),
                            value: _conflictMine[keys[i]].value
                        },
                        theirs: {
                            path: conflicts[j],
                            info: conflicts[j].replace(/\//g, ' / '),
                            value: _conflictTheirs[conflicts[j]].value
                        }
                    });
                }
            }
            return items;
        }

        function harmonizeConflictPaths(diff) {
            var relids = getDiffChildrenRelids(diff),
                keys, i, members, j;

            keys = Object.keys(diff.pointer || {});
            for (i = 0; i < keys.length; i++) {
                diff.pointer[keys[i]] = getCommonPathForConcat(diff.pointer[keys[i]]);
            }
            keys = Object.keys(diff.set || {});
            for (i = 0; i < keys.length; i++) {
                members = Object.keys(diff.set[keys[i]] || {});
                for (j = 0; j < members.length; j++) {
                    if (members[j] !== getCommonPathForConcat(members[j])) {
                        diff.set[keys[i]][getCommonPathForConcat(members[j])] = diff.set[keys[i]][members[j]];
                        delete diff.set[keys[i]][members[j]];
                    }
                }
            }

            //TODO we have to do the meta as well
            for (i = 0; i < relids.length; i++) {
                harmonizeConflictPaths(diff[relids[i]]);
            }
        }

        function depthOfPath(path) {
            ASSERT(typeof path === 'string');
            return path.split('/').length;
        }

        function resolveMoves(resolveObject) {
            var i, moves = {},
                filteredItems = [],
                path,
                moveBaseOfPath = function (path) {
                    var keys = Object.keys(moves),
                        i, maxDepth = -1,
                        base = null;
                    for (i = 0; i < keys.length; i++) {
                        if (path.indexOf(keys[i]) === 1 && depthOfPath(keys[i]) > maxDepth) {
                            base = keys[i];
                            maxDepth = depthOfPath(keys[i]);
                        }
                    }
                    return base;
                };
            for (i = 0; i < resolveObject.items.length; i++) {
                if (resolveObject.items[i].selected === 'theirs' && resolveObject.items[i].theirs.value === 'move') {
                    moves[resolveObject.items[i].mine.path] = resolveObject.items[i].theirs.path;
                    //and we also make the move
                    insertAtPath(resolveObject.merge,
                        resolveObject.items[i].theirs.path,
                        getPathOfDiff(resolveObject.merge, resolveObject.items[i].mine.path));
                    removePathFromDiff(resolveObject.merge, resolveObject.items[i].mine.path);
                } else {
                    filteredItems.push(resolveObject.items[i]);
                }
            }
            resolveObject.items = filteredItems;

            //in a second run we modify all sub-path of the moves paths
            for (i = 0; i < resolveObject.items.length; i++) {
                if (resolveObject.items[i].selected === 'theirs') {
                    path = moveBaseOfPath(resolveObject.items[i].theirs.path);
                    if (path) {
                        resolveObject.items[i].theirs.path =
                            resolveObject.items[i].theirs.path.replace(path, moves[path]);
                    }
                    path = moveBaseOfPath(resolveObject.items[i].mine.path);
                    if (path) {
                        resolveObject.items[i].mine.path = resolveObject.items[i].mine.path.replace(path, moves[path]);
                    }
                }
            }
        }

        //</editor-fold>

        //<editor-fold=Added Methods>
        this.nodeDiff = function (source, target) {
            var diff = {
                children: childrenDiff(source, target),
                attr: attrDiff(source, target),
                reg: regDiff(source, target),
                pointer: pointerDiff(source, target),
                set: setDiff(source, target),
                meta: metaDiff(source, target)
            };

            normalize(diff);

            return isEmptyNodeDiff(diff) ? null : diff;
        };

        this.generateTreeDiff = function (sRoot, tRoot) {
            _yetToCompute = {};
            _DIFF = {};
            _diffMoves = {};
            _needChecking = true;
            _rounds = 0;
            return TASYNC.call(function (d) {
                _DIFF = d;
                return checkRound();
            }, updateDiff(sRoot, tRoot));
        };

        this.generateLightTreeDiff = function (sRoot, tRoot) {
            return updateDiff(sRoot, tRoot);
        };

        this.applyTreeDiff = function (root, diff) {
            // return TASYNC.join(makeInitialContainmentChanges(root, diff), applyNodeChange(root, '', diff));
            // return makeInitialContainmentChanges(root,diff);
            var done = makeInitialContainmentChanges(root, diff);

            done = TASYNC.call(setBaseRelationsOfNewNodes, root, '', diff, done);

            return TASYNC.call(function () {
                return applyNodeChange(root, '', diff);
            }, done);
            // done = TASYNC.call(applyNodeChange, root, '', diff, done);

            // return done;
        };

        this.tryToConcatChanges = function (base, extension) {
            var result = {};
            _conflictItems = [];
            _conflictMine = {};
            _conflictTheirs = {};
            _concatBase = base;
            _concatExtension = extension;
            _concatBaseRemovals = {};
            _concatMoves = {
                getBaseSourceFromDestination: {},
                getBaseDestinationFromSource: {},
                getExtensionSourceFromDestination: {},
                getExtensionDestinationFromSource: {}
            };

            completeConcatBase(base, extension);
            getMoveSources(base,
                '', _concatMoves.getBaseSourceFromDestination, _concatMoves.getBaseDestinationFromSource);
            getMoveSources(extension,
                '', _concatMoves.getExtensionSourceFromDestination, _concatMoves.getExtensionDestinationFromSource);
            getConcatBaseRemovals(base);
            getConcatBaseRemovals(extension);

            fixCollision('', null, _concatBase, _concatExtension);
            tryToConcatNodeChange(_concatExtension, '');

            result.items = generateConflictItems();
            result.mine = _conflictMine;
            result.theirs = _conflictTheirs;
            result.merge = _concatBase;
            harmonizeConflictPaths(result.merge);

            return result;
        };

        this.applyResolution = function (conflictObject) {
            //we apply conflict items to the merge and return it as a diff
            var i;
            resolveMoves(conflictObject);
            for (i = 0; i < conflictObject.items.length; i++) {
                if (conflictObject.items[i].selected !== 'mine') {
                    removePathFromDiff(conflictObject.merge, conflictObject.items[i].mine.path);
                    insertAtPath(conflictObject.merge,
                        conflictObject.items[i].theirs.path, conflictObject.items[i].theirs.value);
                }
            }

            return conflictObject.merge;
        };
        //</editor-fold>
    }

    return DiffCore;
});

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/metacachecore',[
        'common/util/assert',
        'common/core/tasync',
        'common/core/constants'
    ], function (ASSERT, TASYNC, CONSTANTS) {
        'use strict';

        var MetaCacheCore = function (innerCore, options) {
            ASSERT(typeof options === 'object');
            ASSERT(typeof options.globConf === 'object');
            ASSERT(typeof options.logger !== 'undefined');

            var logger = options.logger,
                self = this,
                key;

            for (key in innerCore) {
                this[key] = innerCore[key];
            }

            logger.debug('initialized MetaCacheCore');

            //<editor-fold=Helper Functions>
            function loadMetaSet(root) {
                var paths = innerCore.getMemberPaths(root, CONSTANTS.META_SET_NAME),
                    i,
                    metaNodes = [];

                return TASYNC.call(function () {
                    for (i = 0; i < paths.length; i += 1) {
                        metaNodes.push(innerCore.loadByPath(root, paths[i]));
                    }

                    return TASYNC.lift(metaNodes);
                }, self.loadPaths(self.getHash(root), JSON.parse(JSON.stringify(paths))));
            }

            //</editor-fold>

            //<editor-fold=Modified Methods>
            this.loadRoot = function (hash) {
                return TASYNC.call(function (root) {
                    return TASYNC.call(function (elements) {
                        var i = 0;
                        root.metaNodes = {};
                        for (i = 0; i < elements.length; i += 1) {
                            // It can happen that some elements just been removed during load because of missing base.
                            if (elements[i]) {
                                root.metaNodes[innerCore.getPath(elements[i])] = elements[i];
                            }
                        }
                        return root;
                    }, loadMetaSet(root));
                }, innerCore.loadRoot(hash));
            };

            this.loadByPath = function (node, path) {
                return TASYNC.call(function () {
                    return innerCore.loadByPath(node, path);
                }, self.loadPaths(self.getHash(node), [path]));
            };

            //functions where the cache may needs to be updated
            this.createNode = function (parameters) {
                var node = innerCore.createNode(parameters);

                if (!parameters || !parameters.parent) {
                    //a root just have been created
                    node.metaNodes = {};
                }

                return node;
            };

            this.addMember = function (node, setName, member) {
                var root = self.getRoot(node);
                innerCore.addMember(node, setName, member);

                //check if our cache needs to be updated
                if (setName === CONSTANTS.META_SET_NAME && self.getPath(node) === self.getPath(root)) {
                    root.metaNodes[self.getPath(member)] = member;
                }
            };

            this.delMember = function (node, setName, memberPath) {
                var root = self.getRoot(node);
                innerCore.delMember(node, setName, memberPath);

                //check if our cache needs to be updated
                if (setName === CONSTANTS.META_SET_NAME && self.getPath(node) === self.getPath(root)) {
                    delete root.metaNodes[memberPath];
                }
            };

            this.deleteNode = function (node, technical) {
                var root = self.getRoot(node);
                if (root.metaNodes[self.getPath(node)]) {
                    delete root.metaNodes[self.getPath(node)];
                }
                innerCore.deleteNode(node, technical);
            };

            this.moveNode = function (node, parent) {
                var root = self.getRoot(node),
                    oldpath = self.getPath(node),
                    moved = innerCore.moveNode(node, parent);

                if (root.metaNodes[oldpath]) {
                    delete root.metaNodes[oldpath];
                    root.metaNodes[self.getPath(moved)] = moved;
                }

                return moved;
            };
            //</editor-fold>

            //<editor-fold=Added Methods>
            this.isMetaNode = function (node) {
                var root = self.getRoot(node);
                if (root.metaNodes && root.metaNodes[self.getPath(node)]) {
                    return true;
                }

                return false;
            };

            this.getAllMetaNodes = function (node) {
                var root = self.getRoot(node);

                if (root.metaNodes) {
                    return root.metaNodes;
                }

                return {};
            };

            this.getFCO = function (node) {
                var root = self.getRoot(node),
                    key;

                for (key in root.metaNodes) {
                    return self.getBaseRoot(root.metaNodes[key]);
                }

                return null; //if there is no object on META, there is no FCO!!! 
            };

            //</editor-fold>
        };

        return MetaCacheCore;
    }
);
/*globals define*/
/*jshint node: true, browser: true*/
/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/mixincore',[
    'common/util/assert',
    'common/core/tasync',
    'common/util/canon',
    'common/core/constants'
], function (ASSERT, TASYNC, CANON, CONSTANTS) {
    'use strict';

    var MixinCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            key,
            self = this;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MixinCore');

        //<editor-fold=Helper Functions>

        function realNode(node) { //TODO we have to make some more sophisticated distinction
            if (self.getPath(node).indexOf('_') !== -1) {
                return false;
            }
            return true;
        }

        function getOrderedMixinList(node) {
            var paths = self.getMixinPaths(node),
                metaNodes,
                helper = {},
                orderedList = [],
                guid,
                i;

            if (paths.length === 0) {
                return orderedList;
            }

            metaNodes = self.getAllMetaNodes(node);

            for (i = 0; i < paths.length; i += 1) {
                if (metaNodes[paths[i]]) {
                    guid = self.getGuid(metaNodes[paths[i]]);
                    helper[guid] = paths[i];
                    orderedList.push(guid);
                }

            }

            orderedList.sort();

            for (i = 0; i < orderedList.length; i += 1) {
                orderedList[i] = metaNodes[helper[orderedList[i]]];
            }

            return orderedList;
        }

        function getNodeDictionary(node, paths) {
            var allMetaNodes = self.getAllMetaNodes(node),
                dictionary = {},
                i;

            for (i = 0; i < paths.length; i += 1) {
                if (allMetaNodes[paths[i]]) {
                    dictionary[paths[i]] = allMetaNodes[paths[i]];
                }
            }

            return dictionary;
        }

        function extendUniqueArray(base, extension) {
            var i;

            for (i = 0; i < extension.length; i += 1) {
                if (base.indexOf(extension[i]) === -1) {
                    base.push(extension[i]);
                }
            }
        }

        function getExtendedUniqueKeyedObject(base, extension) {
            var extended = {},
                key;
            for (key in base) {
                extended[key] = base[key];
            }

            for (key in extension) {
                if (!base[key]) {
                    extended[key] = extension[key];
                }
            }

            return extended;
        }

        function getValidNames(node, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                names,
                mixins = getOrderedMixinList(node),
                i;

            if (alreadyVisited[path]) {
                return [];
            }

            if (base) {
                names = getValidNames(base, getter, alreadyVisited);
            } else {
                names = [];
            }

            extendUniqueArray(names, getter(node));
            alreadyVisited[path] = true;

            for (i = 0; i < mixins.length; i += 1) {
                extendUniqueArray(names, getValidNames(mixins[i], getter, alreadyVisited));
            }

            return names;
        }

        function getFirstMatchingRuleHolder(node, name, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                mixins = getOrderedMixinList(node),
                ruleHolder = null,
                i;

            if (alreadyVisited[path]) {
                return null;
            }

            //when it comes to rule holder, always the given node's own rule-set is the first
            alreadyVisited[path] = true;
            if (getter(node).indexOf(name) !== -1) {
                return node;
            }

            if (base) {
                ruleHolder = getFirstMatchingRuleHolder(base, name, getter, alreadyVisited);

                if (ruleHolder) {
                    return ruleHolder;
                }
            }

            for (i = 0; i < mixins.length; i += 1) {
                ruleHolder = getFirstMatchingRuleHolder(mixins[i], name, getter, alreadyVisited);
                if (ruleHolder) {
                    return ruleHolder;
                }
            }

            return null;
        }

        function getAllMatchingRuleHolders(node, name, getter, alreadyVisited) {
            var base = self.getBase(node),
                path = self.getPath(node),
                mixins = getOrderedMixinList(node),
                ruleHolders = [],
                i;

            if (alreadyVisited[path]) {
                return [];
            }

            //when it comes to rule holder, always the given node's own rule-set is the first
            alreadyVisited[path] = true;
            if (getter(node).indexOf(name) !== -1) {
                ruleHolders.push(node);
            }

            if (base) {
                ruleHolders = ruleHolders.concat(getAllMatchingRuleHolders(base, name, getter, alreadyVisited));
            }

            for (i = 0; i < mixins.length; i += 1) {
                ruleHolders = ruleHolders.concat(getAllMatchingRuleHolders(mixins[i], name, getter, alreadyVisited));

            }

            return ruleHolders;
        }

        function getFirstMatchingMeta(node, name, matchFuction, getFunction) {
            var metaRuleHolder = getFirstMatchingRuleHolder(node, name, matchFuction, {});

            if (metaRuleHolder) {
                return getFunction(metaRuleHolder, name);
            }

            return undefined;
        }

        function allValidRelationsNameGetter(node) {
            return innerCore.getOwnValidPointerNames(node).concat(innerCore.getOwnValidSetNames(node));
        }

        function containmentGetter(node) {
            return ['containment'];
        }

        function isTypeOf(node, typeNode, alreadyVisited) {
            var base, mixins, i,
                path = self.getPath(node);

            if (alreadyVisited[path]) {
                return false;
            }

            alreadyVisited[path] = true;

            if (innerCore.isTypeOf(node, typeNode)) {
                return true;
            }

            base = self.getBase(node);
            if (base && isTypeOf(base, typeNode, alreadyVisited)) {
                return true;
            }

            mixins = getOrderedMixinList(node);
            for (i = 0; i < mixins.length; i += 1) {
                if (isTypeOf(mixins[i], typeNode, alreadyVisited)) {
                    return true;
                }
            }

            return false;
        }

        function convertRuleToItemizedArraySet(rule) {
            var items = [],
                minItems = [],
                maxItems = [],
                i;

            for (i in rule) {
                if (i !== 'min' && i !== 'max') {
                    items.push(i);
                    minItems.push(rule[i].min || -1);
                    maxItems.push(rule[i].max || -1);
                    delete rule[i];
                }
            }

            rule.items = items;
            rule.minItems = minItems;
            rule.maxItems = maxItems;
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>

        this.isTypeOf = function (node, typeNode) {
            //TODO implement
            if (!realNode(node)) {
                return false;
            }

            return isTypeOf(node, typeNode, {});
        };

        this.isValidChildOf = function (node, parentNode) {
            if (!realNode(node)) {
                return true;
            }
            var childrenPaths,
                metaNodes,
                i;

            if (innerCore.isValidChildOf(node, parentNode)) {
                return true;
            }

            // Now we have to look deeper as containment rule may come from a mixin
            childrenPaths = self.getValidChildrenPaths(parentNode);
            metaNodes = self.getAllMetaNodes(node);

            for (i = 0; i < childrenPaths.length; i += 1) {
                if (metaNodes[childrenPaths[i]] && self.isTypeOf(node, metaNodes[childrenPaths[i]])) {
                    return true;
                }
            }
            return false;
        };

        this.isValidTargetOf = function (node, source, name) {
            if (!realNode(source) || node === null) {
                return true;
            }

            var targetPaths,
                metaNodes,
                i;

            if (innerCore.isValidTargetOf(node, source, name)) {
                return true;
            }

            // Now we have to look deeper as pointer rule may come from a mixin
            targetPaths = self.getValidTargetPaths(source, name);
            metaNodes = self.getAllMetaNodes(node);

            for (i = 0; i < targetPaths.length; i += 1) {
                if (metaNodes[targetPaths[i]] && self.isTypeOf(node, metaNodes[targetPaths[i]])) {
                    return true;
                }
            }

            return false;
        };

        this.isValidAttributeValueOf = function (node, name, value) {
            if (!realNode(node)) {
                return true;
            }

            var ruleHolder = getFirstMatchingRuleHolder(node, name, innerCore.getOwnValidAttributeNames, {});

            if (ruleHolder) {
                return innerCore.isValidAttributeValueOf(ruleHolder, name, value);
            }

            return false;
        };

        this.getValidPointerNames = function (node) {
            return getValidNames(node, innerCore.getOwnValidPointerNames, {});
        };

        this.getValidSetNames = function (node) {
            return getValidNames(node, innerCore.getOwnValidSetNames, {});
        };

        this.getValidAttributeNames = function (node) {
            if (!realNode(node)) {
                return [];
            }

            return getValidNames(node, innerCore.getOwnValidAttributeNames, {});
        };

        this.getValidAspectNames = function (node) {
            return getValidNames(node, innerCore.getOwnValidAspectNames, {});
        };

        this.getConstraintNames = function (node) {
            return getValidNames(node, innerCore.getConstraintNames, {});
        };

        this.getJsonMeta = function (node) {
            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},
                nullRule = {items: [], minItems: [], maxItems: []},
                tempNode,
                names,
                pointer,
                i, j;

            meta.children = self.getChildrenMeta(node);
            if (meta.children) {
                convertRuleToItemizedArraySet(meta.children);
            } else {
                meta.children = nullRule;
            }

            //attributes
            names = self.getValidAttributeNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.attributes[names[i]] = self.getAttributeMeta(node, names[i]);
            }

            //pointers
            names = self.getValidPointerNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.pointers[names[i]] = self.getPointerMeta(node, names[i]);
                convertRuleToItemizedArraySet(meta.pointers[names[i]]);
            }

            //sets
            names = self.getValidSetNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.pointers[names[i]] = self.getPointerMeta(node, names[i]);
                convertRuleToItemizedArraySet(meta.pointers[names[i]]);
            }

            //aspects
            names = self.getValidAspectNames(node);

            for (i = 0; i < names.length; i += 1) {
                meta.aspects[names[i]] = self.getAspectMeta(node, names[i]);
            }

            //constraints
            names = self.getConstraintNames(node);
            for (i = 0; i < names.length; i += 1) {
                meta.constraints[names[i]] = self.getConstraint(node, names[i]);
            }

            return meta;
        };

        this.getOwnJsonMeta = function (node) {
            // We have to extend the meta definition by the mixins, but only if we talk about the own rule-set.
            var jsonMeta = innerCore.getOwnJsonMeta(node),
                mixins = this.getMixinPaths(node);

            if (mixins.length > 0) {
                jsonMeta.mixins = mixins;
            }

            return jsonMeta;
        };

        this.getValidChildrenPaths = function (node) {
            return getValidNames(node, innerCore.getValidChildrenPaths, {});
        };

        this.getChildrenMeta = function (node) {
            var ruleHolders = getAllMatchingRuleHolders(node, 'containment', containmentGetter, {}),
                childrenMeta = {},
                i;

            for (i = 0; i < ruleHolders.length; i += 1) {
                childrenMeta = getExtendedUniqueKeyedObject(childrenMeta, innerCore.getChildrenMeta(ruleHolders[i]));
            }

            if (Object.keys(childrenMeta).length === 0) {
                return null;
            }

            return childrenMeta;
        };

        this.getPointerMeta = function (node, name) {
            var ruleHolders = getAllMatchingRuleHolders(node, name, allValidRelationsNameGetter, {}),
                i,
                pointerMeta = {};

            if (ruleHolders.length === 0) {
                return undefined;
            }

            for (i = 0; i < ruleHolders.length; i += 1) {
                pointerMeta = getExtendedUniqueKeyedObject(pointerMeta, innerCore.getPointerMeta(ruleHolders[i], name));
            }
            return pointerMeta;
        };

        this.getValidTargetPaths = function (node, name) {
            var getTargetPaths = function (getNode) {
                return innerCore.getValidTargetPaths(getNode, name);
            };

            return getValidNames(node, getTargetPaths, {});
        };

        this.getAttributeMeta = function (node, name) {
            return getFirstMatchingMeta(node, name, innerCore.getOwnValidAttributeNames, innerCore.getAttributeMeta);
        };

        this.getAspectMeta = function (node, name) {
            return getFirstMatchingMeta(node, name, innerCore.getOwnValidAspectNames, innerCore.getAspectMeta);
        };

        this.getSetNames = function (node) {
            var rawNames = innerCore.getSetNames(node),
                index = rawNames.indexOf(CONSTANTS.MIXINS_SET);

            if (index !== -1) {
                rawNames.splice(index, 1);
            }

            return rawNames;
        };

        //</editor-fold>

        //<editor-fold=Added Methods>

        this.getMixinErrors = function (node) {
            var errors = [],
                mixinPaths = self.getMixinPaths(node),
                allMetaNodes = self.getAllMetaNodes(node),
                mixinNodes = getOrderedMixinList(node),
                targetNode,
                targetInfoTxt,
                definitions,
                ownName = self.getAttribute(node, 'name'),
                names,
                base = self.getBase(node),
                ownKeys,
                keys,
                name,
                path,
                i, j, k;

            logger.debug('getMixinErrors(' + ownName + ')');

            //mixin is missing from meta
            for (i = 0; i < mixinPaths.length; i += 1) {
                if (!allMetaNodes[mixinPaths[i]]) {
                    logger.error('mixin node is missing from Meta [' + mixinPaths[i] + ']');
                    errors.push({
                        severity: 'error',
                        nodeName: ownName,
                        type: CONSTANTS.MIXIN_ERROR_TYPE.MISSING,
                        targetInfo: mixinPaths[i],
                        message: '[' + ownName + ']: mixin node \'' + mixinPaths[i] + '\' is missing from the Meta',
                        hint: 'Remove mixin or add to the Meta'
                    });
                }
            }

            //attribute definition collisions
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getValidAttributeNames(base);
            }
            extendUniqueArray(ownKeys, self.getOwnValidAttributeNames(node));

            for (i = 0; i < mixinNodes.length; i += 1) {
                name = self.getAttribute(mixinNodes[i], 'name');
                path = self.getPath(mixinNodes[i]);
                keys = self.getValidAttributeNames(mixinNodes[i]);

                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            logger.warn('colliding attribute (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.ATTRIBUTE_COLLISION,
                                nodeName: ownName,
                                ruleName: keys[j],
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits attribute definition \'' +
                                keys[j] + '\' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            //containment collisions
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getValidChildrenPaths(base);
            }
            extendUniqueArray(ownKeys, self.getOwnValidChildrenPaths(node));

            for (i = 0; i < mixinNodes.length; i += 1) {
                name = self.getAttribute(mixinNodes[i], 'name');
                keys = self.getValidChildrenPaths(mixinNodes[i]);
                path = self.getPath(mixinNodes[i]);

                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            targetNode = allMetaNodes[keys[j]];
                            if (targetNode) {
                                targetInfoTxt = '[' + self.getAttribute(targetNode, 'name') + ']';
                            } else {
                                targetInfoTxt = '\'' + keys[j] + '\'';
                            }
                            logger.warn('colliding child (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.CONTAINMENT_COLLISION,
                                nodeName: ownName,
                                targetInfo: keys[j],
                                targetNode: targetNode,
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits child definition for ' +
                                targetInfoTxt + ' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            //pointer target collisions
            names = this.getValidPointerNames(node);
            for (i = 0; i < names.length; i += 1) {
                definitions = {};
                ownKeys = [];
                if (base) {
                    ownKeys = self.getValidTargetPaths(base, names[i]);
                }
                extendUniqueArray(ownKeys, self.getOwnValidTargetPaths(node, names[i]));
                for (j = 0; j < mixinNodes.length; j += 1) {
                    keys = self.getValidTargetPaths(mixinNodes[j], names[i]);
                    name = self.getAttribute(mixinNodes[j], 'name');
                    path = self.getPath(mixinNodes[j]);
                    for (k = 0; k < keys.length; k += 1) {
                        if (ownKeys.indexOf(keys[k]) === -1 && keys[k] !== 'min' && keys[k] !== 'max') {
                            if (definitions[keys[k]]) {
                                targetNode = allMetaNodes[keys[k]];
                                if (targetNode) {
                                    targetInfoTxt = '[' + self.getAttribute(targetNode, 'name') + ']';
                                } else {
                                    targetInfoTxt = '\'' + keys[k] + '\'';
                                }
                                logger.warn('colliding pointer (' + names[i] + ') target (' + keys[k] +
                                    ') definition [' + definitions[keys[k]].name + ']vs[' + name + ']');
                                errors.push({
                                    severity: 'warning',
                                    type: CONSTANTS.MIXIN_ERROR_TYPE.POINTER_COLLISION,
                                    nodeName: ownName,
                                    ruleName: names[i],
                                    targetInfo: keys[k],
                                    targetNode: targetNode,
                                    collisionPaths: [definitions[keys[k]].path, path],
                                    collisionNodes: [mixinNodes[definitions[keys[k]].index], mixinNodes[j]],
                                    message: '[' + ownName + ']: inherits pointer (' + names[i]
                                    + ') target definition of ' + targetInfoTxt +
                                    ' from [' + definitions[keys[k]].name + '] and [' + name + ']',
                                    hint: 'Remove one of the mixin relations'
                                });
                            } else {
                                definitions[keys[k]] = {name: name, path: path, index: i};
                            }
                        }
                    }
                }
            }

            //set member collisions
            names = this.getValidSetNames(node);
            for (i = 0; i < names.length; i += 1) {
                definitions = {};
                ownKeys = [];
                if (base) {
                    ownKeys = self.getValidTargetPaths(base, names[i]);
                }
                extendUniqueArray(ownKeys, self.getOwnValidTargetPaths(node, names[i]));
                for (j = 0; j < mixinNodes.length; j += 1) {
                    keys = self.getValidTargetPaths(mixinNodes[j], names[i]);
                    name = self.getAttribute(mixinNodes[j], 'name');
                    path = self.getPath(mixinNodes[j]);
                    for (k = 0; k < keys.length; k += 1) {
                        if (ownKeys.indexOf(keys[k]) === -1 && keys[k] !== 'min' && keys[k] !== 'max') {
                            if (definitions[keys[k]]) {
                                targetNode = allMetaNodes[keys[k]];
                                if (targetNode) {
                                    targetInfoTxt = '[' + self.getAttribute(targetNode, 'name') + ']';
                                } else {
                                    targetInfoTxt = '\'' + keys[k] + '\'';
                                }
                                logger.warn('colliding set (' + names[i] + ') member (' + keys[k] +
                                    ') definition [' + definitions[keys[k]].name + ']vs[' + name + ']');
                                errors.push({
                                    severity: 'warning',
                                    type: CONSTANTS.MIXIN_ERROR_TYPE.SET_COLLISION,
                                    nodeName: ownName,
                                    ruleName: names[i],
                                    targetInfo: keys[k],
                                    targetNode: targetNode,
                                    collisionPaths: [definitions[keys[k]].path, path],
                                    collisionNodes: [mixinNodes[definitions[keys[k]].index], mixinNodes[j]],
                                    message: '[' + ownName + ']: inherits set (' + names[i]
                                    + ') member definition of ' + targetInfoTxt +
                                    ' from [' + definitions[keys[k]].name + '] and [' + name + ']',
                                    hint: 'Remove one of the mixin relations'
                                });
                            } else {
                                definitions[keys[k]] = {name: name, path: path, index: i};
                            }
                        }
                    }
                }
            }

            //aspect collisions
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getValidAspectNames(base);
            }
            extendUniqueArray(ownKeys, self.getOwnValidAspectNames(node));
            for (i = 0; i < mixinNodes.length; i += 1) {
                keys = self.getValidAspectNames(mixinNodes[i]);
                name = self.getAttribute(mixinNodes[i], 'name');
                path = self.getPath(mixinNodes[i]);
                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            logger.warn('colliding aspect (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.ASPECT_COLLISION,
                                nodeName: ownName,
                                ruleName: keys[j],
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits aspect definition \'' + keys[j] +
                                '\' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            //constraint collision
            definitions = {};
            ownKeys = [];
            if (base) {
                ownKeys = self.getConstraintNames(base);
            }
            extendUniqueArray(ownKeys, self.getOwnConstraintNames(node));
            for (i = 0; i < mixinNodes.length; i += 1) {
                keys = self.getConstraintNames(mixinNodes[i]);
                name = self.getAttribute(mixinNodes[i], 'name');
                for (j = 0; j < keys.length; j += 1) {
                    if (ownKeys.indexOf(keys[j]) === -1) {
                        if (definitions[keys[j]]) {
                            logger.warn('colliding constraint (' + keys[j] + ') definition [' +
                                definitions[keys[j]].name + ']vs[' + name + ']');
                            errors.push({
                                severity: 'warning',
                                type: CONSTANTS.MIXIN_ERROR_TYPE.CONSTRAINT_COLLISION,
                                nodeName: ownName,
                                ruleName: keys[j],
                                collisionPaths: [definitions[keys[j]].path, path],
                                collisionNodes: [mixinNodes[definitions[keys[j]].index], mixinNodes[i]],
                                message: '[' + ownName + ']: inherits constraint definition \'' + keys[j] +
                                '\' from [' + definitions[keys[j]].name + '] and [' + name + ']',
                                hint: 'Remove one of the mixin relations'
                            });
                        } else {
                            definitions[keys[j]] = {name: name, path: path, index: i};
                        }
                    }
                }
            }

            logger.debug('getMixinErrors(' + ownName + ') finished');
            return errors;
        };

        this.getMixinPaths = function (node) {
            return innerCore.getOwnMemberPaths(node, CONSTANTS.MIXINS_SET);
        };

        this.getMixinNodes = function (node) {
            var paths = self.getMixinPaths(node);
            return getNodeDictionary(node, paths);
        };

        this.delMixin = function (node, mixinPath) {
            var metaNodes = innerCore.getAllMetaNodes(node);

            innerCore.delMember(node, CONSTANTS.MIXINS_SET, mixinPath);
        };

        this.addMixin = function (node, mixinPath) {
            var metaNodes = innerCore.getAllMetaNodes(node);

            if (metaNodes[mixinPath]) {
                innerCore.addMember(node, CONSTANTS.MIXINS_SET, metaNodes[mixinPath]);
            }
        };

        this.clearMixins = function (node) {
            self.deleteSet(node, CONSTANTS.MIXINS_SET);
        };

        this.getBaseTypes = function (node) {
            var metaType = innerCore.getBaseType(node),
                metaTypes = [];

            if (metaType) {
                metaTypes = getOrderedMixinList(metaType);
                metaTypes.unshift(metaType);
            }

            return metaTypes;
        };

        this.canSetAsMixin = function (node, mixinPath) {
            var result = {
                    isOk: true,
                    reason: ''
                },
                mixinNode = self.getAllMetaNodes(node)[mixinPath];

            if (self.getPath(node) === mixinPath) {
                result.isOk = false;
                result.reason = 'Node cannot be mixin of itself!';
            } else if (!mixinNode) {
                result.isOk = false;
                result.reason = 'Mixin must be on the Meta!';
            } else if (innerCore.isTypeOf(node, mixinNode)) {
                result.isOk = false;
                result.reason = 'Base of node cannot be its mixin as well!';
            }

            return result;
        };
        //</editor-fold>
    };

    return MixinCore;
});
/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/metaquerycore',[
    'common/util/assert'
], function (ASSERT) {
    'use strict';

    var MetaQueryCore = function (innerCore, options) {
        ASSERT(typeof options === 'object');
        ASSERT(typeof options.globConf === 'object');
        ASSERT(typeof options.logger !== 'undefined');

        var logger = options.logger,
            self = this,
            key;

        for (key in innerCore) {
            this[key] = innerCore[key];
        }

        logger.debug('initialized MetaQueryCore');

        //<editor-fold=Helper Functions>
        function sensitiveFilter(validNodes) {
            var i;

            i = validNodes.length;
            while (i--) {
                if (self.isConnection(validNodes[i]) || self.isAbstract(validNodes[i])) {
                    validNodes.splice(i, 1);
                }
            }
        }

        //</editor-fold>

        //<editor-fold=Modified Methods>
        //</editor-fold>

        //<editor-fold=Added Methods>
        this.isAbstract = function (node) {
            return self.getRegistry(node, 'isAbstract') === true;
        };

        this.isConnection = function (node) {
            var validPtrNames = innerCore.getValidPointerNames(node);

            return validPtrNames.indexOf('dst') !== -1 && validPtrNames.indexOf('src') !== -1;
        };

        this.getValidChildrenMetaNodes = function (parameters) {
            var validNodes = [],
                node = parameters.node,
                metaNodes = self.getAllMetaNodes(node),
                keys = Object.keys(metaNodes || {}),
                i, j,
                typeCounters = {},
                children = parameters.children || [],
                rules,
                inAspect;

            rules = innerCore.getChildrenMeta(node) || {};

            for (i = 0; i < keys.length; i += 1) {
                if (self.isValidChildOf(metaNodes[keys[i]], node)) {
                    validNodes.push(metaNodes[keys[i]]);
                }
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.sensitive === true) {
                sensitiveFilter(validNodes);
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.multiplicity === true) {
                if (rules.max && rules.max > -1 && innerCore.getChildrenRelids(node).length >= rules.max) {
                    validNodes = [];
                    return validNodes;
                }
                if (children.length === 0) {
                    return validNodes; //we cannot check type-multiplicity without children
                }

                delete rules.max;
                delete rules.min;

                //we need to clear nodes that are not on the meta sheet
                // and we have to initialize the counters
                keys = Object.keys(rules);
                for (i = 0; i < keys.length; i += 1) {
                    if (metaNodes[keys[i]]) {
                        typeCounters[keys[i]] = 0;
                    } else {
                        delete rules[keys[i]];
                    }
                }

                keys = Object.keys(rules);
                for (i = 0; i < children.length; i += 1) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (innerCore.isTypeOf(children[i], metaNodes[keys[j]])) {
                            typeCounters[keys[j]] += 1;
                        }
                    }
                }

                i = validNodes.length;
                keys = Object.keys(typeCounters);
                while (i--) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (rules[keys[j]].max &&
                            rules[keys[j]].max > -1 &&
                            rules[keys[j]].max <= typeCounters[keys[j]] &&
                            innerCore.isTypeOf(validNodes[i], metaNodes[keys[j]])) {
                            validNodes.splice(i, 1); //FIXME slow, use only push instead
                            break;
                        }
                    }
                }
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.aspect) {
                keys = innerCore.getAspectMeta(node, parameters.aspect);
                i = validNodes.length;

                while (i--) {
                    inAspect = false;
                    for (j = 0; j < keys.length; j += 1) {
                        if (innerCore.isTypeOf(validNodes[i], metaNodes[keys[j]])) {
                            inAspect = true;
                            break;
                        }
                    }
                    if (!inAspect) {
                        validNodes.splice(i, 1);
                    }
                }
            }
            return validNodes;
        };

        this.getValidSetElementsMetaNodes = function (parameters) {
            var validNodes = [],
                node = parameters.node,
                name = parameters.name,
                metaNodes = self.getAllMetaNodes(node),
                keys = Object.keys(metaNodes || {}),
                i, j,
                typeCounters = {},
                members = parameters.members || [],
                rules = self.getPointerMeta(node, name) || {};

            for (i = 0; i < keys.length; i += 1) {
                if (metaNodes[keys[i]] && self.isValidTargetOf(metaNodes[keys[i]], node, name)) {
                    validNodes.push(metaNodes[keys[i]]);
                }
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.sensitive === true) {
                sensitiveFilter(validNodes);
            }

            //before every next step we check if we still have potential nodes
            if (validNodes.length === 0) {
                return validNodes;
            }

            if (parameters.multiplicity === true) {
                if (rules.max && rules.max > -1 && innerCore.getMemberPaths(node).length >= rules.max) {
                    validNodes = [];
                    return validNodes;
                }

                if (members.length === 0) {
                    return validNodes; //we cannot check type-multiplicity without children
                }

                delete rules.max;
                delete rules.min;

                //we need to clear nodes that are not on the meta sheet
                // and we have to initialize the counters
                keys = Object.keys(rules);
                for (i = 0; i < keys.length; i += 1) {
                    if (!metaNodes[keys[i]]) {
                        delete rules[keys[i]];
                    } else {
                        typeCounters[keys[i]] = 0;
                    }
                }

                keys = Object.keys(rules);
                for (i = 0; i < members.length; i += 1) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (innerCore.isTypeOf(members[i], metaNodes[keys[j]])) {
                            typeCounters[keys[j]] += 1;
                        }
                    }
                }

                i = validNodes.length;
                keys = Object.keys(typeCounters);
                while (i--) {
                    for (j = 0; j < keys.length; j += 1) {
                        if (rules[keys[j]].max &&
                            rules[keys[j]].max > -1 &&
                            rules[keys[j]].max <= typeCounters[keys[j]] &&
                            innerCore.isTypeOf(validNodes[i], metaNodes[keys[j]])) {
                            validNodes.splice(i, 1); //FIXME slow, use only push instead
                            break;
                        }
                    }
                }
            }

            return validNodes;
        };
        //</editor-fold>
    };

    return MetaQueryCore;
});
/*globals define*/
/*jshint node: true, browser: true*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/core/librarycore',[
        'common/util/assert',
        'common/core/tasync',
        'common/core/constants',
        'common/util/random'
    ], function (ASSERT, TASYNC, CONSTANTS, RANDOM) {
        'use strict';

        var LibraryCore = function (innerCore, options) {
            ASSERT(typeof options === 'object');
            ASSERT(typeof options.globConf === 'object');
            ASSERT(typeof options.logger !== 'undefined');

            var logger = options.logger,
                self = this,
                key;

            for (key in innerCore) {
                this[key] = innerCore[key];
            }

            logger.debug('initialized LibraryCore');

            //<editor-fold=Helper Functions>
            function getAllLibraryRoots(node) {
                var roots = [];
                while (node) {
                    if (self.isLibraryRoot(node)) {
                        roots.push(node);
                    }
                    node = self.getParent(node);
                }

                return roots;
            }

            function getLibraryName(node) {
                ASSERT(self.isValidNode(node));
                var name = '';

                node = self.getParent(node);

                while (node) {
                    if (self.isLibraryRoot(node) && self.getParent(node) !== null) {
                        name = self.getAttribute(node, 'name') + CONSTANTS.NAMESPACE_SEPARATOR + name;
                    }
                    node = self.getParent(node);
                }

                return name;
            }

            function getLibraryRootsInfo(node) {
                var allMetaNodes = self.getAllMetaNodes(node),
                    libraryRoots = {},
                    path,
                    roots,
                    i,
                    name;

                for (path in allMetaNodes) {
                    roots = getAllLibraryRoots(allMetaNodes[path]);
                    for (i = 0; i < roots.length; i += 1) {
                        name = getLibraryName(roots[i]) + self.getAttribute(roots[i], 'name');
                        if (!libraryRoots[name]) {
                            libraryRoots[name] = roots[i];
                        }
                    }
                }

                return libraryRoots;
            }

            function getRootOfLibrary(node, name) {
                return self.getRoot(node).libraryRoots[name];
            }

            function getLibraryRoot(node) {
                while (node) {
                    if (self.isLibraryRoot(node) && !self.isLibraryElement(node)) {
                        return node;
                    }
                    node = self.getParent(node);
                }

                return null;
            }

            function getLibraryInfo(libraryRootHashOrNode) {
                var isNode = typeof libraryRootHashOrNode === 'object',
                    libraryName = '',
                    libraryNamePrefix = '',
                    getPath = function (node) {
                        if (isNode) {
                            return self.getPath(node, libraryRootHashOrNode);
                        } else {
                            return self.getPath(node);
                        }
                    },
                    getName = function (node) {
                        return self.getFullyQualifiedName(node).substr(libraryNamePrefix.length);
                    },
                    getGuid = function (node) {
                        if (isNode) {
                            return self.getLibraryGuid(node, libraryName);
                        } else {
                            return self.getGuid(node);
                        }
                    },
                    load = function () {
                        if (isNode) {
                            return self.loadSubTree(libraryRootHashOrNode);
                        } else {
                            return self.loadTree(libraryRootHashOrNode);
                        }
                    };

                if (isNode) {
                    libraryName = self.getAttribute(libraryRootHashOrNode, 'name');
                    libraryNamePrefix = libraryName + '.';
                }

                return TASYNC.call(function (libraryNodes) {
                    var info = {},
                        infoItem,
                        i;

                    for (i = 1; i < libraryNodes.length; i += 1) {
                        infoItem = {
                            path: getPath(libraryNodes[i]),
                            hash: self.getHash(libraryNodes[i]),
                            fcn: getName(libraryNodes[i])
                        };

                        info[getGuid(libraryNodes[i])] = infoItem;
                    }

                    return info;
                }, load());
                //we use that the root of the library is always the first element
            }

            function removeLibraryRelations(root, path) {
                var overlayItems = self.overlayQuery(root, path),
                    i;

                for (i = 0; i < overlayItems.length; i += 1) {
                    if (overlayItems[i].s === path || overlayItems.t === path) {
                        self.overlayRemove(root, overlayItems[i].s, overlayItems[i].n, overlayItems[i].t);
                    }
                }
            }

            function moveLibraryRelations(root, from, to) {
                var overlayItems = self.overlayQuery(root, from),
                    i;

                for (i = 0; i < overlayItems.length; i += 1) {
                    if (overlayItems[i].s === from) {
                        self.overlayRemove(root, overlayItems[i].s, overlayItems[i].n, overlayItems[i].t);
                        self.overlayInsert(root, to, overlayItems[i].n, overlayItems[i].t);

                    } else if (overlayItems[i].t === from) {
                        self.overlayRemove(root, overlayItems[i].s, overlayItems[i].n, overlayItems[i].t);
                        self.overlayInsert(root, overlayItems[i].s, overlayItems[i].n, to);
                    }
                }

            }

            function isPathInSubTree(fullPath, subTreePath) {
                if (fullPath === subTreePath) {
                    return true;
                }
                if (fullPath.indexOf(subTreePath + CONSTANTS.PATH_SEP) === 0) {
                    return true;
                }

                return false;
            }

            function isClosureInternalTarget(targetPath, closureInfo) {
                var selectionPath;

                for (selectionPath in closureInfo.selection) {
                    if (isPathInSubTree(targetPath, selectionPath)) {
                        return true;
                    }
                }

                return false;
            }

            function collectBaseInformation(baseNode, closureInfo) {
                var libraryRoots = getAllLibraryRoots(baseNode),
                    namespaceInfo = {},
                    i,
                    namespace;

                for (i = 0; i < libraryRoots.length; i += 1) {
                    namespace = self.getFullyQualifiedName(libraryRoots[i]);
                    namespaceInfo[namespace] = {
                        info: self.getLibraryInfo(libraryRoots[i], namespace),
                        guid: self.getLibraryGuid(baseNode, namespace)
                    };
                    if (namespaceInfo[namespace].info && namespaceInfo[namespace].info.hash) {
                        namespaceInfo[namespace].hash = namespaceInfo[namespace].info.hash;
                    }
                }

                closureInfo.bases[self.getGuid(baseNode)] = {
                    originGuid: libraryRoots.length > 0 ? self.getLibraryGuid(baseNode) : self.getGuid(baseNode),
                    name: self.getAttribute(baseNode, 'name'),
                    fullName: self.getFullyQualifiedName(baseNode),
                    namsespaces: namespaceInfo
                };
            }

            function addRelationsFromNodeToClosureInfo(node, allMetaNodes, closureInfo) {
                var basePath = self.getPath(node),
                    overlayInfo = self.getProperty(node, CONSTANTS.OVERLAYS_PROPERTY),
                    overlayKey,
                    pointerName,
                    path,
                    targetPath;

                for (overlayKey in overlayInfo) {
                    path = basePath + overlayKey;
                    if (isClosureInternalTarget(path, closureInfo)) {
                        for (pointerName in overlayInfo[overlayKey]) {
                            if (self.isPointerName(pointerName)) {
                                targetPath = basePath + overlayInfo[overlayKey][pointerName];
                                if (pointerName === CONSTANTS.BASE_POINTER) {
                                    if (allMetaNodes[targetPath]) {
                                        collectBaseInformation(allMetaNodes[targetPath], closureInfo);
                                        closureInfo.relations.preserved[path] =
                                            closureInfo.relations.preserved[path] || {};
                                        closureInfo.relations.preserved[path][CONSTANTS.BASE_POINTER] =
                                            self.getGuid(allMetaNodes[targetPath]);
                                    } else if (isClosureInternalTarget(targetPath, closureInfo)) {
                                        closureInfo.relations.preserved[path] =
                                            closureInfo.relations.preserved[path] || {};
                                        closureInfo.relations.preserved[path][CONSTANTS.BASE_POINTER] = targetPath;
                                    } else {
                                        closureInfo.relations.lost[path] = closureInfo.relations.lost[path] || {};
                                        closureInfo.relations.lost[path][CONSTANTS.BASE_POINTER] = targetPath;
                                    }
                                } else {
                                    if (isClosureInternalTarget(targetPath, closureInfo)) {
                                        closureInfo.relations.preserved[path] =
                                            closureInfo.relations.preserved[path] || {};
                                        closureInfo.relations.preserved[path][pointerName] = targetPath;
                                    } else {
                                        closureInfo.relations.lost[path] = closureInfo.relations.lost[path] || {};
                                        closureInfo.relations.lost[path][pointerName] = targetPath;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function normalizeSelectionForClosure(nodes) {
                var paths = [],
                    i, j,
                    nodesToKeep = [],
                    nodesToCut = {};

                for (i = 0; i < nodes.length; i += 1) {
                    paths.push(self.getPath(nodes[i]));
                }

                for (i = 0; i < paths.length; i += 1) {
                    for (j = 0; j < paths.length; j += 1) {
                        if (i !== j && isPathInSubTree(paths[j], paths[i])) {
                            nodesToCut[paths[j]] = true;
                        }
                    }
                }

                for (i = 0; i < paths.length; i += 1) {
                    if (nodesToCut[paths[i]] !== true) {
                        nodesToKeep.push(nodes[i]);
                    }
                }

                return nodesToKeep;

            }

            function getBasePathOfPath(path, closureInfo) {
                var basePath;

                for (basePath in closureInfo.hashes) {
                    if (isPathInSubTree(path, basePath)) {
                        return basePath;
                    }
                }

                return '';
            }

            function mapRelationEndings(closureInfo) {
                var source,
                    sourceInfo,
                    name,
                    basePath;

                for (source in closureInfo.relations.preserved) {
                    sourceInfo = closureInfo.relations.preserved[source];
                    for (name in sourceInfo) {
                        if (!closureInfo.bases[sourceInfo[name]]) {
                            basePath = getBasePathOfPath(sourceInfo[name], closureInfo);
                            if (basePath) {
                                sourceInfo[name] = sourceInfo[name].replace(basePath, closureInfo.hashes[basePath]);
                            } else {
                                logger.error('during closure generation unknown based target [' +
                                    sourceInfo[name] + '] remained.');
                                delete sourceInfo[name];
                            }
                        }
                    }

                    basePath = getBasePathOfPath(source, closureInfo);
                    if (basePath) {
                        closureInfo.relations.preserved[source.replace(basePath, closureInfo.hashes[basePath])] =
                            closureInfo.relations.preserved[source];
                        delete closureInfo.relations.preserved[source];
                    } else {
                        logger.error('during closure generation unknown based source [' +
                            source + '] remained.');
                        delete closureInfo.relations.preserved[source];
                    }

                }
            }

            function gatherOccurancesOfType(baseGuid, closureInformation, allMetaNodes) {
                var keys = Object.keys(allMetaNodes),
                    occurrences = [],
                    i;

                for (i = 0; i < keys.length; i += 1) {
                    if (closureInformation.bases[baseGuid].originGuid === self.getLibraryGuid(allMetaNodes[keys[i]]) ||
                        closureInformation.bases[baseGuid].originGuid === self.getGuid(allMetaNodes[keys[i]])) {
                        occurrences.push(allMetaNodes[keys[i]]);
                    }
                }

                return occurrences;
            }

            function checkClosure(allMetaNodes, closureInformation) {
                //here we only check for exact GUID matches
                //TODO we might be able to map even with no exact GUID match based on library information
                var keys = Object.keys(allMetaNodes),
                    occurrences, i, j, errorTxt;

                closureInformation.destinationBases = {};
                for (i = 0; i < keys.length; i += 1) {
                    closureInformation.destinationBases[self.getGuid(allMetaNodes[keys[i]])] = keys[i];
                }

                keys = Object.keys(closureInformation.bases || {});

                for (i = 0; i < keys.length; i += 1) {
                    if (!closureInformation.destinationBases[keys[i]]) {
                        occurrences = gatherOccurancesOfType(keys[i], closureInformation, allMetaNodes);
                        if (occurrences.length === 0) {
                            return new Error('Cannot find necessary base [' +
                                closureInformation.bases[keys[i]].fullName + ' : ' + keys[i] + ']');
                        } else if (occurrences.length === 1) {
                            closureInformation.destinationBases[keys[i]] = self.getPath(occurrences[0]);
                        } else {
                            errorTxt = 'Ambiguous occurrences of base [' +
                                closureInformation.bases[keys[i]].fullName + ' : ' + keys[i] + '] ( ';
                            for (j = 0; j < occurrences.length; j += 1) {
                                errorTxt += '[' + self.getFullyQualifiedName(occurrences[j]) +
                                    ' : ' + self.getPath(occurrences[j]) + '] ';
                            }
                            errorTxt += ')';
                            return new Error(errorTxt);
                        }

                    }
                }

                return null;
            }

            function getAncestor(node, from, to) {
                var fromArray = from.split(CONSTANTS.PATH_SEP),
                    toArray = to.split(CONSTANTS.PATH_SEP),
                    commonAncestorPath = '',
                    i;

                fromArray.shift();
                toArray.shift();

                for (i = 0; i < fromArray.length && i < toArray.length; i += 1) {
                    if (fromArray[i] === toArray[i]) {
                        commonAncestorPath += CONSTANTS.PATH_SEP + fromArray[i];
                    } else {
                        break;
                    }
                }

                while (self.getPath(node) !== commonAncestorPath && node !== null) {
                    node = self.getParent(node);
                }

                return node;
            }

            function addRelation(parent, from, to, name) {
                var commonAncestor = getAncestor(parent, from, to),
                    relFrom, relTo;

                if (commonAncestor) {
                    relFrom = from.substr(self.getPath(commonAncestor).length);
                    relTo = to.substr(self.getPath(commonAncestor).length);

                    self.overlayInsert(commonAncestor, relFrom, name, relTo);
                } else {
                    logger.error('unable to add relation: ' + name + '(' + from + '->' + to + ')');
                }
            }

            function getFinalPath(path, closureInformation) {
                // #9ab4 1eaad 98572 de827 49f0d 54520 3ad99 6b564 7 => 41 char is the hash length
                var hash = path.substr(0, 41),
                    resultPath = '';

                if (closureInformation.relids[hash]) {
                    resultPath = closureInformation.parent + CONSTANTS.PATH_SEP + closureInformation.relids[hash];
                    resultPath += path.substr(41);
                }

                return resultPath;
            }

            function computePaths(closureInformation) {
                var source, name, sourceInfo;

                for (source in closureInformation.relations.preserved) {
                    sourceInfo = closureInformation.relations.preserved[source];
                    for (name in sourceInfo) {
                        if (closureInformation.destinationBases[sourceInfo[name]]) {
                            sourceInfo[name] = closureInformation.destinationBases[sourceInfo[name]];
                        } else {
                            sourceInfo[name] = getFinalPath(sourceInfo[name], closureInformation);
                        }
                    }
                }

                for (source in closureInformation.relations.preserved) {
                    closureInformation.relations.preserved[getFinalPath(source, closureInformation)] =
                        closureInformation.relations.preserved[source];
                    delete closureInformation.relations.preserved[source];
                }
            }

            //</editor-fold>

            //<editor-fold=Modified Methods>
            this.loadRoot = function (hash) {
                return TASYNC.call(function (root) {
                    root.libraryRoots = getLibraryRootsInfo(root);
                    return root;
                }, innerCore.loadRoot(hash));
            };

            this.createNode = function (parameters) {
                var node;

                if (parameters && parameters.parent &&
                    (self.isLibraryRoot(parameters.parent) || self.isLibraryElement(parameters.parent))) {
                    return new Error('Not allowed to create new node inside library.');
                }

                if (parameters && parameters.base && self.isLibraryRoot(parameters.base)) {
                    return new Error('Not allowed to instantiate library root.');
                }

                node = innerCore.createNode(parameters);
                if (node.parent === null) {
                    node.libraryRoots = {};
                }

                return node;
            };

            this.deleteNode = function (node, technical) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to remove library node by simply deleting them.');
                }

                return innerCore.deleteNode(node, technical);
            };

            this.copyNode = function (node, parent) {
                if (self.isLibraryRoot(parent) || self.isLibraryElement(parent)) {
                    return new Error('Not allowed to add nodes inside a library.');
                }

                if (self.isLibraryRoot(node)) {
                    return new Error('Not allowed to copy library root.');
                }

                return innerCore.copyNode(node, parent);
            };

            this.copyNodes = function (nodes, parent) {
                var i;
                if (self.isLibraryRoot(parent) || self.isLibraryElement(parent)) {
                    return new Error('Not allowed to add nodes inside a library.');
                }

                for (i = 0; i < nodes.length; i += 1) {
                    if (self.isLibraryRoot(nodes[i])) {
                        return new Error('Not allowed to copy library root.');
                    }
                }

                return innerCore.copyNodes(nodes, parent);
            };

            this.moveNode = function (node, parent) {
                if (self.isLibraryRoot(parent) || self.isLibraryElement(parent)) {
                    return new Error('Not allowed to add nodes inside a library.');
                }

                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to move library elements.');
                }

                return innerCore.moveNode(node, parent);
            };

            this.setAttribute = function (node, name, value) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setAttribute(node, name, value);
            };

            this.delAttribute = function (node, name) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delAttribute(node, name);
            };

            this.setRegistry = function (node, name, value) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setRegistry(node, name, value);
            };

            this.delRegistry = function (node, name) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delRegistry(node, name);
            };

            this.setPointer = function (node, name, target) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setPointer(node, name, target);
            };

            this.deletePointer = function (node, name) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.deletePointer(node, name);
            };

            this.setBase = function (node, base) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                if (base && self.isLibraryRoot(base)) {
                    return new Error('Not allowed to instantiate library root.');
                }

                return innerCore.setBase(node, base);
            };

            this.addMember = function (node, name, member) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.addMember(node, name, member);
            };

            this.delMember = function (node, name, path) {
                if (self.isLibraryElement(node) || self.isLibraryRoot(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delMember(node, name, path);
            };

            this.setMemberAttribute = function (node, setName, memberPath, attrName, value) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.setMemberAttribute(node, setName, memberPath, attrName, value);
            };

            this.delMemberAttribute = function (node, setName, memberPath, attrName) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.delMemberAttribute(node, setName, memberPath, attrName);
            };

            this.setMemberRegistry = function (node, setName, memberPath, regName, value) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.setMemberRegistry(node, setName, memberPath, regName, value);
            };

            this.delMemberRegistry = function (node, setName, memberPath, regName) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.delMemberRegistry(node, setName, memberPath, regName);
            };

            this.createSet = function (node, name) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.createSet(node, name);
            };

            this.deleteSet = function (node, name) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.deleteSet(node, name);
            };

            this.setSetAttribute = function (node, setName, regName, regValue) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.setSetAttribute(node, setName, regName, regValue);
            };

            this.delSetAttribute = function (node, setName, regName) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.delSetAttribute(node, setName, regName);
            };

            this.setSetRegistry = function (node, setName, regName, regValue) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.setSetRegistry(node, setName, regName, regValue);
            };

            this.delSetRegistry = function (node, setName, regName) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.delSetRegistry(node, setName, regName);
            };

            this.setGuid = function (node, guid) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    //FIXME cannot return any error in async functions :/
                    // /return new Error('Not allowed to modify library elements.');
                } else {
                    return innerCore.setGuid(node, guid);
                }
            };

            this.setConstraint = function (node, name, constraint) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.setConstraint(node, name, constraint);
            };

            this.delConstraint = function (node, name) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }
                return innerCore.delConstraint(node, name);
            };

            this.clearMetaRules = function (node) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.clearMetaRules(node);
            };

            this.setAttributeMeta = function (node, name, rule) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setAttributeMeta(node, name, rule);
            };

            this.delAttributeMeta = function (node, name) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delAttributeMeta(node, name);
            };

            this.setChildMeta = function (node, child, min, max) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                if (self.isLibraryRoot(child)) {
                    return new Error('Not allowed to use library root as valid child.');
                }

                return innerCore.setChildMeta(node, child, min, max);
            };

            this.delChildMeta = function (node, childPath) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delChildMeta(node, childPath);
            };

            this.setChildrenMetaLimits = function (node, min, max) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setChildrenMetaLimits(node, min, max);
            };

            this.setPointerMetaTarget = function (node, name, target, min, max) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setPointerMetaTarget(node, name, target, min, max);
            };

            this.delPointerMetaTarget = function (node, name, targetPath) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delPointerMetaTarget(node, name, targetPath);
            };

            this.setPointerMetaLimits = function (node, name, min, max) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setPointerMetaLimits(node, name, min, max);
            };

            this.delPointerMeta = function (node, name) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delPointerMeta(node, name);
            };

            this.setAspectMetaTarget = function (node, name, target) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.setAspectMetaTarget(node, name, target);
            };

            this.delAspectMetaTarget = function (node, name, targetPath) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delAspectMetaTarget(node, name, targetPath);
            };

            this.delAspectMeta = function (node, name) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delAspectMeta(node, name);
            };

            this.delMixin = function (node, mixinPath) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.delMixin(node, mixinPath);
            };

            this.addMixin = function (node, mixinPath) {
                var libraryName,
                    root = self.getRoot(node);

                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                for (libraryName in root.libraryRoots) {
                    if (self.getPath(root.libraryRoots[libraryName]) === mixinPath) {
                        return new Error('Not allowed to use library root as mixin.');
                    }
                }

                return innerCore.addMixin(node, mixinPath);
            };

            this.clearMixins = function (node) {
                if (self.isLibraryRoot(node) || self.isLibraryElement(node)) {
                    return new Error('Not allowed to modify library elements.');
                }

                return innerCore.clearMixins(node);
            };
            //</editor-fold>

            //<editor-fold=Added Methods>

            this.getLibraryRoot = function (node, name) {
                var root = self.getRoot(node);

                return root.libraryRoots[name] || null;
            };

            this.isLibraryElement = function (node) {
                var parent = self.getParent(node);

                while (parent) {
                    if (self.isLibraryRoot(parent)) {
                        return true;
                    }
                    parent = self.getParent(parent);
                }

                return false;
            };

            this.isLibraryRoot = function (node) {
                if (innerCore.getAttribute(node, '_libraryInfo')) {
                    return true;
                }
                return false;
            };

            this.getNamespace = function (node) {
                var libPrefix = getLibraryName(node);

                if (libPrefix) {
                    // Trim the trailing dot..
                    libPrefix = libPrefix.substring(0, libPrefix.length - 1);
                }

                return libPrefix;
            };

            this.getFullyQualifiedName = function (node) {
                ASSERT(self.isValidNode(node));
                return getLibraryName(node) + self.getAttribute(node, 'name');
            };

            this.getLibraryGuid = function (node, name) {
                ASSERT(self.isValidNode(node));
                var libraryRoot;

                if (!self.isLibraryElement(node) && !self.isLibraryRoot(node)) {
                    return new Error('Node is not a library member');
                }

                if (!name) {
                    libraryRoot = getLibraryRoot(node);
                } else {
                    libraryRoot = getRootOfLibrary(node, name);
                }

                if (!libraryRoot) {
                    return new Error('Unknown library was given');
                }

                if (self.getFullyQualifiedName(node).indexOf(self.getFullyQualifiedName(libraryRoot)) !== 0) {
                    return new Error('Node is not a member of the library');
                }

                if (self.isLibraryRoot(node) && self.getPath(node) === self.getPath(libraryRoot)) {
                    return innerCore.getDataGuid(node);
                }

                return innerCore.getDeducedGuid(node, self.getLibraryGuid(self.getParent(node), name));
            };

            this.addLibrary = function (node, name, libraryRootHash, libraryInfo) {
                var root = self.getRoot(node),
                    libraryRelid = RANDOM.generateRelid(root.data);

                innerCore.setProperty(root, libraryRelid, libraryRootHash);
                root.childrenRelids = null;

                return TASYNC.call(function (newLibraryRoot) {
                    return TASYNC.call(function (libraryNodes) {
                        var inMeta = self.getMemberPaths(newLibraryRoot, CONSTANTS.META_SET_NAME),
                            libraryInfoAttribute = libraryInfo;
                        //remove the libraryRoot from the libraryNodes
                        libraryNodes.shift();

                        //set the name of the library root
                        innerCore.setAttribute(newLibraryRoot, 'name', name);

                        //add library_info
                        libraryInfoAttribute.hash = libraryRootHash;
                        innerCore.setAttribute(newLibraryRoot, '_libraryInfo', libraryInfoAttribute);

                        if (libraryNodes.length > 0) {
                            //connect the FCO as base of libraryFCO
                            innerCore.setBase(self.getBaseRoot(libraryNodes[0]), self.getFCO(root));

                            //adding nodes to the global META
                            var i;
                            for (i = 0; i < libraryNodes.length; i += 1) {
                                if (inMeta.indexOf(self.getPath(libraryNodes[i])) !== -1) {
                                    innerCore.addMember(root, CONSTANTS.META_SET_NAME, libraryNodes[i]);
                                }
                            }
                        }
                        //refreshing libraryInfo
                        root.libraryRoots[name] = newLibraryRoot;
                    }, self.loadSubTree(newLibraryRoot));
                }, self.loadChild(root, libraryRelid));
            };

            this.updateLibrary = function (node, name, updatedLibraryRootHash, libraryInfo/*, updateInstructions*/) {
                var logs = {added: {}, updated: {}, moved: {}, removed: {}},
                    root = self.getRoot(node),
                    libraryRoot = getRootOfLibrary(root, name),
                    relid,
                    FCO = self.getFCO(root);

                if (!libraryRoot) { //do nothing if not valid library
                    return logs;
                }

                relid = self.getRelid(libraryRoot);

                return TASYNC.call(function (oldInfo, newInfo) {
                    var newNodePaths = [],
                        removedNodePaths = [],
                        i,
                        moves = [],
                        guid;

                    for (guid in newInfo) {
                        if (!oldInfo[guid]) {
                            newNodePaths.push('/' + relid + newInfo[guid].path);
                        } else if (oldInfo[guid].path !== newInfo[guid].path) {
                            moves.push({from: '/' + relid + oldInfo[guid].path, to: '/' + relid + newInfo[guid].path});
                        }
                    }

                    for (guid in oldInfo) {
                        if (!newInfo[guid]) {
                            removedNodePaths.push('/' + relid + oldInfo[guid].path);
                        }
                    }

                    for (i = 0; i < removedNodePaths.length; i += 1) {
                        removeLibraryRelations(root, removedNodePaths[i]);
                    }

                    for (i = 0; i < moves.length; i += 1) {
                        moveLibraryRelations(root, moves[i].from, moves[i].to);
                    }

                    innerCore.setProperty(root, relid, updatedLibraryRootHash);
                    root = self.removeChildFromCache(root, relid);
                    return TASYNC.call(function (newLibraryRoot) {
                        return TASYNC.call(function (newLibraryNodes) {
                            var i,
                                inMeta = self.getMemberPaths(newLibraryRoot, CONSTANTS.META_SET_NAME),
                                libraryInfoAttribute = libraryInfo,
                                libraryFCO;

                            newLibraryNodes.shift();
                            //set the name of the library root
                            innerCore.setAttribute(newLibraryRoot, 'name', name);

                            //add library_info
                            libraryInfoAttribute.hash = updatedLibraryRootHash;
                            innerCore.setAttribute(newLibraryRoot, '_libraryInfo', libraryInfoAttribute);

                            if (newLibraryNodes.length > 0) {
                                //connect the FCO as base of libraryFCO, but be sure to remove the nullPtr

                                libraryFCO = self.getBaseRoot(newLibraryNodes[0]);
                                innerCore.deletePointer(libraryFCO, 'base');
                                innerCore.setBase(libraryFCO, FCO);

                                //adding new nodes to the global META
                                for (i = 0; i < newLibraryNodes.length; i += 1) {
                                    if (newNodePaths.indexOf(self.getPath(newLibraryNodes[i])) !== -1 &&
                                        inMeta.indexOf(self.getPath(newLibraryNodes[i])) !== -1) {
                                        innerCore.addMember(root, CONSTANTS.META_SET_NAME, newLibraryNodes[i]);
                                    }
                                }
                            }

                            root.libraryRoots[name] = newLibraryRoot;

                            return logs;
                        }, self.loadSubTree(newLibraryRoot));
                    }, self.loadChild(root, relid));
                }, getLibraryInfo(libraryRoot), getLibraryInfo(updatedLibraryRootHash));

            };

            this.removeLibrary = function (node, name) {
                ASSERT(self.isValidNode(node));
                var root = self.getRoot(node),
                    libraryRoot = root.libraryRoots[name];

                if (libraryRoot && !self.isLibraryElement(libraryRoot)) {
                    innerCore.deleteNode(root.libraryRoots[name], true);
                    delete root.libraryRoots[name];
                }

            };

            this.renameLibrary = function (node, oldName, newName) {
                ASSERT(self.isValidNode(node));
                var root = self.getRoot(node);

                ASSERT(typeof oldName === 'string' && typeof newName === 'string' &&
                    oldName.indexOf(CONSTANTS.NAMESPACE_SEPARATOR) === -1 &&
                    newName.indexOf(CONSTANTS.NAMESPACE_SEPARATOR) === -1 &&
                    root.libraryRoots[oldName]);

                if (oldName !== newName) {
                    ASSERT(!root.libraryRoots[newName], 'Library already exists [' + newName + ']');
                    innerCore.setAttribute(root.libraryRoots[oldName], 'name', newName);
                    root.libraryRoots[newName] = root.libraryRoots[oldName];
                    delete root.libraryRoots[oldName];
                }
            };

            this.getLibraryNames = function (node) {
                ASSERT(self.isValidNode(node));
                return Object.keys(self.getRoot(node).libraryRoots);
            };

            this.getLibraryMetaNodes = function (node, name, onlyOwn) {
                var allNodes = self.getAllMetaNodes(node),
                    libraryNodes = {},
                    path;

                for (path in allNodes) {
                    if (onlyOwn) {
                        if (self.getNamespace(allNodes[path]) === name) {
                            libraryNodes[path] = allNodes[path];
                        }
                    } else {
                        if (self.getNamespace(allNodes[path]).indexOf(name) === 0) {
                            libraryNodes[path] = allNodes[path];
                        }
                    }
                }

                return libraryNodes;
            };

            this.getLibraryInfo = function (node, name) {
                var libroot = getRootOfLibrary(node, name);
                return self.getAttribute(libroot, '_libraryInfo');
            };

            this.getClosureInformation = function (nodes) {
                ASSERT(nodes.length > 0);
                var closureInfo = {
                        hashes: {},
                        selection: {},
                        bases: {},
                        relations: {preserved: {}, lost: {}}
                    },
                    infoLosses = {},
                    allMetaNodes,
                    path,
                    node,
                    keys,
                    i;

                nodes = normalizeSelectionForClosure(nodes);
                allMetaNodes = this.getAllMetaNodes(nodes[0]);

                // We first collect the absolute paths of the selected nodes
                for (i = 0; i < nodes.length; i += 1) {
                    // The selection cannot contain library elements as that would violate read-only
                    if (this.isLibraryElement(nodes[i]) || this.isLibraryRoot(nodes[i])) {
                        return new Error('Cannot select node[' +
                            this.getPath(nodes[i]) + '] because it is library content!'
                        );
                    }
                    if (this.getParent(nodes[i]) === null) {
                        return new Error('Cannot select the project root!');
                    }
                    closureInfo.selection[this.getPath(nodes[i])] = this.getGuid(nodes[i]);
                    closureInfo.hashes[this.getPath(nodes[i])] = this.getHash(nodes[i]);
                }

                // Secondly, we collect relation information (the first order ones).
                // We leave the handling of the root node's overlay info for a separate step
                for (i = 0; i < nodes.length; i += 1) {
                    node = this.getParent(nodes[i]);
                    while (this.getPath(node)) { // until it is not the root
                        addRelationsFromNodeToClosureInfo(node, allMetaNodes, closureInfo);
                        node = this.getParent(node);
                    }
                }

                // Finally we process the relations of the root
                addRelationsFromNodeToClosureInfo(this.getRoot(nodes[0]), allMetaNodes, closureInfo);

                //now we combine the selection and hashes info
                keys = Object.keys(closureInfo.selection);
                for (i = 0; i < keys.length; i += 1) {
                    closureInfo.selection[closureInfo.selection[keys[i]]] = closureInfo.hashes[keys[i]];
                    delete closureInfo.selection[keys[i]];
                }

                //now map the paths to some guid+relpath format
                mapRelationEndings(closureInfo);

                //remove hashes field from closure information
                delete closureInfo.hashes;

                //checking and logging lost relation information
                logger.debug('Closure creation finished!', closureInfo);
                for (path in closureInfo.relations.lost) {
                    if (closureInfo.relations.lost[path][CONSTANTS.BASE_POINTER]) {
                        //we do not allow external non-Meta bases
                        return new Error('Closure cannot be created due to [' + path +
                            '] misses its base [' + closureInfo.relations.lost[path][CONSTANTS.BASE_POINTER] + '].');
                    }
                }

                return closureInfo;
            };

            this.importClosure = function (parent, closureInformation) {
                //at this point we can assume that the database has the necessary blobs
                var allMetaNodes = this.getAllMetaNodes(parent),
                    checkResult,
                    key,
                    name,
                    longestNewRelid = '',
                    reservedRelids = this.getChildrenRelids(parent, true),
                    newRelid;

                checkResult = checkClosure(allMetaNodes, closureInformation);

                if (checkResult) {
                    return checkResult;
                }

                closureInformation.relids = {};
                closureInformation.parent = this.getPath(parent);

                // Attaching the selected nodes under the parent node
                for (key in closureInformation.selection) {
                    newRelid = RANDOM.generateRelid(reservedRelids,
                        innerCore.getProperty(parent, CONSTANTS.MINIMAL_RELID_LENGTH_PROPERTY));
                    reservedRelids[newRelid] = true;
                    innerCore.setProperty(parent, newRelid, closureInformation.selection[key]);
                    closureInformation.relids[closureInformation.selection[key]] = newRelid;
                    if (newRelid.length > longestNewRelid.length) {
                        longestNewRelid = newRelid;
                    }
                }

                parent.childrenRelids = null;

                // Now processing the new relid creations
                innerCore.processRelidReservation(parent, longestNewRelid);

                // Replacing the paths in the closure information with actual paths in the target project
                computePaths(closureInformation);

                // Creating all the relations
                for (key in closureInformation.relations.preserved) {
                    for (name in closureInformation.relations.preserved[key]) {
                        addRelation(parent, key, closureInformation.relations.preserved[key][name], name);
                    }
                }

                logger.debug('Closure import finished!', closureInformation);

                return closureInformation;
            };
            //</editor-fold>
        };

        return LibraryCore;
    }
);
/*globals define*/
/*jshint node: true, browser: true*/

/**
 * This class defines the public API of the WebGME-Core
 *
 * @author kecso / https://github.com/kecso
 * @module Core
 */

/**
 * @typedef {object} Node - the object that represents the atomic element of the containment hierarchy.
 */

/**
 * @typedef {object} DataObject - Inner data of {@link module:Core~Node} that can be serialized and saved in the storage.
 */

/**
 * @typedef {object} GmePersisted - the result object of a persist which contains information about the newly
 * created data objects.
 * @prop {module:Core~ObjectHash} rootHash - Hash of the root node.
 * @prop {Object.<module:Core~ObjectHash, module:Core~DataObject>} objects - Hash of the root node.
 */

/**
 * @typedef {string} ObjectHash - Unique SHA-1 hash for the node object.
 * @example
 * '#5496cf226542fcceccf89056f0d27564abc88c99'
 */

/**
 * @typedef {string} GUID - Globally unique identifier. A formatted string containing hexadecimal characters. If some
 * projects share some GUIDs that can only be because the node with the given identification represents the same
 * concept.
 * @example
 * 'cd891e7b-e2ea-e929-f6cd-9faf4f1fc045'
 */

/**
 * @typedef {object} Constraint - An object that represents some additional rule regarding some node of the project.
 * @prop {string} script - The script which checks if the constraint is met.
 * @prop {string} info - Short description of the constraint.
 * @prop {string} priority - Gives instructions on how to deal with violations of the constraint.
 */

/**
 * @typedef {object} RelationRule - An object that represents a relational type rule-set (pointer/set).
 * @prop {integer} [min] - The minimum amount of target necessary for the relationship (if not present or '-1'
 * then there is no minimum rule that applies)
 * @prop {integer} [max] - The minimum amount of target necessary for the relationship (if not present or '-1'
 * then there is no minimum rule that applies)
 * @prop {object} [absolutePathOfTarget] - special rules regarding the given type (if the object is empty, it still
 * represents that the type is a valid target of the relationship)
 * @prop {integer} [absolutePathOfTarget.min] - The minimum amount of target necessary for the relationship
 * from the given type (if not present or '-1' then there is no minimum rule that applies)
 * @prop {integer} [absolutePathOfTarget.max] - The minimum amount of target necessary for the relationship
 * from the given type (if not present or '-1' then there is no minimum rule that applies)
 * @example
 * '{
 *  'min': 1,
 *  'max': -1,
 *  'any/path/of/node':{
 *   'min':-1,
 *   'max':2
 *   },
 *   'any/other/valid/path':{
 *   }
 * }'
 */

/**
 * @typedef {object} MixinViolation - An object that has information about a mixin violation in the given node.
 * @prop {string} [severity] - The severity of the given error ('error','warning').
 * @prop {string} [type] - 'missing', 'attribute collision', 'set collision',
 * 'pointer collision', 'containment collision', 'aspect collision', 'constraint collision'
 * @prop {string|undefined} [ruleName] - The name of the affected rule definition  (if available).
 * @prop {string|undefined} [targetInfo] - The path of the target of the violation (if available).
 * @prop {module:Core~Node|undefined} [targetNode] - The target node of the violation (if available).
 * @prop {string[]} [collisionPaths] - The list of paths of colliding nodes (if any).
 * @prop {module:Core~Node[]} [collisionNodes] - The colliding mixin nodes (if any).
 * @prop {string} [message] - The description of the violation.
 * @prop {string} [hint] - Hint on how to resolve the issue.
 * @example
 * '{
 * 'severity': 'error',
 * 'type': 'missing',
 * 'targetInfo': '/E/b',
 * 'message': '[MyObject]: mixin node \'E/b\' is missing from the Meta',
 * 'hint': 'Remove mixin or add to the Meta'
 * }'
 * @example
 * '{
 * 'severity': 'warning',
 * 'type': 'attribute collision',
 * 'ruleName': 'value',
 * 'collisionPaths': ['/E/a','/E/Z'],
 * 'collisionNodes': [Object,Object],
 * 'message':'[MyObject]: inherits attribute definition \'value'\ from [TypeA] and [TypeB]',
 * 'hint': 'Remove one of the mixin relations'
 * }'
 */

define('common/core/core',[
    'common/core/corerel',
    'common/core/setcore',
    'common/core/guidcore',
    'common/core/nullpointercore',
    'common/core/coreunwrap',
    'common/core/coretype',
    'common/core/constraintcore',
    'common/core/coretree',
    'common/core/metacore',
    'common/core/coretreeloader',
    'common/core/corediff',
    'common/core/metacachecore',
    'common/core/mixincore',
    'common/core/metaquerycore',
    'common/core/librarycore'
], function (CoreRel,
             Set,
             Guid,
             NullPtr,
             UnWrap,
             Type,
             Constraint,
             CoreTree,
             MetaCore,
             TreeLoader,
             CoreDiff,
             MetaCacheCore,
             MixinCore,
             MetaQueryCore,
             LibraryCore) {
    'use strict';

    /**
     * @param {object} storageObject
     * @param {object} options - contains logging information
     * @alias Core
     * @constructor
     */
    function Core(storage, options) {
        var core,
            coreLayers = [];
        coreLayers.push(CoreRel);
        coreLayers.push(NullPtr);
        coreLayers.push(Type);
        coreLayers.push(NullPtr);
        coreLayers.push(Set);
        coreLayers.push(Guid);
        coreLayers.push(Constraint);
        coreLayers.push(MetaCore);
        coreLayers.push(MetaCacheCore);
        coreLayers.push(MixinCore);
        coreLayers.push(MetaQueryCore);
        coreLayers.push(CoreDiff);

        coreLayers.push(TreeLoader);

        coreLayers.push(LibraryCore);

        if (options.usertype !== 'tasync') {
            coreLayers.push(UnWrap);
        }

        core = coreLayers.reduce(function (inner, Class) {
            return new Class(inner, options);
        }, new CoreTree(storage, options));

        /**
         * Returns the parent of the node.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {module:Core~Node} Returns the parent of the node or NULL if it has no parent.
         *
         * @func
         */
        this.getParent = core.getParent;

        /**
         * Returns the parent-relative identifier of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} Returns the id string or return NULL and UNDEFINED if there is no such id for the node.
         *
         * @func
         */
        this.getRelid = core.getRelid;

        //this.getLevel = core.getLevel;

        /**
         * Returns the root node of the containment tree that node is part of.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node} Returns the root of the containment hierarchy (it can be the node itself).
         *
         * @func
         */
        this.getRoot = core.getRoot;

        /**
         * Returns the complete path of the node in the containment hierarchy.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} Returns a path string where each portion is a relative id and they are separated by '/'.
         * The path can be empty as well if the node in question is the  root itself, otherwise it should be a chain
         * of relative ids from the root of the containment hierarchy.
         *
         * @func
         */
        this.getPath = core.getPath;

        //this.isValidPath = core.isValidPath;
        //this.splitPath = core.splitPath;
        //this.buildPath = core.buildPath;
        //this.joinPaths = core.joinPaths;
        //this.getCommonPathPrefixData = core.getCommonPathPrefixData;
        //this.normalize = core.normalize;
        //this.getAncestor = core.getAncestor;
        //this.isAncestor = core.isAncestor;
        //this.createRoot = core.createRoot;
        //this.createChild = core.createChild;

        /**
         * Retrieves the child of the input node at the given relative id. It is not an asynchronous load
         * and it automatically creates the child under the given relative id if no child was there beforehand.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} relativeId - the relative id which our child in question has.
         *
         * @return {module:Core~Node} Return an empty node if it was created as a result of the function or
         * return the already existing and loaded node if it found.
         *
         * @func
         */
        this.getChild = core.getChild;

        //this.isMutable = core.isMutable;
        //this.isObject = core.isObject;

        /**
         * Checks if the node in question has some actual data.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} Returns true if the node is 'empty' meaning that it is not reserved by real data.
         * Returns false if the node is exists and have some meaningful value.
         *
         * @func
         */
        this.isEmpty = core.isEmpty;

        //this.mutate = core.mutate;
        //this.getData = core.getData;
        //this.setData = core.setData;
        //this.deleteData = core.deleteData;
        //this.copyData = core.copyData;
        //this.getProperty = core.getProperty;
        //this.setProperty = core.setProperty;
        //this.deleteProperty = core.deleteProperty;
        //this.getKeys = core.getKeys;
        //this.getRawKeys = core.getRawKeys;
        //this.isHashed = core.isHashed;
        //this.setHashed = core.setHashed;

        /**
         * Returns the calculated database id of the data of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~ObjectHash} Returns the so called Hash value of the data of the given node. If the string is empty,
         * then it means that the node was mutated but not yet saved to the database, so it do not have a hash
         * temporarily.
         *
         * @func
         */
        this.getHash = core.getHash;

        /**
         * Persists the changes made in memory and computed the data blobs that needs to be saved into the database
         * to make the change and allow other users to see the new state of the project.
         * @param {module:Core~Node} node - some node element of the modified containment hierarchy (usually the root).
         *
         * @return {module:Core~GmePersisted} The function returns an object which collects all the changes
         * on data level and necessary to update the database on server side
         *
         * @func
         */
        this.persist = core.persist;

        /**
         * Loads the data object with the given hash and makes it a root of a containment hierarchy.
         * @param {module:Core~ObjectHash} hash - the hash of the data object we like to load as root.
         * @param {function(string, module:Core~Node)} callback
         *
         * @func
         */
        this.loadRoot = core.loadRoot;

        /**
         * Loads the child of the given parent pointed by the relative id. Behind the scenes, it means
         * that it actually loads the data pointed by a hash stored inside the parent under the given id
         * and wraps it in a node object which will be connected to the parent as a child in the containment
         * hierarchy. If there is no such relative id reserved, the call will return with null.
         * @param {module:Core~Node} parent - the container node in question.
         * @param {string} relativeId - the relative id of the child in question.
         * @param {function(string, module:Core~Node)} callback
         *
         * @func
         */
        this.loadChild = core.loadChild;

        /**
         * From the given starting node, it loads the path given as a series of relative ids (separated by '/')
         * and returns the node it finds at the ends of the path. If there is no node, the function will return null.
         * @param {module:Core~Node} startNode - the starting node of our search.
         * @param {string} relativePath - the relative path - built by relative ids - of the node in question.
         * @param {function(string, module:Core~Node)} callback
         *
         * @func
         */
        this.loadByPath = core.loadByPath;

        /**
         * Loads all the children of the given parent. As it first checks the already reserved relative ids of
         * the parent, it only loads the already existing children (so no on-demand empty node creation).
         * @param {module:Core~Node} parent - the container node in question.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadChildren = core.loadChildren;

        /**
         * Loads all the children of the given parent that has some data and not just inherited. As it first checks
         * the already reserved relative ids of the parent, it only loads the already existing children
         * (so no on-demand empty node creation).
         * @param {module:Core~Node} parent - the container node in question.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadOwnChildren = core.loadOwnChildren;

        /**
         * Loads the target of the given pointer of the given node. In the callback the node can have three values:
         * if the node is valid, then it is the defined target of a valid pointer,
         * if the returned value is null, then it means that the pointer is defined, but has no real target,
         * finally if the returned value is undefined than there is no such pointer defined for the given node.
         * @param {module:Core~Node} source - the container node in question.
         * @param {string} pointerName - the relative id of the child in question.
         * @param {function(string, module:Core~Node)} callback
         *
         * @func
         */
        this.loadPointer = core.loadPointer;

        /**
         * Loads all the source nodes that has such a pointer and its target is the given node.
         * @param {module:Core~Node} target - the container node in question.
         * @param {string} pointerName - the relative id of the child in question.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadCollection = core.loadCollection;

        /**
         * Loads a complete sub-tree of the containment hierarchy starting from the given node.
         * @param {module:Core~Node} node - the container node in question.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadSubTree = core.loadSubTree;

        /**
         * Loads a complete sub-tree of the containment hierarchy starting from the given node, but load only those
         * children that has some additional data and not purely inherited.
         * @param {module:Core~Node} node - the container node in question.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadOwnSubTree = core.loadOwnSubTree;

        /**
         * Loads a complete containment hierarchy using the data object - pointed by the given hash -
         * as the root.
         * @param {module:Core~ObjectHash} rootHash - hash of the root node.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadTree = core.loadTree;

        //this.isValidNode = core.isValidNode;
        //this.getChildHash = core.getChildHash;
        //this.isValidRelid = core.isValidRelid;

        /**
         * Collects the relative ids of all the children of the given node.
         * @param {module:Core~Node} parent - the container node in question.
         *
         * @return {string[]} The function returns an array of the relative ids.
         *
         * @func
         */
        this.getChildrenRelids = core.getChildrenRelids;

        /**
         * Collects the relative ids of all the children of the given node that has some data and not just inherited.
         * N.B. Do not mutate the returned array!
         * @param {module:Core~Node} parent - the container node in question.
         *
         * @return {string[]} The function returns an array of the relative ids.
         *
         * @func
         */
        this.getOwnChildrenRelids = core.getOwnChildrenRelids;

        /**
         * Collects the paths of all the children of the given node.
         * @param {module:Core~Node} parent - the container node in question.
         *
         *@return {string[]} The function returns an array of the absolute paths of the children.
         *
         * @func
         */
        this.getChildrenPaths = core.getChildrenPaths;

        /**
         * Collects the paths of all the children of the given node that has some data as well and not just inherited.
         * @param {module:Core~Node} parent - the container node in question.
         *
         *@return {string[]} The function returns an array of the absolute paths of the children.
         *
         * @func
         */
        this.getOwnChildrenPaths = core.getOwnChildrenPaths;

        /**
         * Creates a node according to the given parameters.
         * @param {object} parameters - the details of the creation.
         * @param {module:Core~Node | null} [parameters.parent] - the parent of the node to be created.
         * @param {module:Core~Node | null} [parameters.base] - the base of the node to be created.
         * @param {string} [parameters.relid] - the relative id of the node to be created (if reserved, the function
         * returns the node behind the relative id)
         * @param {module:Core~GUID} [parameters.guid] - the GUID of the node to be created
         *
         *
         * @return {module:Core~Node | Error} The function returns the created node or null if no node was created
         * or an error if the creation with the given parameters are not allowed.
         *
         * @func
         */
        this.createNode = core.createNode;

        /**
         * Removes a node from the containment hierarchy.
         * @param {module:Core~Node} node - the node to be removed.
         *
         * @return {undefined|Error} If the operation is not allowed it returns an error.
         * @func
         */
        this.deleteNode = core.deleteNode;

        /**
         * Copies the given node into parent.
         * @param {module:Core~Node} node - the node to be copied.
         * @param {module:Core~Node} parent - the parent node of the copy.
         *
         * @return {module:Core~Node | Error} The function returns the copied node or an error if the copy
         * is not allowed.
         *
         * @func
         */
        this.copyNode = core.copyNode;

        /**
         * Copies the given nodes into parent.
         * @param {module:Core~Node[]} nodes - the nodes to be copied.
         * @param {module:Core~Node} parent - the parent node of the copy.
         *
         * @return {module:Core~Node[] | Error} The function returns an array of the copied nodes or an error
         * if any of the nodes are not allowed to be copied to the given parent.
         *
         * @func
         */
        this.copyNodes = core.copyNodes;

        /**
         * Checks if parent can be the new parent of node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} parent - the new parent.
         *
         * @return {boolean} True if the supplied parent is a valid parent for the node.
         *
         * @func
         */
        this.isValidNewParent = core.isValidNewParent;

        /**
         * Moves the given node under the given parent.
         * @param {module:Core~Node} node - the node to be moved.
         * @param {module:Core~Node} parent - the parent node of the copy.
         *
         * @return {module:Core~Node | Error} The function returns the node after the move or an error
         * if the move is not allowed.
         *
         * @func
         */
        this.moveNode = core.moveNode;

        /**
         * Returns the names of the defined attributes of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the attributes of the node.
         *
         * @func
         */
        this.getAttributeNames = core.getAttributeNames;

        /**
         * Retrieves the value of the given attribute of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {object | primitive | null | undefined} The function returns the value of the attribute of the node.
         * The value can be an object or any primitive type. If the value is undefined that means the node do not have
         * such attribute defined. [The retrieved attribute should not be modified as is - it should be copied first!!]
         *
         * @func
         */
        this.getAttribute = core.getAttribute;

        /**
         * Sets the value of the given attribute of the given node. It defines the attribute on demand, means that it
         * will set the given attribute even if was ot defined for the node beforehand.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         * @param {object | primitive | null} value - the new of the attribute. Can be any primitive type or object.
         * Undefined is not allowed.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setAttribute = core.setAttribute;

        /**
         * Removes the given attributes from the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delAttribute = core.delAttribute;

        /**
         * Returns the names of the defined registry entries of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the registry entries of the node.
         *
         * @func
         */
        this.getRegistryNames = core.getRegistryNames;

        /**
         * Retrieves the value of the given registry entry of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         *
         * @return {object | primitive | null | undefined} The function returns the value of the registry entry
         * of the node. The value can be an object or any primitive type. If the value is undefined that means
         * the node do not have such attribute defined. [The retrieved registry value should
         * not be modified as is - it should be copied first!!]
         *
         * @func
         */
        this.getRegistry = core.getRegistry;

        /**
         * Sets the value of the given registry entry of the given node. It defines the registry entry on demand,
         * means that it will set the given registry entry even if was ot defined for the node beforehand.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         * @param {object | primitive | null} value - the new of the registry entry. Can be any primitive
         * type or object. Undefined is not allowed.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         * @func
         */
        this.setRegistry = core.setRegistry;

        /**
         * Removes the given registry entry from the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delRegistry = core.delRegistry;

        /**
         * Retrieves a list of the defined pointer names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the pointers of the node.
         *
         * @func
         */
        this.getPointerNames = core.getPointerNames;

        /**
         * Retrieves the path of the target of the given pointer of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         *
         * @return {string | null | undefined} The function returns the absolute path of the target node
         * if there is a valid target. It returns null if though the pointer is defined it does not have any
         * valid target. Finally, it return undefined if there is no pointer defined for the node under the given name.
         *
         * @func
         */
        this.getPointerPath = core.getPointerPath;

        /**
         * Removes the pointer from the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.deletePointer = this.delPointer = core.deletePointer;

        /**
         * Sets the target of the pointer of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer in question.
         * @param {module:Core~Node} target - the new target of the pointer.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setPointer = core.setPointer;

        /**
         * Retrieves a list of the defined pointer names that has the node as target.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the pointers pointing to the node.
         *
         * @func
         */
        this.getCollectionNames = core.getCollectionNames;

        /**
         * Retrieves a list of absolute paths of nodes that has a given pointer which points to the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer.
         *
         * @return {string[]} The function returns an array of absolute paths of nodes that
         * has the pointer pointing to the node.
         *
         * @func
         */
        this.getCollectionPaths = core.getCollectionPaths;

        /**
         * Collects the data hash values of the children of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {Object<string, module:Core~ObjectHash>} The function returns a dictionary of {@link module:Core~ObjectHash} that stored in pair
         * with the relative id of the corresponding child of the node.
         *
         * @func
         */
        this.getChildrenHashes = core.getChildrenHashes;

        /**
         * Returns the base node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node | null} Returns the base of the given node or null if there is no such node.
         *
         * @func
         */
        this.getBase = core.getBase;

        /**
         * Returns the root of the inheritance chain of the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node} Returns the root of the inheritance chain (usually the FCO).
         *
         * @func
         */
        this.getBaseRoot = core.getBaseRoot;

        /**
         * Returns the names of the attributes of the node that have been first defined for the node and not for its
         * bases.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the own attributes of the node.
         *
         * @func
         */
        this.getOwnAttributeNames = core.getOwnAttributeNames;

        /**
         * Returns the names of the registry enrties of the node that have been first defined for the node
         * and not for its bases.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of the names of the own registry entries of the node.
         *
         * @func
         */
        this.getOwnRegistryNames = core.getOwnRegistryNames;

        /**
         * Returns the value of the attribute defined for the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {object | primitive | null | undefined} Returns the value of the attribute defined specifically for
         * the node. If undefined then it means that there is no such attribute defined directly for the node, meaning
         * that it either inherits some value or there is no such attribute at all.
         *
         * @func
         */
        this.getOwnAttribute = core.getOwnAttribute;

        /**
         * Returns the value of the registry entry defined for the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the registry entry.
         *
         * @return {object | primitive | null | undefined} Returns the value of the registry entry defined specifically
         * for the node. If undefined then it means that there is no such registry entry defined directly for the node,
         * meaning that it either inherits some value or there is no such registry entry at all.
         *
         * @func
         */
        this.getOwnRegistry = core.getOwnRegistry;

        /**
         * Returns the list of the names of the pointers that were defined specifically for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns an array of names of pointers defined specifically for the node.
         *
         *@func
         */
        this.getOwnPointerNames = core.getOwnPointerNames;

        /**
         * Returns the absolute path of the target of the pointer specifically defined for the node.
         * @param {module:Core~Node} node - the node in question
         * @param {string} name - the name of the pointer
         *
         * @return {string | null | undefined} Returns the absolute path. If the path is null, then it means that
         * 'no-target' was defined specifically for this node for the pointer. If undefined it means that the node
         * either inherits the target of the pointer or there is no pointer defined at all.
         *
         * @func
         */
        this.getOwnPointerPath = core.getOwnPointerPath;

        /**
         * Checks if base can be the new base of node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node | null | undefined} base - the new base.
         *
         * @return {boolean} True if the supplied base is a valid base for the node.
         *
         * @func
         */
        this.isValidNewBase = core.isValidNewBase;

        /**
         * Sets the base node of the given node. The function doesn't touches the properties or the children of the node
         * so it can cause META rule violations that needs to be corrected manually.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node | null} base - the new base.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setBase = core.setBase;

        /**
         * Returns the root of the inheritance chain (cannot be the node itself).
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~Node | null} Returns the root of the inheritance chain of the node. If returns null,
         * that means the node in question is the root of the chain.
         *
         * @func
         */
        this.getTypeRoot = core.getTypeRoot;

        /**
         * Returns the names of the sets of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns an array of set names that the node has.
         *
         * @func
         */
        this.getSetNames = core.getSetNames;

        /**
         * Returns the names of the sets created specifically at the node.
         * N.B. When adding a member to a set of a node, the set is automatically created at the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns an array of set names that were specifically created at the node.
         *
         * @func
         */
        this.getOwnSetNames = core.getOwnSetNames;

        /**
         * Creates a set for the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.createSet = core.createSet;

        /**
         * Removes a set from the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.deleteSet = this.delSet = core.deleteSet;

        /**
         * Return the names of the attribute entries for the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of attribute entries in the set.
         *
         * @func
         */
        this.getSetAttributeNames = core.getSetAttributeNames;

        /**
         * Return the names of the attribute entries specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of attribute entries defined in the set at the node.
         *
         * @func
         */
        this.getOwnSetAttributeNames = core.getOwnSetAttributeNames;

        /**
         * Get the value of the attribute entry in the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         *
         * @return {object|primitive|null|undefined} Return the value of the attribute. If it is undefined, than there
         * is no such attribute at the set.
         *
         * @func
         */
        this.getSetAttribute = core.getSetAttribute;

        /**
         * Get the value of the attribute entry specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         *
         * @return {object|primitive|null|undefined} Return the value of the attribute. If it is undefined, than there
         * is no such attribute at the set.
         *
         * @func
         */
        this.getOwnSetAttribute = core.getOwnSetAttribute;

        /**
         * Sets the attribute entry value for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         * @param {object|primitive|null} value - the new value of the attribute.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setSetAttribute = core.setSetAttribute;

        /**
         * Removes the attribute entry for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} attrName - the name of the attribute entry.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delSetAttribute = core.delSetAttribute;

        //Regs

        /**
         * Return the names of the registry entries for the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of registry entries in the set.
         *
         * @func
         */
        this.getSetRegistryNames = core.getSetRegistryNames;

        /**
         * Return the names of the registry entries specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns the array of names of registry entries defined in the set at the node.
         *
         * @func
         */
        this.getOwnSetRegistryNames = core.getOwnSetRegistryNames;

        /**
         * Get the value of the registry entry in the set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {object|primitive|null|undefined} Return the value of the registry. If it is undefined, than there
         * is no such registry at the set.
         *
         * @func
         */
        this.getSetRegistry = core.getSetRegistry;

        /**
         * Get the value of the registry entry specifically set for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {object|primitive|null|undefined} Return the value of the registry. If it is undefined, than there
         * is no such registry at the set.
         *
         * @func
         */
        this.getOwnSetRegistry = core.getOwnSetRegistry;

        /**
         * Sets the registry entry value for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         * @param {object|primitive|null} value - the new value of the registry.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setSetRegistry = core.setSetRegistry;

        /**
         * Removes the registry entry for the set at the node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delSetRegistry = core.delSetRegistry;

        /**
         * Returns the list of absolute paths of the members of the given set of the given node.
         * @param {module:Core~Node} node - the set owner.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns an array of absolute path strings of the member nodes of the set.
         * @func
         */
        this.getMemberPaths = core.getMemberPaths;

        /**
         * Returns the list of absolute paths of the members of the given set of the given node that not simply
         * inherited.
         * @param {module:Core~Node} node - the set owner.
         * @param {string} name - the name of the set.
         *
         * @return {string[]} Returns an array of absolute path strings of the member nodes of the set that has
         * information on the node's inheritance level.
         * @func
         */
        this.getOwnMemberPaths = core.getOwnMemberPaths;

        /**
         * Removes a member from the set. The functions doesn't remove the node itself.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} path - the absolute path of the member to be removed.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delMember = core.delMember;

        /**
         * Adds a member to the given set.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {module:Core~Node} member - the new member of the set.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.addMember = core.addMember;

        /**
         * Return the names of the attributes defined for the set membership to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} memberPath - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of attributes that represents some property of the membership.
         *
         * @func
         */
        this.getMemberAttributeNames = core.getMemberAttributeNames;

        /**
         * Return the names of the attributes defined for the set membership specifically defined to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} memberPath - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of attributes that represents some property of the membership.
         *
         * @func
         */
        this.getMemberOwnAttributeNames = core.getMemberOwnAttributeNames;

        /**
         * Get the value of the attribute in relation with the set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         *
         * @return {object|primitive|null|undefined} Return the value of the attribute. If it is undefined, than there
         * is no such attributed connected to the given set membership.
         *
         * @func
         */
        this.getMemberAttribute = core.getMemberAttribute;

        /**
         * Get the value of the attribute for the set membership specifically defined to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         *
         * @return {object|primitive|null|undefined} Return the value of the attribute. If it is undefined, than there
         * is no such attributed connected to the given set membership.
         *
         * @func
         */
        this.getMemberOwnAttribute = core.getMemberOwnAttribute;

        /**
         * Sets the attribute value which represents a property of the membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         * @param {object|primitive|null} value - the new value of the attribute.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setMemberAttribute = core.setMemberAttribute;

        /**
         * Removes an attribute which represented a property of the given set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} attrName - the name of the attribute.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delMemberAttribute = core.delMemberAttribute;

        /**
         * Return the names of the registry entries defined for the set membership to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} memberPath - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of registry entries that represents some property of the
         * membership.
         *
         * @func
         */
        this.getMemberRegistryNames = core.getMemberRegistryNames;

        /**
         * Return the names of the registry entries defined for the set membership specifically defined to
         * the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} name - the name of the set.
         * @param {string} memberPath - the absolute path of the member.
         *
         * @return {string[]} Returns the array of names of registry entries that represents some property of the
         * membership.
         *
         * @func
         */
        this.getMemberOwnRegistryNames = core.getMemberOwnRegistryNames;

        /**
         * Get the value of the registry entry in relation with the set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {object|primitive|null|undefined} Return the value of the registry. If it is undefined, than there
         * is no such registry connected to the given set membership.
         *
         * @func
         */
        this.getMemberRegistry = core.getMemberRegistry;

        /**
         * Get the value of the registry entry for the set membership specifically defined to the member node.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {object|primitive|null|undefined} Return the value of the registry. If it is undefined, than there
         * is no such registry connected to the given set membership.
         *
         * @func
         */
        this.getMemberOwnRegistry = core.getMemberOwnRegistry;

        /**
         * Sets the registry entry value which represents a property of the membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         * @param {object|primitive|null} value - the new value of the registry.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setMemberRegistry = core.setMemberRegistry;

        /**
         * Removes a registry entry which represented a property of the given set membership.
         * @param {module:Core~Node} node - the owner of the set.
         * @param {string} setName - the name of the set.
         * @param {string} memberPath - the absolute path of the member node.
         * @param {string} regName - the name of the registry entry.
         *
         * @return {undefined | Error} If the set is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delMemberRegistry = core.delMemberRegistry;

        /**
         * Returns all membership information of the given node.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {object} Returns a dictionary where every the key of every entry is an absolute path of a set owner
         * node. The value of each entry is an array with the set names in which the node can be found as a member.
         *
         * @func
         */
        this.isMemberOf = core.isMemberOf;

        //this.getMiddleGuid = core.getMiddleGuid;

        /**
         * Get the GUID of a node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~GUID} Returns the globally unique identifier.
         * @func
         */
        this.getGuid = core.getGuid;

        //TODO this is only used in import - export use-cases, probably could be removed...
        /**
         * Set the GUID of a node. As the Core itself do not checks whether the GUID already exists. The use of
         * this function is only advised during the creation of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~GUID} guid - the new globally unique identifier.
         * @param {function()} callback
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setGuid = core.setGuid;

        /**
         * Gets a constraint object of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the constraint.
         *
         * @return {module:Core~Constraint | null} Returns the defined constraint or null if it was not
         * defined for the node.
         * @example
         * {
         *   script: "function (core, node, callback) {callback(null, {hasViolation: false, message: ''});}",
         *   priority: 1,
         *   info: "Should check unique name"
         * }
         * @func
         */
        this.getConstraint = core.getConstraint;

        /**
         * Sets a constraint object of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the constraint.
         * @param {module:Core~Constraint} constraint  - the constraint to be set.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setConstraint = core.setConstraint;

        /**
         * Removes a constraint from the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the constraint.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delConstraint = core.delConstraint;

        /**
         * Retrieves the list of constraint names defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns the array of names of constraints available for the node.
         *
         * @func
         */
        this.getConstraintNames = core.getConstraintNames;

        /**
         * Retrieves the list of constraint names defined specifically for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} Returns the array of names of constraints for the node.
         *
         * @func
         */
        this.getOwnConstraintNames = core.getOwnConstraintNames;

        /**
         * Checks if the given typeNode is really a base of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} type - the type node we want to check.
         *
         * @return {bool} The function returns true if the type is in the inheritance chain of the node or false
         * otherwise. Every node is type of itself.
         *
         * @func
         */
        this.isTypeOf = core.isTypeOf;

        /**
         * Checks if according to the META rules the given node can be a child of the parent.
         * @param {module:Core~Node} node - the node in question
         * @param {module:Core~Node} parent - the parent we like to test.
         *
         * @return {bool} The function returns true if according to the META rules the node can be a child of the
         * parent. The check does not cover multiplicity (so if the parent can only have twi children and it already
         * has them, this function will still returns true).
         * @func
         */
        this.isValidChildOf = core.isValidChildOf;

        /**
         * Returns the list of the META defined pointer names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the pointer names that are defined among the META rules of the node.
         *
         * @func
         */
        this.getValidPointerNames = core.getValidPointerNames;

        /**
         * Returns the list of the META defined set names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the set names that are defined among the META rules of the node.
         *
         * @func
         */
        this.getValidSetNames = core.getValidSetNames;

        /**
         * Returns the list of the META defined pointers of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} source - the source to test.
         * @param {string} name - the name of the pointer.
         *
         * @return {bool} The function returns true if according to the META rules, the given node is a valid
         * target of the given pointer of the source.
         *
         * @func
         */
        this.isValidTargetOf = core.isValidTargetOf;

        /**
         * Returns the list of the META defined attribute names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the attribute names that are defined among the META rules of the
         * node.
         *
         * @func
         */
        this.getValidAttributeNames = core.getValidAttributeNames;

        /**
         * Returns the list of the META defined attribute names of the node that were specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns the attribute names that are defined specifically for the node.
         *
         * @func
         */
        this.getOwnValidAttributeNames = core.getOwnValidAttributeNames;

        /**
         * Checks if the given value is of the necessary type, according to the META rules.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         * @param {object|primitive|null} value - the value to test.
         *
         * @return {bool} Returns true if the value matches the META definitions.
         *
         * @func
         */
        this.isValidAttributeValueOf = core.isValidAttributeValueOf;

        /**
         * Returns the list of the META defined aspect names of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns all the aspect names that are defined among the META rules of the
         * node.
         *
         * @func
         */
        this.getValidAspectNames = core.getValidAspectNames;

        /**
         * Returns the list of the META defined aspect names of the node that were specifically defined for the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns the aspect names that are specifically defined for the node.
         *
         * @func
         */
        this.getOwnValidAspectNames = core.getOwnValidAspectNames;

        /**
         * Returns the list of valid children types of the given aspect.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         *
         * @return {string[]} The function returns a list of absolute paths of nodes that are valid children of the node
         * and fits to the META rules defined for the aspect. Any children, visible under the given aspect of the node
         * must be an instance of at least one node represented by the absolute paths.
         *
         * @func
         */
        this.getAspectMeta = core.getAspectMeta;

        /**
         * Gives a JSON representation of the META rules of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {object} Returns an object that represents all the META rules of the node.
         * @example
         * {
         *   children: {
         *     items: [ "/1", "/c" ],
         *     minItems: [ -1, -1 ],
         *     maxItems: [ -1, -1 ]
         *   },
         *   attributes: {
         *     name: { type: "string" },
         *     level: { type: "integer"}
         *   },
         *   pointers: {
         *     ptr: {
         *       min: 1,
         *       max: 1,
         *       items: [ "/1" ],
         *       minItems: [ -1 ],
         *       maxItems: [ 1 ]
         *     },
         *     set: {
         *       min: -1,
         *       max: -1,
         *       items: [ "/c" ],
         *       minItems: [ -1 ],
         *       maxItems: [ -1 ]
         *     }
         *   },
         *   aspects: {
         *     filter: [ "/8", "/c" ]
         *   },
         *   constraints: {
         *     myConstraint: {
         *       script: "function (core, node, callback) {callback(null, {hasViolation: false, message: ''});}",
         *       priority: 1,
         *       info: "Should check unique name"
         *     }
         *   }
         * }
         * @example
         * {
         *   children: {},
         *   attributes: {
         *      name: { type: "string" },
         *   },
         *   pointers: {},
         *   aspects: {},
         *   constraints: {}
         * @func
         */
        this.getJsonMeta = core.getJsonMeta;

        /**
         * Returns the META rules specifically defined for the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {object} The function returns an object that represent the META rules that were defined
         * specifically for the node.
         * @example
         * see getJsonMeta
         * @func
         */
        this.getOwnJsonMeta = core.getOwnJsonMeta;

        /**
         * Removes all META rules that were specifically defined for the node (so the function do not touches
         * inherited rules).
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.clearMetaRules = core.clearMetaRules;

        /**
         * Sets the META rules of the attribute of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         * @param {object} rule - the rules that defines the attribute
         * @param {'string'|'integer'|'float'|'boolean'|'asset'} rule.type - the type of the attribute (valid types see
         * CONSTANTS.ATTRIBUTE_TYPES).
         * @param {string[]} [rule.enum] - if the attribute is an enumeration, this array contains the possible values
         * @param {string|number|boolean} [rule.default] - The value the attribute should have at the node. If not given
         * it should be set at some point.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setAttributeMeta = core.setAttributeMeta;

        /**
         * Removes an attribute definition from the META rules of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delAttributeMeta = core.delAttributeMeta;

        /**
         * Returns the definition object of an attribute from the META rules of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the attribute.
         *
         * @return {object} The function returns the definition object, where type is always defined.
         * @example
         * {
         *    type: "string"
         * }
         * @example
         * {
         *    type: "string",
         *    regexp: "^win"
         * }
         * @example
         * {
         *    type: "string",
         *    enum: [ "value1", "value2" ]
         * }
         * @example
         * {
         *    type: "boolean"
         * }
         * @example
         * {
         *    type: "integer"
         * }
         * @example
         * {
         *    type: "integer",
         *    min: 0,
         *    max: 10
         * }
         * @example
         * {
         *    type: "integer",
         *    enum: [ 3, 8 ]
         * }
         * @example
         * {
         *    type: "float",
         *    min: 0,
         *    max: 9.9
         * }
         * @example
         * {
         *    type: "asset"
         * }
         * @func
         */
        this.getAttributeMeta = core.getAttributeMeta;

        /**
         * Returns the list of absolute path of the valid children types of the node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The function returns an array of absolute paths of the nodes that was defined as valid
         * children for the node.
         *
         * @func
         */
        this.getValidChildrenPaths = core.getValidChildrenPaths;

        /**
         * Return a JSON representation of the META rules regarding the valid children of the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {module:Core~RelationRule} The function returns a detailed JSON structure that represents the META
         * rules regarding the possible children of the node.
         * @example
         * {
         *   '/5': { max: 1, min: -1 },
         *   '/c': { max: -1, min: 2 },
         *   max: 10,
         *   min: undefined
         * }
         * @func
         */
        this.getChildrenMeta = core.getChildrenMeta;

        /**
         * Sets the given child as a valid children type for the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {module:Core~Node} child - the valid child node.
         * @param {integer} [min] - the allowed minimum number of children from this given node type (if not given or
         * -1 is set, then there will be no minimum rule according this child type)
         * @param {integer} [max] - the allowed maximum number of children from this given node type (if not given or
         * -1 is set, then there will be no minimum rule according this child type)
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setChildMeta = core.setChildMeta;

        /**
         * Removes the given child rule from the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} childPath - the absolute path of the child which rule is to be removed from the node.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delChildMeta = core.delChildMeta;

        /**
         * Sets the global containment limits for the node.
         *
         * @param {integer} [min] - the allowed minimum number of children (if not given or
         * -1 is set, then there will be no minimum rule according children)
         * @param {integer} [max] - the allowed maximum number of children (if not given or
         * -1 is set, then there will be no maximum rule according children)
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setChildrenMetaLimits = core.setChildrenMetaLimits;

        /**
         * Sets the given target as a valid target type for the pointer/set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         * @param {module:Core~Node} target - the valid target/member node.
         * @param {integer} [min] - the allowed minimum number of target/member from this given node type (if not
         * given or -1 is set, then there will be no minimum rule according this target type)
         * @param {integer} [max] - the allowed maximum number of target/member from this given node type (if not
         * given or -1 is set, then there will be no minimum rule according this target type)
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setPointerMetaTarget = core.setPointerMetaTarget;

        /**
         * Removes a possible target type from the pointer/set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set
         * @param {string} targetPath - the absolute path of the possible target type.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delPointerMetaTarget = core.delPointerMetaTarget;

        /**
         * Sets the global target limits for pointer/set of the node. On META level the only distinction between
         * pointer and sets is the global multiplicity which has to maximize the number of possible targets to 1 in
         * case of 'pure' pointer definitions.
         *
         * @param {integer} [min] - the allowed minimum number of children (if not given or
         * -1 is set, then there will be no minimum rule according targets)
         * @param {integer} [max] - the allowed maximum number of children (if not given or
         * -1 is set, then there will be no maximum rule according targets)
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setPointerMetaLimits = core.setPointerMetaLimits;

        /**
         * Removes the complete META rule regarding the given pointer/set of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delPointerMeta = core.delPointerMeta;

        /**
         * Return a JSON representation of the META rules regarding the given pointer/set of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the pointer/set.
         *
         * @return {module:Core~RelationRule} The function returns a detailed JSON structure that represents the META
         * rules regarding the given pointer/set of the node.
         * @example
         * pointer
         * {
         *   '/a': { max: 1, min: -1 },
         *   max: 1,
         *   min: 1
         * }
         * @example
         * set
         * {
         *   '/G': { max: -1, min: -1},
         *   '/i': { max: -1, min: -1},
         *   max: -1
         *   min: -1
         * }
         * @func
         */
        this.getPointerMeta = core.getPointerMeta;

        /**
         * Sets a valid type for the given aspect of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         * @param {module:Core~Node} target - the valid type for the aspect.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.setAspectMetaTarget = core.setAspectMetaTarget;

        /**
         * Removes a valid type from the given aspect of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         * @param {string} targetPath - the absolute path of the valid type of the aspect.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delAspectMetaTarget = core.delAspectMetaTarget;

        /**
         * Removes the given aspect rule of the node.
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the aspect.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delAspectMeta = core.delAspectMeta;

        /**
         * Searches for the closest META node of the node in question.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {module:Core~Node | null} Returns the first node (including itself) among the inheritance chain
         * that is a META node. It returns null if it does not find such node (ideally the only node with this result
         * is the ROOT).
         *
         * @func
         */
        this.getBaseType = this.getMetaType = core.getBaseType;

        /**
         * Checks if there is a node with the given name in the nodes inheritance chain (excluding itself).
         * @param {module:Core~Node} node - the node in question.
         * @param {string} name - the name of the base node.
         *
         * @return {bool} The function returns true if it finds an ancestor with the given name attribute.
         *
         * @func
         */
        this.isInstanceOf = core.isInstanceOf;

        //this.nodeDiff = core.nodeDiff;

        /**
         * Generates a differential tree among the two states of the project that contains the necessary changes
         * that can modify the source to be identical to the target. The result is in form of a json object.
         * @param {module:Core~Node} sourceRoot - the root node of the source state.
         * @param {module:Core~Node} targetRoot - the root node of the target state.
         *
         * @param {function(string, object)} callback
         *
         * @func
         */
        this.generateTreeDiff = core.generateTreeDiff;

        //this.generateLightTreeDiff = core.generateLightTreeDiff;

        /**
         * Apply changes to the current project.
         * @param {module:Core~Node} root - the root of the containment hierarchy where we wish to apply the changes
         * @param {object} patch - the tree structured collection of changes represented with a special JSON object
         * @param {function(string)} callback
         *
         * @func
         */
        this.applyTreeDiff = core.applyTreeDiff;

        /**
         * Tries to merge two patch object. The patches ideally represents changes made by two parties. They represents
         * changes from the same source ending in different states. Our aim is to generate a single patch that could
         * cover the changes of both party.
         * @param {object} mine - the tree structured JSON patch that represents my changes.
         * @param {object} theirs - the tree structured JSON patch that represents the changes of the other party.
         *
         * @return {object} The function returns with an object that contains the conflicts (if any) and the merged
         * patch.
         *
         * @func
         */
        this.tryToConcatChanges = core.tryToConcatChanges;

        /**
         * When our attempt to merge two patches ended in some conflict, then we can modify that result highlighting
         * that in case of every conflict, which side we prefer (mine vs. theirs). If we give that object as an input
         * to this function, it will finish the merge resolving the conflict according our settings and present a final
         * patch.
         * @param {object} conflict - the object that represents our settings for every conflict and the so-far-merged
         * patch.
         *
         * @return {object} The function results in a tree structured patch object that contains the changesthat cover
         * both parties modifications (and the conflicts are resolved according the input settings).
         *
         * @func
         */
        this.applyResolution = core.applyResolution;

        /**
         * Checks if the node is abstract.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} The function returns true if the registry entry 'isAbstract' of the node if true hence
         * the node is abstract.
         *
         * @func
         */
        this.isAbstract = core.isAbstract;

        /**
         * Check is the node is a connection-like node.
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} Returns true if both the 'src' and 'dst' pointer are defined as valid for the node.
         *
         * @func
         */
        this.isConnection = core.isConnection;

        /**
         * Retrieves the valid META nodes that can be base of a child of the node.
         * @param {object} parameters - the input parameters of the query.
         * @param {module:Core~Node} parameters.node - the node in question.
         * @param {module:Core~Node[]} [parameters.children] - the children of the node in question.
         * @param {bool} - [parameters.sensitive] - if true, the query filters out the abstract and connection-like
         * nodes (the default value is false)
         * @param {bool} - [parameters.multiplicity] - if true, the query tries to filter out even more nodes according
         * to the multiplicity rules (the default value is false, the check is only meaningful if all the children were
         * passed)
         * @param {string} - [parameters.aspect] - if given, the query filters to contain only types that are visible
         * in the given aspect.
         * @return {module:Core~Node[]} The function returns a list of valid nodes that can be instantiated as a
         * child of the node.
         *
         * @func
         */
        this.getValidChildrenMetaNodes = core.getValidChildrenMetaNodes;

        /**
         * Retrieves the valid META nodes that can be base of a member of the set of the node.
         * @param {object} parameters - the input parameters of the query.
         * @param {module:Core~Node} parameters.node - the node in question.
         * @param {string} parameters.name - the name of the set.
         * @param {module:Core~Node[]} [parameters.members] - the members of the set of the node in question.
         * @param {bool} - [parameters.sensitive] - if true, the query filters out the abstract and connection-like
         * nodes (the default value is false)
         * @param {bool} - [parameters.multiplicity] - if true, the query tries to filter out even more nodes according
         * to the multiplicity rules (the default value is false, the check is only meaningful if all the members were
         * passed)
         *
         * @return {module:Core~Node[]} The function returns a list of valid nodes that can be instantiated as a
         * member of the set of the node.
         *
         * @func
         */
        this.getValidSetElementsMetaNodes = core.getValidSetElementsMetaNodes;

        /**
         * Returns all META nodes.
         * @param {module:Core~Node} node - any node of the containment hierarchy.
         *
         * @return {Object<string, module:Core~Node>} The function returns a dictionary. The keys of the dictionary are the absolute paths of
         * the META nodes of the project. Every value of the dictionary is a {@link module:Core~Node}.
         *
         * @func
         */
        this.getAllMetaNodes = core.getAllMetaNodes;

        /**
         * Checks if the node is a META node.
         * @param {module:Core~Node} node - the node to test.
         *
         * @return {bool} Returns true if the node is a member of the METAAspectSet of the ROOT node hence can be
         * seen as a META node.
         *
         * @func
         */
        this.isMetaNode = core.isMetaNode;

        /**
         * Checks if the member is completely overridden in the set of the node.
         * @param {module:Core~Node} node - the node to test.
         * @param {string} setName - the name of the set of the node.
         * @param {string} memberPath - the path of the member in question.
         *
         * @return {bool} Returns true if the member exists in the base of the set, but was
         * added to the given set as well, which means a complete override. If the set does not exist
         * or the member do not have a 'base' member or just some property was overridden, the function returns
         * false.
         *
         * @func
         */
        this.isFullyOverriddenMember = core.isFullyOverriddenMember;

        /**
         * Checks if the mixins allocated with the node can be used.
         * Every mixin node should be on the Meta.
         * Every rule (attribute/pointer/set/aspect/containment/constraint) should be defined only in one mixin.
         *
         * @param {module:Core~Node} node - the node to test.
         *
         * @return {module:Core~MixinViolation[]} Returns the array of violations. If the array is empty,
         * there is no violation.
         *
         * @func
         */
        this.getMixinErrors = core.getMixinErrors;

        /**
         * Gathers the paths of the mixin nodes associated with the node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The paths of the mixins in an array.
         *
         * @func
         */
        this.getMixinPaths = core.getMixinPaths;

        /**
         * Gathers the paths of the mixin nodes associated with the node
         * that were defined specifically for the given node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string[]} The paths of the own mixins in an array.
         *
         * @func
         */
        this.getOwnMixinPaths = core.getOwnMixinPaths;

        /**
         * Gathers the mixin nodes associated with the node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {Object<string, module:Core~Node>} The dictionary of the mixin nodes keyed by their paths.
         *
         * @func
         */
        this.getMixinNodes = core.getMixinNodes;

        /**
         * Gathers the mixin nodes associated with the node that were defined specifically for the given node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {Object<string, module:Core~Node>} The dictionary of the own mixin nodes keyed by their paths.
         *
         * @func
         */
        this.getOwnMixinNodes = core.getOwnMixinNodes;

        /**
         * Removes a mixin from the mixin set of the node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {string} mixinPath - the path of the mixin node.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.delMixin = core.delMixin;

        /**
         * Adds a mixin to the mixin set of the node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {string} mixinPath - the path of the mixin node.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.addMixin = core.addMixin;

        /**
         * Removes all mixins for a given node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {undefined | Error} If the node is not allowed to be modified, the function returns
         * an error.
         *
         * @func
         */
        this.clearMixins = core.clearMixins;

        /**
         * Searches for the closest META node of the node in question and the direct mixins of that node.
         * @param {module:Core~Node} node - the node in question
         *
         * @return {Object<string, module:Core~Node>} Returns the closest Meta node that is a base of the given node
         * plus it returns all the mixin nodes associated with the base in a path-node dictionary.
         *
         * @func
         */
        this.getBaseTypes = core.getBaseTypes;

        /**
         * Checks if the given path can be added as a mixin to the given node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {string} mixinPath - the path of the mixin node.
         *
         * @return {Object} - Returns if the mixin could be added, or the reason why it is not.
         *
         * @func
         */
        this.canSetAsMixin = core.canSetAsMixin;

        //library function TODO checking everything and adding all new functions

        /**
         * It adds a project as library to your project by copying it over. The library will be a node
         * with the given name directly under your project's ROOT. It becomes a read-only portion of your project.
         * You will only be able to manipulate it with library functions, but cannot edit the individual nodes inside.
         * However you will be able to instantiate or copy the nodes into other places of your project. Every node
         * that was part of the META in the originating project becomes part of your project's meta.
         * @param {module:Core~Node} node - any regular node in your project.
         * @param {string} name - the name of the library you wish to use as a namespace in your project.
         * @param {string} libraryRootHash - the hash of your library's root
         * (must exist in the project's collection at the time of call).
         * @param {Object} libraryInfo - information about your project.
         * @param {string} libraryInfo.projectId - the projectId of your library.
         * @param {string} libraryInfo.branchName - the branch that your library follows in the origin project.
         * @param {string} libraryInfo.commitHash - the version of your library.
         * @param {function()} callback
         *
         * @func
         */
        this.addLibrary = core.addLibrary;

        /**
         * It updates a library in your project based on the input information. It will 'reaplace' the old
         * version, keeping as much information as possible regarding the instances.
         * @param {module:Core~Node} node - any regular node in your project.
         * @param {string} name - the name of the library you want to update.
         * @param {string} libraryRootHash - the hash of your library's new root
         * (must exist in the project's collection at the time of call).
         * @param {object} libraryInfo - information about your project.
         * @param {string} libraryInfo.projectId - the projectId of your library.
         * @param {string} libraryInfo.branchName - the branch that your library follows in the origin project.
         * @param {string} libraryInfo.commitHash - the version of your library.
         * @param {function()} callback
         *
         * @func
         */
        this.updateLibrary = core.updateLibrary;

        /**
         * Gives back the list of libraries in your project.
         *
         * @param {module:Core~Node} node - any node in your project.
         *
         * @return {string[]} - Returns the fully qualified names of all the libraries in your project
         * (even embedded ones).
         *
         * @func
         */
        this.getLibraryNames = core.getLibraryNames;

        /**
         * Return the root of the inheritance chain of your Meta nodes.
         *
         * @param {module:Core~Node} node - any node in your project.
         *
         * @return {module:Core~Node} - Returns the acting FCO of your project.
         *
         * @func
         */
        this.getFCO = core.getFCO;

        /**
         * Returns true if the node in question is a library root..
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} - Returns true if your node is a library root (even if it is embedded in other library),
         * false otherwise.
         *
         * @func
         */
        this.isLibraryRoot = core.isLibraryRoot;

        /**
         * Returns true if the node in question is a library element..
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {bool} - Returns true if your node is a library element, false otherwise.
         *
         * @func
         */
        this.isLibraryElement = core.isLibraryElement;

        /**
         * Returns the resolved namespace for the node. If node is not in a library it returns the
         * empty string. If the node is in a library of a library -
         * the full name space is the library names joined together by dots.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} - Returns the name space of the node.
         *
         * @example NS1.NS2
         *
         * @func
         */
        this.getNamespace = core.getNamespace;

        /**
         * Returns the fully qualified name of the node, which is the list of its namespaces separated
         * by dot and followed by the name of the node.
         *
         * @param {module:Core~Node} node - the node in question.
         *
         * @return {string} - Returns the fully qualified name of the node,
         * i.e. its namespaces and name join together by dots.
         *
         * @example NS1.NS2.name
         *
         * @func
         */
        this.getFullyQualifiedName = core.getFullyQualifiedName;

        /**
         * Removes a library from your project. It will also remove any remaining instances of the specific library.
         *
         * @param {module:Core~Node} node - any node in your project.
         * @param {string} name - the name of your library.
         *
         * @func
         */
        this.removeLibrary = core.removeLibrary;

        /**
         * Returns the origin GUID of any library node.
         *
         * @param {module:Core~Node} node - the node in question.
         * @param {undefined | string} name - name of the library where we want to deduct the GUID from. If not given,
         * than the GUID is computed from the direct library root of the node
         *
         * @return {module:Core~GUID | Error} - Returns the origin GUID of the node or
         * error if the query cannot be fulfilled.
         *
         * @func
         */
        this.getLibraryGuid = core.getLibraryGuid;

        /**
         * Rename a library in your project.
         *
         * @param {module:Core~Node} node - any node in your project.
         * @param {string} oldName - the current name of the library.
         * @param {string} newName - the new name of the project.
         *
         * @func
         */
        this.renameLibrary = core.renameLibrary;

        /**
         * Returns the info associated with the library.
         *
         * @param {module:Core~Node} node - any node in the project.
         * @param {string} name - the name of the library.
         *
         * @return {object} - Returns the information object, stored alongside the library (that basically
         * carries metaData about the library).
         *
         * @func
         */
        this.getLibraryInfo = core.getLibraryInfo;

        /**
         * Returns the root node of the given library.
         *
         * @param {module:Core~Node} node - any node in the project.
         * @param {string} name - the name of the library.
         *
         * @return {module:Core~Node | null} - Returns the library root node or null, if the library is unknown.
         *
         * @func
         */
        this.getLibraryRoot = core.getLibraryRoot;

        /**
         * Returns all the Meta nodes within the given library.
         * By default it will include nodes defined in any library within the given library.
         *
         * @param {module:Core~Node} node - any node of your project.
         * @param {string} name - name of your library.
         * @param {bool} [onlyOwn] - if true only returns with Meta nodes defined in the library itself.
         *
         * @return {module:Core~Node[]} - Returns an array of core nodes that are part of your meta from
         * the given library.
         *
         * @func
         */
        this.getLibraryMetaNodes = core.getLibraryMetaNodes;

        /**
         * The function traverses the sub-tree of the project starting with the given root and calls the
         * visit function for every node.
         *
         * @param {module:Core~Node} root - the root node of the sub-tree that needs to be traversed.
         * @param {object} options - parameters to control the traversing.
         * @param {bool} [options.excludeRoot = false] - controls whether the root should be excluded from visit.
         * @param {'BFS'|'DFS'} [options.order = 'BFS'] - controls if the traversal order should be breadth first
         * or depth first.
         * @param {integer} [options.maxParallelLoad = 100]- the maximum number of parallel loads allowed.
         * @param {bool} [options.stopOnError = true]- controls if the traverse should stop in case of error.
         * @param {function(module:Core~Node,function)} visitFn - the visitation function that will be called for
         * every node in the sub-tree, the second parameter of the function is a callback that should be called to
         * note to the traversal function that the visitation for a given node finished.
         * @param {function()} callback
         *
         * @func
         */
        this.traverse = core.traverse;

        this.getClosureInformation = core.getClosureInformation;
        this.importClosure = core.importClosure;

        /**
         * Collects the paths of all the instances of the given node.
         * @param {module:Core~Node} node - the node in question.
         *
         *@return {string[]} The function returns an array of the absolute paths of the instances.
         *
         * @func
         */
        this.getInstancePaths = core.getInstancePaths;

        /**
         * Loads all the instances of the given node.
         * @param {module:Core~Node} node - the node in question.
         * @param {function(string, module:Core~Node[])} callback
         *
         * @func
         */
        this.loadInstances = core.loadInstances;
    }

    return Core;
});

/*globals define*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/core/coreQ',['common/core/core', 'q'], function (Core, Q) {

    'use strict';
    /**
     * @param {object} storage
     * @param {object} options - contains logging information
     * @extends Core
     * @constructor
     */
    function CoreQ(storage, options) {
        var self = this;
        Core.call(self, storage, options);

        var loadChildOrg = this.loadChild;
        this.loadChild = function (parent, relativeId, callback) {
            var deferred = Q.defer();
            loadChildOrg(parent, relativeId, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadRootOrg = this.loadRoot;
        this.loadRoot = function (hash, callback) {
            var deferred = Q.defer();
            loadRootOrg(hash, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadByPathOrg = this.loadByPath;
        this.loadByPath = function (startNode, relativeId, callback) {
            var deferred = Q.defer();
            loadByPathOrg(startNode, relativeId, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadChildrenOrg = this.loadChildren;
        this.loadChildren = function (parent, callback) {
            var deferred = Q.defer();
            loadChildrenOrg(parent, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadOwnChildrenOrg = this.loadOwnChildren;
        this.loadOwnChildren = function (parent, callback) {
            var deferred = Q.defer();
            loadOwnChildrenOrg(parent, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadPointerOrg = this.loadPointer;
        this.loadPointer = function (source, pointerName, callback) {
            var deferred = Q.defer();
            loadPointerOrg(source, pointerName, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadCollectionOrg = this.loadCollection;
        this.loadCollection = function (target, pointerName, callback) {
            var deferred = Q.defer();
            loadCollectionOrg(target, pointerName, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadSubTreeOrg = this.loadSubTree;
        this.loadSubTree = function (node, callback) {
            var deferred = Q.defer();
            loadSubTreeOrg(node, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadOwnSubTreeOrg = this.loadOwnSubTree;
        this.loadOwnSubTree = function (node, callback) {
            var deferred = Q.defer();
            loadOwnSubTreeOrg(node, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var loadTreeOrg = this.loadTree;
        this.loadTree = function (rootHash, callback) {
            var deferred = Q.defer();
            loadTreeOrg(rootHash, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var applyTreeDiffOrg = this.applyTreeDiff;
        this.applyTreeDiff = function (root, patch, callback) {
            var deferred = Q.defer();
            applyTreeDiffOrg(root, patch, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var generateTreeDiffOrg = this.generateTreeDiff;
        this.generateTreeDiff = function (sourceRoot, targetRoot, callback) {
            var deferred = Q.defer();
            generateTreeDiffOrg(sourceRoot, targetRoot, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var setGuidOrg = this.setGuid;
        this.setGuid = function (node, guid, callback) {
            var deferred = Q.defer();
            setGuidOrg(node, guid, deferred.resolve);

            return deferred.promise.nodeify(callback);
        };

        var addLibraryOrg = this.addLibrary;
        this.addLibrary = function (node, name, libraryRootHash, libraryInfo, callback) {
            var deferred = Q.defer();
            addLibraryOrg(node, name, libraryRootHash, libraryInfo, deferred.resolve);

            return deferred.promise.nodeify(callback);
        };

        var updateLibraryOrg = this.updateLibrary;
        this.updateLibrary = function (node, name, updatedLibraryRootHash, libraryInfo, updateInstructions, callback) {
            var deferred = Q.defer();
            updateLibraryOrg(node, name, updatedLibraryRootHash, libraryInfo, updateInstructions, function (err, result) {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve(result);
                }
            });

            return deferred.promise.nodeify(callback);
        };

        var traverseOrg = this.traverse;
        this.traverse = function (node, options, visitFn, callback) {
            var deferred = Q.defer();
            traverseOrg(node, options, visitFn, function (err, result) {
                if (err) {
                    deferred.reject(err);
                } else {
                    deferred.resolve(result);
                }
            });
            return deferred.promise.nodeify(callback);
        };

        var loadInstancesOrg = this.loadInstances;
        this.loadInstances = function (node, callback) {
            var deferred = Q.defer();
            loadInstancesOrg(node, function (err, res) {
                if (err) {
                    deferred.reject(err instanceof Error ? err : new Error(err));
                } else {
                    deferred.resolve(res);
                }
            });

            return deferred.promise.nodeify(callback);
        };
    }

    CoreQ.prototype = Object.create(Core.prototype);
    CoreQ.prototype.constructor = CoreQ;

    return CoreQ;
});
/*globals define*/
/*jshint browser:true*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('js/client/constants',[
    'common/storage/constants',
    'common/core/constants'
], function (STORAGE_CONSTANTS, CORE_CONSTANTS) {
    'use strict';

    return {

        STORAGE: STORAGE_CONSTANTS,
        CORE: CORE_CONSTANTS,

        BRANCH_STATUS: STORAGE_CONSTANTS.BRANCH_STATUS,

        UNCAUGHT_EXCEPTION: 'UNCAUGHT_EXCEPTION',

        // Events
        NETWORK_STATUS_CHANGED: 'NETWORK_STATUS_CHANGED',
        BRANCH_STATUS_CHANGED: 'BRANCH_STATUS_CHANGED',

        BRANCH_CHANGED: 'BRANCH_CHANGED',
        PROJECT_CLOSED: 'PROJECT_CLOSED',
        PROJECT_OPENED: 'PROJECT_OPENED',

        UNDO_AVAILABLE: 'UNDO_AVAILABLE',
        REDO_AVAILABLE: 'REDO_AVAILABLE',

        // general notification event
        NOTIFICATION: 'NOTIFICATION',
        CONNECTED_USERS_CHANGED: 'CONNECTED_USERS_CHANGED',

        // Constraint Checking
        META_RULES_RESULT: 'META_RULES_RESULT',
        CONSTRAINT_RESULT: 'CONSTRAINT_RESULT'
    };
});
/*globals define*/
/*jshint node: true, browser: true, bitwise: false*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/util/guid',[],function () {
    'use strict';

    var guid = function () {
        var S4 = function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        };

        //return GUID
        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());
    };

    return guid;
});
/*globals define*/
/*jshint browser: true*/
/**
 * REGISTRY KEY NAMES USED BY THE UI
 *
 * @author rkereskenyi / https://github.com/rkereskenyi
 */

define('js/RegistryKeys',[], function () {

    'use strict';

    return {
        COLOR: 'color',   //fill color of the item
        TEXT_COLOR: 'textColor',   //color of the texts of the item
        BORDER_COLOR: 'borderColor',   //border color of the item (if any)
        POSITION: 'position',  //position of the item {x, y}
        ROTATION: 'rotation',   //rotation of the item
        DECORATOR: 'decorator', //custom decorator name of the item
        IS_PORT: 'isPort',  //if the item is port in its parent or not
        IS_ABSTRACT: 'isAbstract',  //whether the item is abstract or not !!! (attribute???)
        REPLACEABLE: 'replaceable',  //whether the item is replaceable or not (not necessarily inherited).
        LINE_STYLE: 'lineStyle',    //the style of the line (solid, dot, dash-dot)
        LINE_TYPE: 'lineType',      //the type of the line (straight, bezier, ...)
        LINE_WIDTH: 'lineWidth',     //width of the line
        LINE_START_ARROW: 'lineStartArrow',     //start arrow of a line
        LINE_END_ARROW: 'lineEndArrow',     //start arrow of a line
        LINE_CUSTOM_POINTS: 'lineCustomPoints',  //custom routing points of a line
        LINE_LABEL_PLACEMENT: 'lineLabel', // Where the connection labels should be placed 'src', 'mid', 'dst'.

        //TODO maybe we should harmonize with project registry
        VALID_PLUGINS: 'validPlugins', //space separated list of valid plugins for the project
        USED_ADDONS: 'usedAddOns', //space separated list of used addons in the given project
        VALID_VISUALIZERS: 'validVisualizers', //space separated list of valid visualizers for the node
        VALID_DECORATORS: 'validDecorators', //space separated list of valid decorators for the project
        /*
         *  MISC
         */
        PROJECT_REGISTRY: 'ProjectRegistry',
        DISPLAY_FORMAT: 'DisplayFormat',
        SVG_ICON: 'SVGIcon',
        PORT_SVG_ICON: 'PortSVGIcon',
        TREE_ITEM_COLLAPSED_ICON: 'TreeItemCollapsedIcon',
        TREE_ITEM_EXPANDED_ICON: 'TreeItemExpandedIcon',

        /*
         * META_SHEETS_METADATA (title, order, setID, etc)
         */
        META_SHEETS: 'MetaSheets',

        /*
         * CROSSCUTS_META_INFO_REGISTRY_KEY
         */
        CROSSCUTS: 'CrossCuts',

        /*
         * DISABLED CONNECTION AREAS FOR DIAGRAM-DESIGNER-WIDGET DECORATORS ARE STORED UNDER THIS REGISTRY KEY
         * ON A PER DECORATOR BASIS
         */
        DIAGRAM_DESIGNER_WIDGET_DECORATOR_DISABLED_CONNECTION_AREAS:
            'diagramDesignerWidgetDecoratorDisabledConnectionAreas_'
    };
});
/*globals define, console*/
/*jshint browser: true*/
/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */

define('js/client/gmeNodeGetter',['js/RegistryKeys'], function (REG_KEYS) {
    'use strict';

    function _logDeprecated(oldFn, newFn, comment) {
        var commentStr = comment ? comment : '';
        console.warn('"gmeNode.' + oldFn + '" is deprecated and will eventually be removed, use "gmeNode.' + newFn +
        '" instead.' + commentStr);
    }

    function _getNode(nodes, path) {
        return nodes[path] && nodes[path].node;
    }

    /**
     * @param {string} _id - Path of node.
     * @param {GmeLogger} logger - logger.
     * @param {object} state - state of the client.
     * @param {function} storeNode - invoked when storing new nodes.
     * @constructor
     */
    function GMENode(_id, logger, state, storeNode) {
        this._id = _id;
        this._logger = logger;
        this._state = state;
        this._storeNode = storeNode;
    }

    GMENode.prototype.getParentId = function () {
        //just for sure, as it may missing from the cache
        return this._storeNode(this._state.core.getParent(this._state.nodes[this._id].node));
    };

    GMENode.prototype.getId = function () {
        return this._id;
    };

    GMENode.prototype.getRelid = function () {
        return this._state.core.getRelid(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getGuid = function () {
        return this._state.core.getGuid(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getChildrenIds = function () {
        return this._state.core.getChildrenPaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getChildrenRelids = function () {
        return this._state.core.getChildrenRelids(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getBaseId = function () {
        var base = this._state.core.getBase(this._state.nodes[this._id].node);
        if (base) {
            return this._storeNode(base);
        } else {
            return null;
        }
    };

    GMENode.prototype.isValidNewBase = function (basePath) {
        var base;
        if (typeof basePath === 'string') {
            base = _getNode(this._state.nodes, basePath);
            if (base) {
                return this._state.core.isValidNewBase(this._state.nodes[this._id].node, base);
            } else {
                return false;
            }
        } else if (basePath === undefined || basePath === null) {
            return true;
        } else {
            return false;
        }
    };

    GMENode.prototype.isValidNewParent = function (parentPath) {
        var parent;
        if (typeof parentPath === 'string') {
            parent = _getNode(this._state.nodes, parentPath);
            if (parent) {
                return this._state.core.isValidNewParent(this._state.nodes[this._id].node, parent);
            } else {
                return false;
            }
        } else {
            return false;
        }
    };

    GMENode.prototype.getInheritorIds = function () {
        return [];
    };

    GMENode.prototype.getAttribute = function (name) {
        return this._state.core.getAttribute(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnAttribute = function (name) {
        return this._state.core.getOwnAttribute(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getEditableAttribute = function (name) {
        var value = this._state.core.getAttribute(this._state.nodes[this._id].node, name);
        if (typeof value === 'object') {
            return JSON.parse(JSON.stringify(value));
        }
        return value;
    };

    GMENode.prototype.getOwnEditableAttribute = function (name) {
        var value = this._state.core.getOwnAttribute(this._state.nodes[this._id].node, name);
        if (typeof value === 'object') {
            return JSON.parse(JSON.stringify(value));
        }
        return value;
    };

    GMENode.prototype.getRegistry = function (name) {
        return this._state.core.getRegistry(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getOwnRegistry = function (name) {
        return this._state.core.getOwnRegistry(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getEditableRegistry = function (name) {
        var value = this._state.core.getRegistry(this._state.nodes[this._id].node, name);
        if (typeof value === 'object') {
            return JSON.parse(JSON.stringify(value));
        }
        return value;
    };

    GMENode.prototype.getOwnEditableRegistry = function (name) {
        var value = this._state.core.getOwnRegistry(this._state.nodes[this._id].node, name);
        if (typeof value === 'object') {
            return JSON.parse(JSON.stringify(value));
        }
        return value;
    };

    GMENode.prototype.getPointer = function (name) {
        //return _core.getPointerPath(_nodes[this._id].node,name);
        if (name === 'base') {
            //base is a special case as it complicates with inherited children
            return {
                to: this._state.core.getPath(this._state.core.getBase(this._state.nodes[this._id].node)),
                from: []
            };
        }
        return {to: this._state.core.getPointerPath(this._state.nodes[this._id].node, name), from: []};
    };

    GMENode.prototype.getPointerId = function (name) {
        return this.getPointer(name).to;
    };

    GMENode.prototype.getOwnPointer = function (name) {
        return {to: this._state.core.getOwnPointerPath(this._state.nodes[this._id].node, name), from: []};
    };

    GMENode.prototype.getOwnPointerId = function (name) {
        return this.getOwnPointer(name).to;
    };

    GMENode.prototype.getPointerNames = function () {
        return this._state.core.getPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnPointerNames = function () {
        return this._state.core.getOwnPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAttributeNames = function () {
        return this._state.core.getAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getValidAttributeNames = function () {
        return this._state.core.getValidAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnAttributeNames = function () {
        return this._state.core.getOwnAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnValidAttributeNames = function () {
        return this._state.core.getOwnValidAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAttributeMeta = function (name) {
        return this._state.core.getAttributeMeta(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getRegistryNames = function () {
        return this._state.core.getRegistryNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnRegistryNames = function () {
        return this._state.core.getOwnRegistryNames(this._state.nodes[this._id].node);
    };

    //SET
    GMENode.prototype.getMemberIds = function (setName) {
        return this._state.core.getMemberPaths(this._state.nodes[this._id].node, setName);
    };

    GMENode.prototype.getSetNames = function () {
        return this._state.core.getSetNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getMemberAttributeNames = function (setName, memberId) {
        return this._state.core.getMemberAttributeNames(this._state.nodes[this._id].node, setName, memberId);
    };

    GMENode.prototype.getMemberAttribute = function (setName, memberId, attrName) {
        return this._state.core.getMemberAttribute(this._state.nodes[this._id].node, setName, memberId, attrName);
    };

    GMENode.prototype.getEditableMemberAttribute = function (setName, memberId, attrName) {
        var attr = this._state.core.getMemberAttribute(this._state.nodes[this._id].node, setName, memberId, attrName);
        if (attr !== null && attr !== undefined) {
            return JSON.parse(JSON.stringify(attr));
        }
        return null;
    };

    GMENode.prototype.getMemberRegistryNames = function (setName, memberId) {
        return this._state.core.getMemberRegistryNames(this._state.nodes[this._id].node, setName, memberId);
    };

    GMENode.prototype.getMemberRegistry = function (setName, memberId, regName) {
        return this._state.core.getMemberRegistry(this._state.nodes[this._id].node, setName, memberId, regName);
    };

    GMENode.prototype.getEditableMemberRegistry = function (setName, memberId, regName) {
        var attr = this._state.core.getMemberRegistry(this._state.nodes[this._id].node, setName, memberId, regName);
        if (attr !== null && attr !== undefined) {
            return JSON.parse(JSON.stringify(attr));
        }
        return null;
    };

    GMENode.prototype.getSetRegistry = function (setName, regName) {
        return this._state.core.getSetRegistry(this._state.nodes[this._id].node, setName, regName);
    };

    GMENode.prototype.getSetRegistryNames = function (setName) {
        return this._state.core.getSetRegistryNames(this._state.nodes[this._id].node, setName);
    };

    GMENode.prototype.getSetAttribute = function (setName, attrName) {
        return this._state.core.getSetAttribute(this._state.nodes[this._id].node, setName, attrName);
    };

    GMENode.prototype.getSetAttributeNames = function (setName) {
        return this._state.core.getSetAttributeNames(this._state.nodes[this._id].node, setName);
    };

    //META
    GMENode.prototype.getValidChildrenTypes = function () {
        _logDeprecated('getValidChildrenTypes()', 'getValidChildrenIds()');
        return this.getValidChildrenIds();
    };

    GMENode.prototype.getValidAttributeNames = function () {
        return this._state.core.getValidAttributeNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isValidAttributeValueOf = function (name, value) {
        return this._state.core.isValidAttributeValueOf(this._state.nodes[this._id].node, name, value);
    };

    GMENode.prototype.getValidPointerNames = function () {
        return this._state.core.getValidPointerNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getValidSetNames = function () {
        return this._state.core.getValidSetNames(this._state.nodes[this._id].node);
    };

    //constraint functions
    GMENode.prototype.getConstraintNames = function () {
        return this._state.core.getConstraintNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnConstraintNames = function () {
        return this._state.core.getOwnConstraintNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getConstraint = function (name) {
        return this._state.core.getConstraint(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.toString = function () {
        return this._state.core.getAttribute(this._state.nodes[this._id].node, 'name') + ' (' + this._id + ')';
    };

    GMENode.prototype.getCollectionPaths = function (name) {
        return this._state.core.getCollectionPaths(this._state.nodes[this._id].node, name);
    };

    GMENode.prototype.getInstancePaths = function () {
        return this._state.core.getInstancePaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getJsonMeta = function () {
        return this._state.core.getJsonMeta(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isConnection = function () {
        return this._state.core.isConnection(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isAbstract = function () {
        return this._state.core.isAbstract(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isLibraryRoot = function () {
        return this._state.core.isLibraryRoot(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isLibraryElement = function () {
        return this._state.core.isLibraryElement(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getFullyQualifiedName = function () {
        return this._state.core.getFullyQualifiedName(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getNamespace = function () {
        return this._state.core.getNamespace(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getLibraryGuid = function () {
        return this._state.core.getLibraryGuid(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getCrosscutsInfo = function () {
        return this._state.core.getRegistry(this._state.nodes[this._id].node, REG_KEYS.CROSSCUTS) || [];
    };

    GMENode.prototype.getValidChildrenTypesDetailed = function (aspect, noFilter) {
        var parameters = {
                node: this._state.nodes[this._id].node,
                children: [],
                sensitive: !noFilter,
                multiplicity: false,
                aspect: aspect
            },
            fullList,
            filteredList,
            validTypes = {},
            keys = this.getChildrenIds(),
            i;

        for (i = 0; i < keys.length; i++) {
            if (this._state.nodes[keys[i]]) {
                parameters.children.push(this._state.nodes[keys[i]].node);
            }
        }

        fullList = this._state.core.getValidChildrenMetaNodes(parameters);

        parameters.multiplicity = true;
        filteredList = this._state.core.getValidChildrenMetaNodes(parameters);

        for (i = 0; i < fullList.length; i += 1) {
            validTypes[this._state.core.getPath(fullList[i])] = false;
        }

        for (i = 0; i < filteredList.length; i += 1) {
            validTypes[this._state.core.getPath(filteredList[i])] = true;
        }

        return validTypes;
    };

    GMENode.prototype.getValidSetMemberTypesDetailed = function (setName) {
        var parameters = {
                node: this._state.nodes[this._id].node,
                children: [],
                sensitive: true,
                multiplicity: false,
                name: setName
            },
            fullList,
            filteredList,
            validTypes = {},
            keys = this.getChildrenIds(),
            i;

        for (i = 0; i < keys.length; i++) {
            if (this._state.nodes[keys[i]]) {
                parameters.children.push(this._state.nodes[keys[i]].node);
            }
        }

        fullList = this._state.core.getValidSetElementsMetaNodes(parameters);

        parameters.multiplicity = true;
        filteredList = this._state.core.getValidSetElementsMetaNodes(parameters);

        for (i = 0; i < fullList.length; i += 1) {
            validTypes[this._state.core.getPath(fullList[i])] = false;
        }

        for (i = 0; i < filteredList.length; i += 1) {
            validTypes[this._state.core.getPath(filteredList[i])] = true;
        }

        return validTypes;
    };

    GMENode.prototype.getMetaTypeId = GMENode.prototype.getBaseTypeId = function () {
        var metaType = this._state.core.getMetaType(this._state.nodes[this._id].node);

        if (metaType) {
            return this._storeNode(metaType);
        } else {
            return null;
        }
    };

    GMENode.prototype.isMetaNode = function () {
        return this._state.core.isMetaNode(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isTypeOf = function (typePath) {
        var typeNode = _getNode(this._state.nodes, typePath);

        if (typeNode) {
            return this._state.core.isTypeOf(this._state.nodes[this._id].node, typeNode);
        } else {
            return false;
        }
    };

    GMENode.prototype.isValidChildOf = function (parentPath) {
        var parentNode = this._state.nodes[parentPath].node;

        if (parentNode) {
            return this._state.core.isValidChildOf(this._state.nodes[this._id].node, parentNode);
        } else {
            return false;
        }
    };

    GMENode.prototype.getValidChildrenIds = function () {
        return this._state.core.getValidChildrenPaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.isValidTargetOf = function (sourcePath, name) {
        var sourceNode = _getNode(this._state.nodes, sourcePath);

        if (sourceNode) {
            return this._state.core.isValidTargetOf(this._state.nodes[this._id].node, sourceNode, name);
        } else {
            return false;
        }
    };

    GMENode.prototype.getValidAspectNames = function () {
        return this._state.core.getValidAspectNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getOwnValidAspectNames = function () {
        return this._state.core.getOwnValidAspectNames(this._state.nodes[this._id].node);
    };

    GMENode.prototype.getAspectMeta = function (name) {
        return this._state.core.getAspectMeta(this._state.nodes[this._id].node, name);
    };

    //MIXINS
    GMENode.prototype.getMixinPaths = function () {
        return this._state.core.getMixinPaths(this._state.nodes[this._id].node);
    };

    GMENode.prototype.canSetAsMixin = function (mixinPath) {
        return this._state.core.canSetAsMixin(this._state.nodes[this._id].node, mixinPath);
    };

    GMENode.prototype.isReadOnly = function () {
        return this._state.readOnlyProject || this._state.viewer || this.isLibraryRoot() || this.isLibraryElement();
    };

    //getNode
    function getNode(_id, logger, state, storeNode) {
        if (state.nodes[_id]) {
            return new GMENode(_id, logger, state, storeNode);

        } else {
            //logger.warn('Tried to get node with path "' + _id + '" but was not in state.nodes');
        }

        return null;
    }

    return getNode;
});
/*globals define, console*/
/*jshint browser: true*/
/**
 * @author kecso / https://github.com/kecso
 */
define('js/client/gmeNodeSetter',[], function () {
    'use strict';
    function gmeNodeSetter(logger, state, saveRoot, storeNode, printCoreError) {

        function _logDeprecated(oldFn, newFn, isGetter, comment) {
            var typeToUse = isGetter ? 'gmeNode.' : 'gmeClient.',
                commentStr = comment ? comment : '';

            console.warn('"gmeClient.' + oldFn + '" is deprecated and will eventually be removed, use "' +
            typeToUse + newFn + '" instead.' + commentStr);
        }

        function _getNode(path) {
            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {
                return state.nodes[path].node;
            }
        }

        function _setAttrAndRegistry(node, desc) {
            var name;
            desc = desc || {};

            if (desc.attributes) {
                for (name in desc.attributes) {
                    if (desc.attributes.hasOwnProperty(name)) {
                        state.core.setAttribute(node, name, desc.attributes[name]);
                    }
                }
            }

            if (desc.registry) {
                for (name in desc.registry) {
                    if (desc.registry.hasOwnProperty(name)) {
                        state.core.setRegistry(node, name, desc.registry[name]);
                    }
                }
            }
        }

        function _copyMultipleNodes(paths, parentNode) {
            var i,
                tempContainer,
                tempFrom,
                tempTo,
                helpArray,
                subPathArray,
                result = {},
                childrenRelIds,
                childNode,
                newNode,
                checkPaths = function () {
                    var i,
                        result = true;

                    for (i = 0; i < paths.length; i += 1) {
                        result = result && (state.nodes[paths[i]] &&
                            typeof state.nodes[paths[i]].node === 'object');
                    }

                    return result;
                };

            // In order to preserve the relationships between the copied nodes. These steps are take:
            // 1) A temporary container tempFrom is created.
            // 2) The nodes are moved to tempFrom.
            // 3) tempFrom is copied (including the children) to tempTo
            // 4) The nodes from tempFrom are moved back to their parent(s).
            // 5) The nodes from tempTo are moved to the targeted parent.
            // 6) tempFrom and tempTo are removed.

            if (parentNode && checkPaths()) {
                helpArray = {};
                subPathArray = {};

                // 0) create a container for the tempNodes to preserve the relids of the original nodes
                tempContainer = state.core.createNode({
                    parent: state.core.getRoot(parentNode),
                    base: state.core.getTypeRoot(state.nodes[paths[0]].node)
                });

                // 1) creating the 'from' object
                tempFrom = state.core.createNode({
                    parent: tempContainer
                });

                // 2) and moving every node under it
                for (i = 0; i < paths.length; i += 1) {
                    helpArray[paths[i]] = {};
                    helpArray[paths[i]].origparent = state.core.getParent(state.nodes[paths[i]].node);
                    helpArray[paths[i]].tempnode = state.core.moveNode(state.nodes[paths[i]].node, tempFrom);
                    subPathArray[state.core.getRelid(helpArray[paths[i]].tempnode)] = paths[i];
                    delete state.nodes[paths[i]];
                }

                // 3) do the copy
                tempTo = state.core.copyNode(tempFrom, tempContainer);

                // 4) moving back the temporary source
                for (i = 0; i < paths.length; i += 1) {
                    helpArray[paths[i]].node = state.core.moveNode(helpArray[paths[i]].tempnode,
                        helpArray[paths[i]].origparent);
                    storeNode(helpArray[paths[i]].node);
                }

                // 5) gathering the destination nodes and move them to targeted parent
                childrenRelIds = state.core.getChildrenRelids(tempTo);

                for (i = 0; i < childrenRelIds.length; i += 1) {
                    if (subPathArray[childrenRelIds[i]]) {
                        childNode = state.core.getChild(tempTo, childrenRelIds[i]);
                        newNode = state.core.moveNode(childNode, parentNode);
                        storeNode(newNode);
                        result[subPathArray[state.core.getRelid(childNode)]] = newNode;
                    } else {
                        state.logger.error(new Error('Unexpected error when copying nodes!'));
                    }
                }

                // 6) clean up the temporary container nodes.
                state.core.deleteNode(tempContainer);
            }

            return result;
        }

        function setAttribute(path, name, value, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.setAttribute(node, name, value);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setAttribute(' + path + ',' + name + ',' + JSON.stringify(value) + ')');
            }
        }

        function delAttribute(path, name, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.delAttribute(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delAttribute(' + path + ',' + name + ')');
            }
        }

        function setRegistry(path, name, value, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.setRegistry(node, name, value);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setRegistry(' + path + ',' + name + ',' + JSON.stringify(value) + ')');
            }
        }

        function delRegistry(path, name, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.delRegistry(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delRegistry(' + path + ',' + name + ')');
            }
        }

        function copyNode(path, parentPath, desc, msg) {
            var node = _getNode(path),
                parentNode = _getNode(parentPath),
                newNode;

            if (node && parentNode) {
                newNode = state.core.copyNode(node, parentNode);

                if (newNode instanceof Error) {
                    printCoreError(newNode);
                    return;
                }

                _setAttrAndRegistry(newNode, desc);
                storeNode(newNode);

                saveRoot(msg || 'copyNode(' + path + ', ' + parentPath + ', ' + JSON.stringify(desc) + ')');
                return state.core.getPath(newNode);
            }
        }

        function copyMoreNodes(parameters, msg) {
            var pathsToCopy = [],
                parentNode = _getNode(parameters.parentId),
                nodePath,
                newNodes;

            if (parentNode) {
                for (nodePath in parameters) {
                    if (parameters.hasOwnProperty(nodePath) && nodePath !== 'parentId') {
                        pathsToCopy.push(nodePath);
                    }
                }

                msg = msg || 'copyMoreNodes(' + JSON.stringify(pathsToCopy) + ',' + parameters.parentId + ')';

                if (pathsToCopy.length < 1) {
                    // empty on purpose
                } else if (pathsToCopy.length === 1) {
                    copyNode(pathsToCopy[0], parameters.parentId, parameters[pathsToCopy[0]], msg);
                } else {
                    newNodes = _copyMultipleNodes(pathsToCopy, parentNode);

                    if (newNodes instanceof Error) {
                        printCoreError(newNodes);
                        return;
                    }

                    for (nodePath in newNodes) {
                        if (newNodes.hasOwnProperty(nodePath) && parameters[nodePath]) {
                            _setAttrAndRegistry(newNodes[nodePath], parameters[nodePath]);
                        }
                    }

                    saveRoot(msg);
                }
            } else {
                state.logger.error('wrong parameters for copy operation - denied -');
            }
        }

        function moveMoreNodes(parameters, msg) {
            var pathsToMove = [],
                returnParams = {},
                i,
                newNode;

            for (i in parameters) {
                if (parameters.hasOwnProperty(i)) {
                    if (i !== 'parentId') {
                        pathsToMove.push(i);
                    }
                }
            }

            if (pathsToMove.length > 0 &&
                typeof parameters.parentId === 'string' &&
                state.nodes[parameters.parentId] &&
                typeof state.nodes[parameters.parentId].node === 'object') {
                for (i = 0; i < pathsToMove.length; i += 1) {
                    if (state.nodes[pathsToMove[i]] &&
                        typeof state.nodes[pathsToMove[i]].node === 'object') {

                        newNode = state.core.moveNode(state.nodes[pathsToMove[i]].node,
                            state.nodes[parameters.parentId].node);
                        returnParams[pathsToMove[i]] = state.core.getPath(newNode);
                        _setAttrAndRegistry(newNode, parameters[pathsToMove[i]]);
                        delete state.nodes[pathsToMove[i]];
                        storeNode(newNode, true);
                    }
                }
            }

            saveRoot(msg || 'moveMoreNodes(' + JSON.stringify(returnParams) + ')');
            return returnParams;
        }

        function createChildren(parameters, msg) {
            //TODO we also have to check out what is happening with the sets!!!
            var result = {},
                paths = [],
                nodes = [],
                node,
                parent = state.nodes[parameters.parentId].node,
                names, i, j, index, pointer,
                newChildren = [],
                relations = [];

            //to allow 'meaningfull' instantiation of multiple objects
            // we have to recreate the internal relations - except the base
            paths = Object.keys(parameters);
            paths.splice(paths.indexOf('parentId'), 1);
            for (i = 0; i < paths.length; i++) {
                node = state.nodes[paths[i]].node;
                nodes.push(node);
                pointer = {};
                names = state.core.getPointerNames(node);
                index = names.indexOf('base');
                if (index !== -1) {
                    names.splice(index, 1);
                }

                for (j = 0; j < names.length; j++) {
                    index = paths.indexOf(state.core.getPointerPath(node, names[j]));
                    if (index !== -1) {
                        pointer[names[j]] = index;
                    }
                }
                relations.push(pointer);
            }

            //now the instantiation
            for (i = 0; i < nodes.length; i++) {
                newChildren.push(state.core.createNode({parent: parent, base: nodes[i]}));
            }

            //now for the storage and relation setting
            for (i = 0; i < paths.length; i++) {
                _setAttrAndRegistry(newChildren[i], parameters[paths[i]]);

                //relations
                names = Object.keys(relations[i]);
                for (j = 0; j < names.length; j++) {
                    state.core.setPointer(newChildren[i], names[j], newChildren[relations[i][names[j]]]);
                }

                //store
                result[paths[i]] = storeNode(newChildren[i]);

            }

            msg = msg || 'createChildren(' + JSON.stringify(result) + ')';
            saveRoot(msg);
            return result;
        }

        function deleteNode(path, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.deleteNode(node);
                saveRoot(msg || 'deleteNode(' + path + ')');
            }
        }

        function deleteNodes(paths, msg) {
            var didDelete = false,
                i,
                node;

            for (i = 0; i < paths.length; i++) {
                node = _getNode(paths[i]);
                if (node) {
                    state.core.deleteNode(node);
                    didDelete = true;
                }
            }

            if (didDelete) {
                saveRoot(msg || 'deleteNodes(' + paths + ')');
            }
        }

        function createNode(parameters, desc, msg) {
            var parentNode = _getNode(parameters.parentId),
                baseNode = _getNode(parameters.baseId),
                newNode,
                newID;

            if (parentNode) {
                newNode = state.core.createNode({
                    parent: parentNode,
                    base: baseNode,
                    guid: parameters.guid,
                    relid: parameters.relid
                });

                if (newNode instanceof Error) {
                    printCoreError(newNode);
                    return;
                }

                // By default the position will be {100, 100}
                desc = desc || {};
                desc.registry = desc.registry || {};
                desc.registry.position = desc.registry.position || {};
                desc.registry.position.x = desc.registry.position.x || 100;
                desc.registry.position.y = desc.registry.position.y || 100;

                _setAttrAndRegistry(newNode, desc);

                storeNode(newNode);
                newID = state.core.getPath(newNode);
                saveRoot(msg || 'createNode(' + parameters.parentId + ',' + parameters.baseId + ',' + newID + ')');
            }

            return newID;
        }

        function setPointer(path, name, target, msg) {
            var node = _getNode(path),
                targetNode;

            if (node) {
                if (target === null) {
                    state.core.setPointer(node, name, target);
                } else {
                    targetNode = _getNode(target);
                    state.core.setPointer(node, name, targetNode);
                }

                saveRoot(msg || 'setPointer(' + path + ',' + name + ',' + target + ')');
            }
        }

        function delPointer(path, name, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.delPointer(node, name);
                saveRoot(msg || 'delPointer(' + path + ',' + name + ')');
            }
        }

        // Mixed argument methods - START
        function addMember(path, memberPath, setId, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path),
                memberNode = _getNode(memberPath);

            if (node && memberNode) {
                state.core.addMember(node, setId, memberNode);
                saveRoot(msg || 'addMember(' + path + ',' + memberPath + ',' + setId + ')');
            }
        }

        function removeMember(path, memberPath, setId, msg) {
            // FIXME: This will have to break due to switched arguments (sort of)
            var node = _getNode(path);

            if (node) {
                state.core.delMember(node, setId, memberPath);
                saveRoot(msg || 'removeMember(' + path + ',' + memberPath + ',' + setId + ')');
            }
        }

        function setMemberAttribute(path, memberPath, setId, name, value, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.setMemberAttribute(node, setId, memberPath, name, value);
                saveRoot(msg || 'setMemberAttribute(' + path + ',' + memberPath + ',' + setId + ',' + name +
                    ',' + value + ')');
            }
        }

        function delMemberAttribute(path, memberPath, setId, name, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.delMemberAttribute(node, setId, memberPath, name);
                saveRoot(msg || 'delMemberAttribute(' + path + ',' + memberPath + ',' + setId + ',' + name + ')');
            }
        }

        function setMemberRegistry(path, memberPath, setId, name, value, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.setMemberRegistry(node, setId, memberPath, name, value);
                saveRoot(msg || 'setMemberRegistry(' + path + ',' + memberPath + ',' + setId + ',' + name + ',' +
                    JSON.stringify(value) + ')');
            }
        }

        function delMemberRegistry(path, memberPath, setId, name, msg) {
            // FIXME: This will have to break due to switched arguments
            var node = _getNode(path);

            if (node) {
                state.core.delMemberRegistry(node, setId, memberPath, name);
                saveRoot(msg || 'delMemberRegistry(' + path + ',' + memberPath + ',' + setId + ',' + name + ')');
            }
        }
        // Mixed argument methods - END

        function setSetAttribute(path, setName, attrName, attrValue, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.setSetAttribute(node, setName, attrName, attrValue);
                saveRoot(msg || 'setSetAttribute(' + path + ',' + setName + ',' + attrName + ',' +
                    JSON.stringify(attrValue) + ')');
            }
        }

        function delSetAttribute(path, setName, attrName, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.delSetAttribute(node, setName, attrName);
                saveRoot(msg || 'delSetAttribute(' + path + ',' + setName + ',' + attrName + ')');
            }
        }

        function setSetRegistry(path, setName, regName, regValue, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.setSetRegistry(node, setName, regName, regValue);
                saveRoot(msg || 'setSetRegistry(' + path + ',' + setName + ',' + regName + ',' +
                    JSON.stringify(regValue) + ')');
            }
        }

        function delSetRegistry(path, setName, regName, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.delSetRegistry(node, setName, regName);
                saveRoot(msg || 'delSetRegistry(' + path + ',' + setName + ',' + regName + ')');
            }
        }

        function createSet(path, setId, msg) {
            var node = _getNode(path);

            if (node) {
                state.core.createSet(node, setId);
                saveRoot(msg || 'createSet(' + path + ',' + setId + ')');
            }
        }

        function delSet(path, setId, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delSet(node, setId);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delSet(' + path + ',' + setId + ')');
            }
        }

        function setBase(path, basePath, msg) {
            var node = _getNode(path),
                baseNode = _getNode(basePath),
                error;

            if (node && baseNode) {
                error = state.core.setBase(node, baseNode);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setBase(' + path + ',' + basePath + ')');
            }
        }

        function moveNode(path, parentPath, msg) {
            var node = _getNode(path),
                parentNode = _getNode(parentPath),
                error;

            if (node && parentNode) {
                error = state.core.moveNode(node, parentNode);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'moveNode(' + path + ',' + parentPath + ')');
            }
        }

        function delBase(path, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.setBase(node, null);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delBase(' + path + ')');
            }
        }

        // META functions
        function getMeta(path) {
            var node = _getNode(path),
                meta = {children: {}, attributes: {}, pointers: {}, aspects: {}};

            if (!node) {
                return null;
            }

            meta = state.core.getJsonMeta(node);

            return meta;
        }

        function setMeta(path, meta, msg) {
            var node = _getNode(path),
                otherNode,
                name,
                i,
                error;

            if (node) {
                state.core.clearMetaRules(node);

                //children
                if (meta.children && meta.children.items && meta.children.items.length > 0) {
                    error = state.core.setChildrenMetaLimits(node, meta.children.min, meta.children.max);
                    if (error instanceof Error) {
                        printCoreError(error);
                        return;
                    }

                    for (i = 0; i < meta.children.items.length; i += 1) {
                        otherNode = _getNode(meta.children.items[i]);
                        if (otherNode) {
                            error = state.core.setChildMeta(node,
                                otherNode,
                                meta.children.minItems[i],
                                meta.children.maxItems[i]);

                            if (error instanceof Error) {
                                printCoreError(error);
                                return;
                            }
                        }
                    }
                }

                //attributes
                if (meta.attributes) {
                    for (i in meta.attributes) {
                        error = state.core.setAttributeMeta(node, i, meta.attributes[i]);
                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                //pointers and sets
                if (meta.pointers) {
                    for (name in meta.pointers) {
                        if (meta.pointers[name].items && meta.pointers[name].items.length > 0) {
                            error = state.core.setPointerMetaLimits(node,
                                name,
                                meta.pointers[name].min,
                                meta.pointers[name].max);

                            if (error instanceof Error) {
                                printCoreError(error);
                                return;
                            }

                            for (i = 0; i < meta.pointers[name].items.length; i += 1) {
                                otherNode = _getNode(meta.pointers[name].items[i]);
                                if (otherNode) {
                                    error = state.core.setPointerMetaTarget(node,
                                        name,
                                        otherNode,
                                        meta.pointers[name].minItems[i],
                                        meta.pointers[name].maxItems[i]);
                                    if (error instanceof Error) {
                                        printCoreError(error);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                //aspects
                if (meta.aspects) {
                    for (name in meta.aspects) {
                        for (i = 0; i < meta.aspects[name].length; i += 1) {
                            otherNode = _getNode(meta.aspects[name][i]);
                            if (otherNode) {
                                error = state.core.setAspectMetaTarget(node, name, otherNode);
                                if (error instanceof Error) {
                                    printCoreError(error);
                                    return;
                                }
                            }
                        }
                    }
                }

                //constraints
                if (meta.constraints) {
                    for (name in meta.constraints) {
                        if (typeof meta.constraints[name] === 'object') {
                            error = state.core.setConstraint(node, name, meta.constraints[name]);
                            if (error instanceof Error) {
                                printCoreError(error);
                                return;
                            }
                        }
                    }
                }

                saveRoot(msg || 'setMeta(' + path + ')');
            }
        }

        function addMixin(path, mixinPath, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.addMixin(node, mixinPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'addMixin(' + path + ',' + mixinPath + ')');
            }
        }

        function delMixin(path, mixinPath, msg) {
            var error,
                node = _getNode(path);

            if (node) {
                error = state.core.delMixin(node, mixinPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg, 'delMixin(' + path + ',' + mixinPath + ')');
            }
        }

        function setChildrenMetaAttribute(path, attrName, value, msg) {
            if (attrName !== 'items') {
                var rawMeta = getMeta(path);
                rawMeta.children[attrName] = value;
                setMeta(path, rawMeta, msg);
            }
        }

        function setChildMeta(path, childPath, min, max, msg) {
            var node = _getNode(path),
                childNode = _getNode(childPath),
                error;

            if (childNode && node) {
                error = state.core.setChildMeta(node, childNode, min, max);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg ||'setChildMeta(' + path + ', ' + childPath + ',' + min || -1 + ',' + max || -1 +')');
            }
        }

        function setChildrenMeta(path, meta, msg) {
            var node = _getNode(path),
                target,
                error,
                i;

            if (meta && meta.items && node) {
                for (i = 0; i < meta.items.length; i += 1) {
                    target = _getNode(meta.items[i].id);
                    if (target) {
                        error = state.core.setChildMeta(node, target, meta.items[i].min, meta.items[i].max);
                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                error = state.core.setChildrenMetaLimits(node, meta.min, meta.max);

                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'Meta.setChildrenMeta(' + path + ')');
            }
        }

        function delChildMeta(path, typeId, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delChildMeta(node, typeId);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delChildMeta(' + path + ', ' + typeId + ')');
            }
        }

        function setAttributeMeta(path, name, schema, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.setAttributeMeta(node, name, schema);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setAttributeMeta(' + path + ', ' + name + ')');
            }
        }

        function delAttributeMeta(path, name, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delAttributeMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delAttributeMeta(' + path + ', ' + name + ')');
            }
        }

        function setPointerMetaTarget(path, name, targetPath, min, max, msg) {
            var node = _getNode(path),
                targetNode = _getNode(targetPath),
                error;

            if (node && targetNode) {
                error = state.core.setPointerMetaTarget(node, name, targetNode, min, max);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setPointerMetaTarget(' + path + ', ' + name + ', ' + targetPath + ',' +
                    min || -1 + ',' + max || -1 + ')');
            }
        }

        function delPointerMetaTarget(path, name, targetPath, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delPointerMetaTarget(node, name, targetPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delPointerMetaTarget(' + path + ', ' + name + ', ' + targetPath + ')');
            }
        }

        function delPointerMeta(path, name, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delPointerMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delPointerMeta(' + path + ', ' + name + ')');
            }
        }

        function setPointerMeta(path, name, meta, msg) {
            var node = _getNode(path),
                target,
                error,
                i;

            if (meta && meta.items && node) {
                for (i = 0; i < meta.items.length; i += 1) {
                    target = _getNode(meta.items[i].id);
                    if (target) {
                        error = state.core.setPointerMetaTarget(node,
                            name,
                            target,
                            meta.items[i].min,
                            meta.items[i].max);

                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                error = state.core.setPointerMetaLimits(node, name, meta.min, meta.max);

                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setPointerMeta(' + path + ', ' + name + ')');
            }
        }

        function setAspectMetaTarget(path, name, targetPath, msg) {
            var node = _getNode(path),
                targetNode = _getNode(targetPath),
                error;

            if (node && targetNode) {
                error = state.core.setAspectMetaTarget(node, name, targetNode);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'setAspectMetaTarget(' + path + ', ' + name + ',' + targetPath + ')');
            }
        }

        function delAspectMetaTarget(path, name, targetPath, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delAspectMetaTarget(node, name, targetPath);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delAspectMeta(' + path + ', ' + name + ')');
            }
        }

        function setAspectMetaTargets(path, name, targetPaths, msg) {
            var node = _getNode(path),
                i,
                target,
                error;

            if (node) {
                error = state.core.delAspectMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                for (i = 0; i < targetPaths.length; i += 1) {
                    target = _getNode(targetPaths[i]);
                    if (target) {
                        error = state.core.setAspectMetaTarget(node, name, target);
                        if (error instanceof Error) {
                            printCoreError(error);
                            return;
                        }
                    }
                }

                saveRoot(msg || 'setAspectMetaTargets(' + path + ', ' + name + ',' + JSON.stringify(targetPaths) + ')');
            }
        }

        function delAspectMeta(path, name, msg) {
            var node = _getNode(path),
                error;

            if (node) {
                error = state.core.delAspectMeta(node, name);
                if (error instanceof Error) {
                    printCoreError(error);
                    return;
                }

                saveRoot(msg || 'delAspectMeta(' + path + ', ' + name + ')');
            }
        }

        // Deprecated meta-getters from core/users/meta
        // TODO: These should be removed at next version bump.

        function isTypeOf(path, typePath) {
            var node = _getNode(path),
                typeNode = _getNode(typePath);

            if (node && typeNode) {
                return state.core.isTypeOf(node, typeNode);
            }

            return false;
        }

        function isValidTarget(path, name, targetPath) {
            var node = _getNode(path),
                target = _getNode(targetPath);

            if (node && target) {
                return state.core.isValidTargetOf(target, node, name);
            }

            return false;
        }

        function filterValidTarget(path, name, paths) {
            var targets = [];

            for (var i = 0; i < paths.length; i++) {
                if (isValidTarget(path, name, paths[i])) {
                    targets.push(paths[i]);
                }
            }

            return targets;
        }

        function getValidTargetTypes(path, name) {
            var node = _getNode(path),
                meta, i,
                targets = [];

            if (node) {
                meta = state.core.getPointerMeta(node, name);

                for (i in meta) {
                    if (i !== 'min' && i !== 'max') {
                        targets.push(i);
                    }
                }
            }

            return targets;
        }

        function getOwnValidTargetTypes(path, name) {
            var node = _getNode(path),
                ownMeta;

            if (node) {
                ownMeta = state.core.getOwnJsonMeta(node);
                ownMeta.pointers = ownMeta.pointers || {};
                ownMeta.pointers[name] = ownMeta.pointers[name] || {};

                return ownMeta.pointers[name].items || [];
            }

            return [];
        }

        function _getValidTargetItems(path, name, ownOnly) {
            var node = _getNode(path),
                meta,
                paths,
                items = [],
                i;

            if (node) {
                meta = state.core.getPointerMeta(node, name);
                paths = ownOnly ? state.core.getOwnJsonMeta(node) : state.core.getJsonMeta(node);
                if (paths && paths.pointers && paths.pointers[name]) {
                    paths = paths.pointers[name].items || [];
                } else {
                    paths = [];
                }

                if (meta && paths.length > 0) {
                    delete meta.min;
                    delete meta.max;
                    for (i in meta) {
                        if (paths.indexOf(i) !== -1) {
                            items.push({
                                id: i,
                                min: meta[i].min === -1 ? undefined : meta[i].min,
                                max: meta[i].max === -1 ? undefined : meta[i].max
                            });
                        }
                    }

                    return items;
                }
            }

            return null;
        }

        function getValidTargetItems(path, name) {
            return _getValidTargetItems(path, name, false);
        }

        function getOwnValidTargetItems(path, name) {
            return _getValidTargetItems(path, name, true);
        }

        function isValidChild(parentPath, path) {
            var node = _getNode(path),
                parentNode = _getNode(parentPath);

            if (node && parentNode) {
                return state.core.isValidChildOf(node, parentNode);
            }

            return false;
        }

        function getValidChildrenTypes(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getValidChildrenPaths(node);
            }

            return [];
        }

        function getValidAttributeNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getValidAttributeNames(node);
            }

            return [];
        }

        function getOwnValidAttributeNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getOwnValidAttributeNames(node);
            }

            return [];
        }

        function getPointerMeta(path, name) {
            var node = _getNode(path),
                meta,
                i,
                pointerMeta;

            if (node) {
                meta = state.core.getPointerMeta(node, name);

                if (meta) {
                    pointerMeta = {min: meta.min, max: meta.max, items: []};

                    for (i in meta) {
                        if (i !== 'min' && i !== 'max') {
                            pointerMeta.items.push({
                                id: i,
                                min: meta[i].min === -1 ? undefined : meta[i].min,
                                max: meta[i].max === -1 ? undefined : meta[i].max
                            });
                        }
                    }

                    return pointerMeta;
                }
            }

            return null;
        }

        function getAttributeSchema(path, name) {
            var node = _getNode(path);

            if (node) {
                return state.core.getAttributeMeta(node, name);
            }

            return;
        }

        function getMetaAspectNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getValidAspectNames(node);
            }

            return [];
        }

        function getOwnMetaAspectNames(path) {
            var node = _getNode(path);

            if (node) {
                return state.core.getOwnValidAspectNames(node);
            }

            return [];
        }

        function getMetaAspect(path, name) {
            var node = _getNode(path),
                meta;

            if (node) {
                meta = state.core.getAspectMeta(node, name);

                if (meta) {
                    return {items: meta};
                }
            }

            return null;
        }

        function hasOwnMetaRules(path) {
            var node = _getNode(path),
                ownMeta, key;

            if (node) {
                ownMeta = state.core.getOwnJsonMeta(node);

                //children
                if (ownMeta.children && ownMeta.children.items && ownMeta.children.items.length > 0) {
                    return true;
                }

                //pointers
                for (key in ownMeta.pointers || {}) {
                    return true;
                }

                //attributes
                for (key in ownMeta.attributes || {}) {
                    return true;
                }
                //aspects
                for (key in ownMeta.aspects || {}) {
                    return true;
                }

                //mixins
                if (ownMeta.mixins && ownMeta.mixins.length > 0) {
                    return true;
                }
            }

            return false;
        }

        function getChildrenMeta(path) {
            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}
            var node = _getNode(path),
                meta, i,
                childrenMeta = {items: []};

            if (node) {
                meta = state.core.getChildrenMeta(node);
                if (meta) {
                    childrenMeta = {min: meta.min, max: meta.max, items: []};
                    for (i in meta) {
                        if (i !== 'min' && i !== 'max') {
                            childrenMeta.items.push({
                                id: i,
                                min: meta[i].min === -1 ? undefined : meta[i].min,
                                max: meta[i].max === -1 ? undefined : meta[i].max
                            });
                        }
                    }
                }

                return childrenMeta;
            }

            return null;
        }

        function getChildrenMetaAttribute(path/*, attrName*/) {
            var childrenMeta = getChildrenMeta(path);
            if (childrenMeta) {
                return childrenMeta.attrName;
            }
            return null;
        }

        function getValidChildrenItems(path) {
            var childrenMeta = getChildrenMeta(path);
            if (childrenMeta) {
                return childrenMeta.items;
            }
            return null;
        }

        function getOwnValidChildrenTypes(path) {
            var node = _getNode(path),
                ownMeta;

            if (node) {
                ownMeta = state.core.getOwnJsonMeta(node);

                if (ownMeta && ownMeta.children && ownMeta.children.items) {
                    return ownMeta.children.items;
                }
            }

            return [];
        }

        function getAspectTerritoryPattern(path, name) {
            var aspect = getMetaAspect(path, name);

            if (aspect !== null) {
                aspect.children = 1; //TODO now it is fixed, maybe we can change that in the future
                return aspect;
            }
            return null;
        }

        return {
            setAttribute: setAttribute,
            setAttributes: function() {
                _logDeprecated('setAttributes', 'setAttribute');
                setAttribute.apply(null, arguments);
            },

            delAttribute: delAttribute,
            delAttributes: function() {
            _logDeprecated('delAttributes', 'delAttribute');
                delAttribute.apply(null, arguments);
            },
            setRegistry: setRegistry,
            delRegistry: delRegistry,

            copyNode: copyNode,
            copyMoreNodes: copyMoreNodes,
            moveNode: moveNode,
            moveMoreNodes: moveMoreNodes,
            deleteNode: deleteNode,
            deleteNodes: deleteNodes,
            delMoreNodes: function() {
                _logDeprecated('delMoreNodes', 'deleteNodes');
                deleteNodes.apply(null, arguments);
            },
            createNode: createNode,
            createChild: function (parameters, msg) {
                return createNode(parameters, {
                    registry: {
                        position: parameters.position
                    }
                }, msg);
            },
            createChildren: createChildren,

            setPointer: setPointer,
            makePointer: function() {
                _logDeprecated('makePointer', 'setPointer');
                setPointer.apply(null, arguments);
            },
            delPointer: delPointer,
            deletePointer: delPointer,

            addMember: addMember,
            removeMember: removeMember,
            setMemberAttribute: setMemberAttribute,
            delMemberAttribute: delMemberAttribute,
            setMemberRegistry: setMemberRegistry,
            delMemberRegistry: delMemberRegistry,
            setSetAttribute: setSetAttribute,
            delSetAttribute: delSetAttribute,
            setSetRegistry: setSetRegistry,
            delSetRegistry: delSetRegistry,
            createSet: createSet,
            delSet: delSet,
            deleteSet: delSet,

            setBase: setBase,
            delBase: delBase,

            // --- Meta ---
            setMeta: setMeta,

            // containment
            setChildrenMeta: setChildrenMeta,
            setChildrenMetaAttribute: setChildrenMetaAttribute,
            setChildMeta: setChildMeta,
            updateValidChildrenItem: function (path, newTypeObj, msg) {
                _logDeprecated('updateValidChildrenItem(path, newTypeObj, msg)',
                    'setChildMeta(path, childPath, min, max, msg)');
                newTypeObj = newTypeObj || {};
                setChildMeta(path, newTypeObj.id, newTypeObj.min, newTypeObj.max, msg);
            },

            delChildMeta: delChildMeta,
            removeValidChildrenItem: function () {
                _logDeprecated('removeValidChildrenItem', 'delChildMeta');
                delChildMeta.apply(null, arguments);
            },

            // attribute
            setAttributeMeta: setAttributeMeta,
            setAttributeSchema: function() {
                _logDeprecated('setAttributeSchema', 'setAttributeMeta');
                setAttributeMeta.apply(null, arguments);
            },
            delAttributeMeta: delAttributeMeta,
            removeAttributeSchema: function() {
                _logDeprecated('removeAttributeSchema', 'delAttributeMeta');
                delAttributeMeta.apply(null, arguments);
            },

            // pointer
            setPointerMeta: setPointerMeta,
            setPointerMetaTarget: setPointerMetaTarget,
            updateValidTargetItem: function (path, name, targetObj, msg) {
            _logDeprecated('updateValidTargetItem(path, name, targetObj, msg)',
                    'setPointerMetaTarget(path, name, targetPath, childPath, min, max, msg)');
                targetObj = targetObj || {};
                setPointerMetaTarget(path, name, targetObj.id, targetObj.min, targetObj.max, msg);
            },

            delPointerMetaTarget: delPointerMetaTarget,
            removeValidTargetItem:  function() {
                _logDeprecated('removeValidTargetItem', 'delPointerMetaTarget');
                delPointerMetaTarget.apply(null, arguments);
            },
            delPointerMeta: delPointerMeta,
            deleteMetaPointer: function() {
                _logDeprecated('deleteMetaPointer', 'delPointerMeta');
                delPointerMeta.apply(null, arguments);
            },

            // aspect
            setAspectMetaTarget: setAspectMetaTarget,
            setAspectMetaTargets: setAspectMetaTargets,
            setMetaAspect: function() {
                _logDeprecated('setMetaAspect', 'setAspectMetaTargets');
                setAspectMetaTargets.apply(null, arguments);
            },
            delAspectMetaTarget: delAspectMetaTarget,
            delAspectMeta: delAspectMeta,
            deleteMetaAspect: function() {
                _logDeprecated('deleteMetaAspect', 'delAspectMeta');
                delAspectMeta.apply(null, arguments);
            },

            // mixin
            addMixin: addMixin,
            delMixin: delMixin,

            // Deprecated meta-getters
            // TODO: These should be moved to Util/GMEConcepts or removed.
            getMeta: function() {
                _logDeprecated('getMeta(path)', 'getJsonMeta()', true);
                return getMeta.apply(null, arguments);
            },
            isTypeOf: function() {
                //_logDeprecated('isTypeOf(path, typePath)', 'isTypeOf(typePath)', true);
                return isTypeOf.apply(null, arguments);
            },
            isValidTarget: function() {
                _logDeprecated('isValidTarget(path, name, targetPath)', 'isValidTargetOf(sourcePath, name)', true);
                return isValidTarget.apply(null, arguments);
            },
            filterValidTarget: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return filterValidTarget.apply(null, arguments);
            },
            getValidTargetTypes: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getValidTargetTypes.apply(null, arguments);
            },
            getOwnValidTargetTypes: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getOwnValidTargetTypes.apply(null, arguments);
            },
            getValidTargetItems: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getValidTargetItems.apply(null, arguments);
            },
            getOwnValidTargetItems: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getOwnValidTargetItems.apply(null, arguments);
            },
            getPointerMeta: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getPointerMeta.apply(null, arguments);
            },
            isValidChild: function() {
                _logDeprecated('isValidChild(path, childPath)', 'isValidChildOf(parentPath)', true);
                return isValidChild.apply(null, arguments);
            },
            getValidChildrenTypes: function() {
                _logDeprecated('getValidChildrenTypes(path)', 'getValidChildrenIds()', true);
                return getValidChildrenTypes.apply(null, arguments);
            },
            getValidAttributeNames: function() {
                _logDeprecated('getValidAttributeNames(path)', 'getValidAttributeNames()', true);
                return getValidAttributeNames.apply(null, arguments);
            },
            getOwnValidAttributeNames: function() {
                _logDeprecated('getOwnValidAttributeNames(path)', 'getOwnValidAttributeNames()', true);
                return getOwnValidAttributeNames.apply(null, arguments);
            },
            getAttributeSchema: function() {
                _logDeprecated('getAttributeSchema(path, name)', 'getAttributeMeta(name)', true);
                return getAttributeSchema.apply(null, arguments);
            },
            getMetaAspectNames: function() {
                _logDeprecated('getMetaAspectNames(path)', 'getValidAspectNames()', true);
                return getMetaAspectNames.apply(null, arguments);
            },
            getOwnMetaAspectNames: function() {
                _logDeprecated('getOwnMetaAspectNames(path)', 'getOwnValidAspectNames()', true);
                return getOwnMetaAspectNames.apply(null, arguments);
            },
            getMetaAspect: function() {
                _logDeprecated('getMetaAspect(path, name)', 'getAspectMeta(name)', true,
                    ' Returned value is of different structure! {items: meta} vs meta');
                return getMetaAspect.apply(null, arguments);
            },
            hasOwnMetaRules: function() {
                // TODO: Should we add a method on the core??
                return hasOwnMetaRules.apply(null, arguments);
            },
            getChildrenMeta: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getChildrenMeta.apply(null, arguments);
            },
            getChildrenMetaAttribute: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getChildrenMetaAttribute.apply(null, arguments);
            },
            getValidChildrenItems: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getValidChildrenItems.apply(null, arguments);
            },
            getOwnValidChildrenTypes: function() {
                // TODO: Should we add a method on the core similar to getValidChildrenTypes?
                return getOwnValidChildrenTypes.apply(null, arguments);
            },
            getAspectTerritoryPattern: function() {
                // TODO: Should we add a method in GMEConcepts or remove this guy?
                return getAspectTerritoryPattern.apply(null, arguments);
            }
        };
    }

    return gmeNodeSetter;
});

//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

/*globals define*/
/*jshint node: true, browser: true*/

/**
 * STRING CONSTANT DEFINITIONS USED IN BOTH CLIENT AND SERVER JAVASCRIPT
 * @author rkereskenyi / https://github.com/rkereskenyi
 */

define('common/Constants',['common/core/constants'], function (CoreConstants) {
    'use strict';
    //return string constants
    return {
        /*
         * TERRITORY EVENTS
         */
        TERRITORY_EVENT_LOAD: 'load',
        TERRITORY_EVENT_UPDATE: 'update',
        TERRITORY_EVENT_UNLOAD: 'unload',
        TERRITORY_EVENT_COMPLETE: 'complete',
        TERRITORY_EVENT_INCOMPLETE: 'incomplete',

        /*
         * GME_ID: wherever a GME object ID needs to be present
         */
        GME_ID: 'GME_ID',

        /*
         * DEDICATED GME OBJECT IDs
         */
        PROJECT_ROOT_ID: '',
        PROJECT_FCO_ID: 'FCO_ID',
        PROJECT_FCO_GUID: 'cd891e7b-e2ea-e929-f6cd-9faf4f1fc045',
        PROJECT_FCO_RELID: '1',

        /*
         * DEDICATED GME ROOT properties
         */
        PROJECT_ROOT_NAME: 'ROOT',


        /*
         * Dedicated POINTER names
         */
        POINTER_SOURCE: 'src',      //dedicated connection source pointer name
        POINTER_TARGET: 'dst',      //dedicated connection target pointer name
        POINTER_BASE: 'base',       //dedicated inheritance pointer name
        POINTER_CONSTRAINED_BY: 'constrainedby', //dedicated replaceable/constrainedBy pointer name

        /*
         * Dedicated RELATION names
         */
        RELATION_CONTAINMENT: 'containment',

        CORE: CoreConstants

    };
});
/*globals define, _*/
/*jshint browser: true*/
/**
 * STRING CONSTANT DEFINITIONS USED IN CLIENT JAVASCRIPT (INHERITS ALL THE CONSTANST FROM COMMON/CONSTANST.JS)
 *
 * @author rkereskenyi / https://github.com/rkereskenyi
 */

define('js/Constants',[
    'underscore',
    'common/Constants',
    'js/client/constants'
], function (underscore, COMMON_CONSTANTS, CLIENT_CONSTANTS) {

    'use strict';

    //define client-only string constants
    var clientConstants = {};

    //copy over all the constanst form common/constants.js
    _.extend(clientConstants, COMMON_CONSTANTS, {
        /*
         * DOM element ID to use for all-over-the-screen-draggable-parent
         */
        ALL_OVER_THE_SCREEN_DRAGGABLE_PARENT_ID: 'body',

        /*
         * META-INFORMATION ABOUT THE USER ACTION
         */
        META_INFO: 'metaInfo',

        /*
         * DRAG SOURCE IDENTIFIER (Widget, panel, etc)
         */
        DRAG_SOURCE: 'dragSource',

        /*
         * LINE VISUAL DESCRIPTOR CONSTANTS
         */
        LINE_STYLE: {
            WIDTH: 'width',
            COLOR: 'color',
            PATTERN: 'pattern',
            PATTERNS: {
                SOLID: '',
                DASH: '-',
                LONGDASH: '- ',
                DOT: '.',
                DASH_DOT: '-.',
                DASH_DOT_DOT: '-..'
            },
            TYPE: 'type',
            TYPES: {
                NONE: '',
                BEZIER: 'bezier'
            },
            START_ARROW: 'start-arrow',
            END_ARROW: 'end-arrow',
            CUSTOM_POINTS: 'custom-points',
            LABEL_PLACEMENT: 'label-placement',
            LABEL_PLACEMENTS: {
                SRC: 'src',
                MIDDLE: 'mid',
                DST: 'dst'
            },
            LINE_ARROWS: {
                NONE: 'none',
                DIAMOND: 'diamond',
                BLOCK: 'block',
                CLASSIC: 'classic',
                OPEN: 'open',
                OVAL: 'oval',
                DIAMOND2: 'diamond2',
                INHERITANCE: 'inheritance'
            }
        },

        DISPLAY_FORMAT_ATTRIBUTE_MARKER: '$',

        //the path to the SVGs that can be used by the decorators supporting SVG_Icon
        ASSETS_DECORATOR_SVG_FOLDER: 'assets/DecoratorSVG/',

        /*WebGME state constants*/
        STATE_ACTIVE_OBJECT: 'activeObject',
        STATE_ACTIVE_SELECTION: 'activeSelection',
        STATE_ACTIVE_ASPECT: 'activeAspect',
        STATE_ACTIVE_VISUALIZER: 'activeVisualizer',
        STATE_ACTIVE_PROJECT_NAME: 'activeProjectName',
        STATE_ACTIVE_COMMIT: 'activeCommit',
        STATE_ACTIVE_BRANCH_NAME: 'activeBranchName',
        STATE_ACTIVE_CROSSCUT: 'activeCrosscut',
        STATE_ACTIVE_TAB: 'activeTab',
        STATE_SUPPRESS_VISUALIZER_FROM_NODE: 'suppressVisualizerFromNode',

        STATE_LAYOUT: 'layout',

        /* ASPECTS */
        ASPECT_ALL: 'All',

        /* Property groups */
        PROPERTY_GROUP_META: 'META',
        PROPERTY_GROUP_PREFERENCES: 'Preferences',
        PROPERTY_GROUP_ATTRIBUTES: 'Attributes',
        PROPERTY_GROUP_POINTERS: 'Pointers',

        /* Visualizer */
        DEFAULT_VISUALIZER: 'ModelEditor',

        // This is assigned by the VisualizerPanel onto the visualizer instance on the fly and is set to
        // the id defined in Visualizers.json.
        VISUALIZER_PANEL_IDENTIFIER: 'VISUALIZER_PANEL_IDENTIFIER'
    });

    clientConstants.CLIENT = CLIENT_CONSTANTS;

    return clientConstants;
});

/*globals define*/
/*jshint browser: true*/
/**
 * @author kecso / https://github.com/kecso
 */
define('js/client/libraries',['js/Constants'], function (CONSTANTS) {
    'use strict';
    function gmeLibraries(logger, state, storage, saveRoot) {

        function getLibraryNames() {
            if (state.core && state.nodes[CONSTANTS.PROJECT_ROOT_ID] &&
                typeof state.nodes[CONSTANTS.PROJECT_ROOT_ID].node === 'object') {
                return state.core.getLibraryNames(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node);
            }

            return [];
        }

        function getLibraryInfo(libraryName) {
            if (state.core && state.nodes[CONSTANTS.PROJECT_ROOT_ID] &&
                typeof state.nodes[CONSTANTS.PROJECT_ROOT_ID].node === 'object') {
                return state.core.getLibraryInfo(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node, libraryName) || null;
            }

            return null;
        }

        function addLibrary(name, blobHashOrLibraryInfo, callback) {
            var parameters = {
                command: 'addLibrary',
                projectId: state.project.projectId,
                libraryName: name,
                branchName: state.branchName
            };

            if (typeof blobHashOrLibraryInfo === 'string') {
                parameters.blobHash = blobHashOrLibraryInfo;
            } else {
                parameters.libraryInfo = blobHashOrLibraryInfo;
            }

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function updateLibrary(name, blobHashOrLibraryInfo, callback) {
            var parameters = {
                command: 'updateLibrary',
                projectId: state.project.projectId,
                libraryName: name,
                branchName: state.branchName
            };

            if (typeof blobHashOrLibraryInfo === 'string') {
                parameters.blobHash = blobHashOrLibraryInfo;
            } else if (blobHashOrLibraryInfo) {
                parameters.libraryInfo = blobHashOrLibraryInfo;
            }

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        }

        function removeLibrary(libraryName) {
            state.core.removeLibrary(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node, libraryName);
            saveRoot('removeLibrary(' + libraryName + ')');
        }

        function renameLibrary(oldName, newName) {
            state.core.renameLibrary(state.nodes[CONSTANTS.PROJECT_ROOT_ID].node, oldName, newName);
            saveRoot('renameLibrary(' + oldName + ',' + newName + ')');
        }

        function openLibraryOriginInNewWindow(libraryRootId, followBranch) {
            // FIXME: This does not belong here (the client knows nothing about the URL serialization..
            var address,
                info;
            if (!state.nodes[libraryRootId]) {
                logger.warn('only cached libraries can be followed!');
                return;
            }
            info = getLibraryInfo(state.core.getFullyQualifiedName(state.nodes[libraryRootId].node));

            if (!info) {
                logger.warn('the library has no valid info');
                return;
            }

            if (!info.projectId) {
                logger.warn('the library has only partial info');
                return;
            }

            address = window.location.origin + '/?project=' + encodeURIComponent(info.projectId);

            if (info.branchName && followBranch) {
                address += '&branch=' + encodeURIComponent(info.branchName);
            } else if (info.commitHash) {
                address += '&commit=' + encodeURIComponent(info.commitHash);
            }

            window.open(address, '_blank');
            window.focus();

        }

        return {
            getLibraryNames: getLibraryNames,
            addLibrary: addLibrary,
            updateLibrary: updateLibrary,
            removeLibrary: removeLibrary,
            renameLibrary: renameLibrary,
            getLibraryInfo: getLibraryInfo,
            openLibraryOriginInNewWindow: openLibraryOriginInNewWindow
        };
    }

    return gmeLibraries;
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * Client module for accessing the blob.
 *
 * @author lattmann / https://github.com/lattmann
 */

define('blob/BlobConfig',[], function () {
    'use strict';
    var BlobConfig = {
        hashMethod: 'sha1', // TODO: in the future we may switch to sha512
        hashRegex: new RegExp('^[0-9a-f]{40}$')
    };

    return BlobConfig;
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * Client module for accessing the blob.
 *
 * @author lattmann / https://github.com/lattmann
 */

define('blob/BlobMetadata',['blob/BlobConfig'], function (BlobConfig) {
    'use strict';

    /**
     * Initializes a new instance of BlobMetadata
     * @param {object} metadata - A serialized metadata object.
     * @param {string} metadata.name
     * @param {string|Object} metadata.content
     * @param {number} [metadata.size=0]
     * @param {BlobMetadata.CONTENT_TYPES} [metadata.contentType=BlobMetadata.CONTENT_TYPES.OBJECT]
     * @param {string} [metadata.mime='']
     * @param {boolean} [metadata.isPublic=false]
     * @param {string[]} [metadata.tags=[]]
     * @constructor
     * @alias BlobMetadata
     */
    var BlobMetadata = function (metadata) {
        var key;
        if (metadata) {
            this.name = metadata.name;
            this.size = metadata.size || 0;
            this.mime = metadata.mime || '';
            this.isPublic = metadata.isPublic || false;
            this.tags = metadata.tags || [];
            this.content = metadata.content;
            this.contentType = metadata.contentType || BlobMetadata.CONTENT_TYPES.OBJECT;
            if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {
                for (key in this.content) {
                    if (this.content.hasOwnProperty(key)) {
                        if (BlobConfig.hashRegex.test(this.content[key].content) === false) {
                            throw new Error('BlobMetadata is malformed: hash \'' + this.content[key].content + '\'is invalid');
                        }
                    }
                }
            }
        } else {
            throw new Error('metadata parameter is not defined');
        }
    };

    /**
     * Type of the metadata
     * @type {{OBJECT: string, COMPLEX: string, SOFT_LINK: string}}
     */
    BlobMetadata.CONTENT_TYPES = {
        OBJECT: 'object',
        COMPLEX: 'complex',
        SOFT_LINK: 'softLink'
    };

    /**
     * Serializes the metadata to a JSON object.
     * @returns {{
     *  name: string,
     *  size: number,
     *  mime: string,
     *  tags: Array.<string>,
     *  content: (string|Object),
     *  contentType: string}}
     */
    BlobMetadata.prototype.serialize = function () {
        var metadata = {
            name: this.name,
            size: this.size,
            mime: this.mime,
            isPublic: this.isPublic,
            tags: this.tags,
            content: this.content,
            contentType: this.contentType
        };

        metadata.tags.sort();

        if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {
            // override on  purpose to normalize content
            metadata.content = {};
            var fnames = Object.keys(this.content);
            fnames.sort();

            for (var j = 0; j < fnames.length; j += 1) {
                metadata.content[fnames[j]] = this.content[fnames[j]];
            }
        }

        return metadata;
    };

    return BlobMetadata;
});

/*globals define*/
/*jshint browser: true, node:true*/

/**
 * @author lattmann / https://github.com/lattmann
 */

define('blob/Artifact',[
    'blob/BlobMetadata',
    'blob/BlobConfig',
    'common/core/tasync',
    'q'
], function (BlobMetadata, BlobConfig, tasync, Q) {
    'use strict';

    /**
     * Creates a new instance of artifact, i.e. complex object, in memory. This object can be saved in the blob-storage
     * on the server and later retrieved with its metadata hash.
     * @param {string} name Artifact's name without extension
     * @param {BlobClient} blobClient
     * @param {BlobMetadata} descriptor
     * @constructor
     * @alias Artifact
     */
    var Artifact = function (name, blobClient, descriptor) {
        this.name = name;
        this.blobClient = blobClient;
        this.blobClientPutFile = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.putFile), 5));
        this.blobClientGetMetadata = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.getMetadata), 5));
        // TODO: use BlobMetadata class here
        this.descriptor = descriptor || {
                name: name + '.zip',
                size: 0,
                mime: 'application/zip',
                content: {},
                contentType: 'complex'
            }; // name and hash pairs
    };

    /**
     * Adds content to the artifact as a file.
     * @param {string} name - filename
     * @param {Blob} content - File object or Blob.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addFile = function (name, content, callback) {
        var self = this,
            filename = name.substring(name.lastIndexOf('/') + 1),
            deferred = Q.defer();

        self.blobClientPutFile.call(self.blobClient, filename, content, function (err, metadataHash) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.addObjectHash(name, metadataHash, function (err, metadataHash) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                deferred.resolve(metadataHash);
            });
        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds files as soft-link.
     * @param {string} name - filename.
     * @param {Blob} content - File object or Blob.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addFileAsSoftLink = function (name, content, callback) {
        var deferred = Q.defer(),
            self = this,
            filename = name.substring(name.lastIndexOf('/') + 1);

        self.blobClientPutFile.call(self.blobClient, filename, content,
            function (err, metadataHash) {
                if (err) {
                    deferred.reject(err);
                    return;
                }
                var size;
                if (content.size !== undefined) {
                    size = content.size;
                }
                if (content.length !== undefined) {
                    size = content.length;
                }

                self.addMetadataHash(name, metadataHash, size)
                    .then(deferred.resolve)
                    .catch(deferred.reject);
            });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds a hash to the artifact using the given file path.
     * @param {string} name - Path to the file in the artifact. Note: 'a/b/c.txt'
     * @param {string} metadataHash - Metadata hash that has to be added.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>hash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addObjectHash = function (name, metadataHash, callback) {
        var self = this,
            deferred = Q.defer();

        if (BlobConfig.hashRegex.test(metadataHash) === false) {
            deferred.reject('Blob hash is invalid');
        } else {
            self.blobClientGetMetadata.call(self.blobClient, metadataHash, function (err, metadata) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                if (self.descriptor.content.hasOwnProperty(name)) {
                    deferred.reject(new Error('Another content with the same name was already added. ' +
                        JSON.stringify(self.descriptor.content[name])));

                } else {
                    self.descriptor.size += metadata.size;

                    self.descriptor.content[name] = {
                        content: metadata.content,
                        contentType: BlobMetadata.CONTENT_TYPES.OBJECT
                    };
                    deferred.resolve(metadataHash);
                }
            });
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds a hash to the artifact using the given file path.
     * @param {string} name - Path to the file in the artifact. Note: 'a/b/c.txt'
     * @param {string} metadataHash - Metadata hash that has to be added.
     * @param {number} [size] - Size of the referenced blob.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>hash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addMetadataHash = function (name, metadataHash, size, callback) {
        var self = this,
            deferred = Q.defer(),
            addMetadata = function (size) {
                if (self.descriptor.content.hasOwnProperty(name)) {
                    deferred.reject(new Error('Another content with the same name was already added. ' +
                        JSON.stringify(self.descriptor.content[name])));

                } else {
                    self.descriptor.size += size;

                    self.descriptor.content[name] = {
                        content: metadataHash,
                        contentType: BlobMetadata.CONTENT_TYPES.SOFT_LINK
                    };
                    deferred.resolve(metadataHash);
                }
            };

        if (typeof size === 'function') {
            callback = size;
            size = undefined;
        }

        if (BlobConfig.hashRegex.test(metadataHash) === false) {
            deferred.reject(new Error('Blob hash is invalid'));
        } else if (size === undefined) {
            self.blobClientGetMetadata.call(self.blobClient, metadataHash, function (err, metadata) {
                if (err) {
                    deferred.reject(err);
                    return;
                }
                addMetadata(metadata.size);
            });
        } else {
            addMetadata(size);
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds multiple files.
     * @param {Object.<string, Blob>} files files to add
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>metadataHashes</b>.<br>
     * On error the promise will be rejected with {@link Error|string} <b>error</b>.
     */
    Artifact.prototype.addFiles = function (files, callback) {
        var self = this,
            fileNames = Object.keys(files);

        return Q.all(fileNames.map(function (fileName) {
            return self.addFile(fileName, files[fileName]);
        })).nodeify(callback);
    };

    /**
     * Adds multiple files as soft-links.
     * @param {Object.<string, Blob>} files files to add
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>metadataHashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addFilesAsSoftLinks = function (files, callback) {
        var self = this,
            fileNames = Object.keys(files);

        return Q.all(fileNames.map(function (fileName) {
            return self.addFileAsSoftLink(fileName, files[fileName]);
        })).nodeify(callback);
    };

    /**
     * Adds hashes to the artifact using the given file paths.
     * @param {object.<string, string>} metadataHashes - Keys are file paths and values metadata hashes.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>hashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addObjectHashes = function (metadataHashes, callback) {
        var self = this,
            fileNames = Object.keys(metadataHashes);

        return Q.all(fileNames.map(function (fileName) {
            return self.addObjectHash(fileName, metadataHashes[fileName]);
        })).nodeify(callback);
    };

    /**
     * Adds hashes to the artifact using the given file paths.
     * @param {object.<string, string>} metadataHashes - Keys are file paths and values metadata hashes.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string[]} <b>hashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.addMetadataHashes = function (metadataHashes, callback) {
        var self = this,
            fileNames = Object.keys(metadataHashes);

        return Q.all(fileNames.map(function (fileName) {
            return self.addMetadataHash(fileName, metadataHashes[fileName]);
        })).nodeify(callback);
    };

    /**
     * Saves this artifact and uploads the metadata to the server's storage.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    Artifact.prototype.save = function (callback) {
        var deferred = Q.defer();

        this.blobClient.putMetadata(this.descriptor, function (err, hash) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve(hash);
            }
        });

        return deferred.promise.nodeify(callback);
    };

    return Artifact;
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('superagent',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.superagent = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],2:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

exports.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
exports.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

exports.withCredentials = function(){
  // This is browser-only functionality. Node side is no-op.
  this._withCredentials = true;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

exports.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

exports.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

exports._isHost = function _isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

exports.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || this._isHost(data)) return this;

  // default to json
  if (!type) this.type('json');
  return this;
};

},{"./is-object":1}],3:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],4:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],5:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('emitter');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */),
        key = parts.shift(),
        val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this._setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this._parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype._setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype._setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (res.status < 200 || res.status >= 300) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype._timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self._timeoutError();
      if (self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  this._appendQueryString();

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":1,"./request":3,"./request-base":2,"emitter":4}]},{},[5])(5)
});
/*jshint node: true, browser: true, bitwise: false*/

/**
 * @author kecso / https://github.com/kecso
 */

define('common/util/uint',[],function () {
    'use strict';

    //this helper function is necessary as in case of large json objects,
    // the library standard function causes stack overflow
    function uint8ArrayToString(uintArray) {
        var resultString = '',
            i;
        for (i = 0; i < uintArray.byteLength; i++) {
            resultString += String.fromCharCode(uintArray[i]);
        }
        return decodeURIComponent(escape(resultString));
    }

    return {
        uint8ArrayToString: uint8ArrayToString
    };
});
/*globals define, console*/
/*jshint browser: true, node:true*/

/**
 * Client module for accessing the blob.
 *
 * @author lattmann / https://github.com/lattmann
 * @author ksmyth / https://github.com/ksmyth
 */

define('blob/BlobClient',[
    'blob/Artifact',
    'blob/BlobMetadata',
    'superagent',
    'q',
    'common/util/uint'
], function (Artifact, BlobMetadata, superagent, Q, UINT) {
    'use strict';

    /**
     * Client to interact with the blob-storage. <br>
     *
     * @param {object} parameters
     * @param {object} parameters.logger
     * @constructor
     * @alias BlobClient
     */
    var BlobClient = function (parameters) {
        var self = this;
        this.artifacts = [];
        if (parameters && parameters.logger) {
            this.logger = parameters.logger;
        } else {
            var doLog = function () {
                console.log.apply(console, arguments);
            };
            this.logger = {
                debug: doLog,
                log: doLog,
                info: doLog,
                warn: doLog,
                error: doLog
            };
            console.warn('Since v1.3.0 BlobClient requires a logger, falling back on console.log.');
        }

        if (parameters && parameters.uploadProgressHandler) {
            this.uploadProgressHandler = parameters.uploadProgressHandler;
        } else {
            this.uploadProgressHandler = function (fName, e) {
                self.logger.debug('File upload of', fName, e.percent, '%');
            };
        }

        this.logger.debug('ctor', {metadata: parameters});

        if (parameters) {
            this.server = parameters.server || this.server;
            this.serverPort = parameters.serverPort || this.serverPort;
            this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;
            this.webgmeToken = parameters.webgmeToken;
            this.keepaliveAgentOptions = parameters.keepaliveAgentOptions || {/* use defaults */};
        } else {
            this.keepaliveAgentOptions = {/* use defaults */};
        }
        this.origin = '';
        if (this.httpsecure !== undefined && this.server && this.serverPort) {
            this.origin = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;
        }
        this.relativeUrl = '/rest/blob/';
        this.blobUrl = this.origin + this.relativeUrl;
        // TODO: TOKEN???
        // TODO: any ways to ask for this or get it from the configuration?

        this.isNodeOrNodeWebKit = typeof process !== 'undefined';
        if (this.isNodeOrNodeWebKit) {
            // node or node-webkit
            this.logger.debug('Running under node or node-web-kit');
            if (this.httpsecure) {
                this.Agent = require('agentkeepalive').HttpsAgent;
            } else {
                this.Agent = require('agentkeepalive');
            }
            if (this.keepaliveAgentOptions.hasOwnProperty('ca') === false) {
                this.keepaliveAgentOptions.ca = require('https').globalAgent.options.ca;
            }
            this.keepaliveAgent = new this.Agent(this.keepaliveAgentOptions);
        }

        this.logger.debug('origin', this.origin);
        this.logger.debug('blobUrl', this.blobUrl);
    };

    BlobClient.prototype.getMetadataURL = function (hash) {
        return this.origin + this.getRelativeMetadataURL(hash);
    };

    BlobClient.prototype.getRelativeMetadataURL = function (hash) {
        var metadataBase = this.relativeUrl + 'metadata';
        if (hash) {
            return metadataBase + '/' + hash;
        } else {
            return metadataBase;
        }
    };

    BlobClient.prototype._getURL = function (base, hash, subpath) {
        var subpathURL = '';
        if (subpath) {
            subpathURL = subpath;
        }
        return this.relativeUrl + base + '/' + hash + '/' + encodeURIComponent(subpathURL);
    };

    BlobClient.prototype.getViewURL = function (hash, subpath) {
        return this.origin + this.getRelativeViewURL(hash, subpath);
    };

    BlobClient.prototype.getRelativeViewURL = function (hash, subpath) {
        return this._getURL('view', hash, subpath);
    };

    /**
     * Returns the get-url for downloading a blob.
     * @param {string} metadataHash
     * @param {string} [subpath] - optional file-like path to sub-object if complex blob
     * @return {string} get-url for blob
     */
    BlobClient.prototype.getDownloadURL = function (metadataHash, subpath) {
        return this.origin + this.getRelativeDownloadURL(metadataHash, subpath);
    };

    BlobClient.prototype.getRelativeDownloadURL = function (hash, subpath) {
        return this._getURL('download', hash, subpath);
    };

    BlobClient.prototype.getCreateURL = function (filename, isMetadata) {
        return this.origin + this.getRelativeCreateURL(filename, isMetadata);
    };

    BlobClient.prototype.getRelativeCreateURL = function (filename, isMetadata) {
        if (isMetadata) {
            return this.relativeUrl + 'createMetadata/';
        } else {
            return this.relativeUrl + 'createFile/' + encodeURIComponent(filename);
        }
    };

    /**
     * Adds a file to the blob storage.
     * @param {string} name - file name.
     * @param {string|Buffer|ArrayBuffer} data - file content.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {string} <b>metadataHash</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.putFile = function (name, data, callback) {
        var deferred = Q.defer(),
            self = this,
            contentLength,
            req;

        this.logger.debug('putFile', name);

        function toArrayBuffer(buffer) {
            var ab = new ArrayBuffer(buffer.length);
            var view = new Uint8Array(ab);
            for (var i = 0; i < buffer.length; ++i) {
                view[i] = buffer[i];
            }
            return ab;
        }

        // On node-webkit, we use XMLHttpRequest, but xhr.send thinks a Buffer is a string and encodes it in utf-8 -
        // send an ArrayBuffer instead.
        if (typeof window !== 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {
            data = toArrayBuffer(data); // FIXME will this have performance problems
        }
        // on node, empty Buffers will cause a crash in superagent
        if (typeof window === 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {
            if (data.length === 0) {
                data = '';
            }
        }
        contentLength = data.hasOwnProperty('length') ? data.length : data.byteLength;
        req = superagent.post(this.getCreateURL(name));

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
        }

        if (this.webgmeToken) {
            req.set('Authorization', 'Bearer ' + this.webgmeToken);
        }

        if (typeof data !== 'string' && !(data instanceof String) && typeof window === 'undefined') {
            req.set('Content-Length', contentLength);
        }

        req.set('Content-Type', 'application/octet-stream')
            .send(data)
            .on('progress', function (event) {
                self.uploadProgressHandler(name, event);
            })
            .end(function (err, res) {
                if (err || res.status > 399) {
                    deferred.reject(err || new Error(res.status));
                    return;
                }
                var response = res.body;
                // Get the first one
                var hash = Object.keys(response)[0];
                self.logger.debug('putFile - result', hash);
                deferred.resolve(hash);
            });

        return deferred.promise.nodeify(callback);
    };

    BlobClient.prototype.putMetadata = function (metadataDescriptor, callback) {
        var metadata = new BlobMetadata(metadataDescriptor),
            deferred = Q.defer(),
            self = this,
            blob,
            contentLength,
            req;
        // FIXME: in production mode do not indent the json file.
        this.logger.debug('putMetadata', {metadata: metadataDescriptor});
        if (typeof Blob !== 'undefined') {
            blob = new Blob([JSON.stringify(metadata.serialize(), null, 4)], {type: 'text/plain'});
            contentLength = blob.size;
        } else {
            blob = new Buffer(JSON.stringify(metadata.serialize(), null, 4), 'utf8');
            contentLength = blob.length;
        }

        req = superagent.post(this.getCreateURL(metadataDescriptor.name, true));
        if (this.webgmeToken) {
            req.set('Authorization', 'Bearer ' + this.webgmeToken);
        }

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
            req.set('Content-Length', contentLength);
        }

        req.set('Content-Type', 'application/octet-stream')
            .send(blob)
            .end(function (err, res) {
                if (err || res.status > 399) {
                    deferred.reject(err || new Error(res.status));
                    return;
                }
                // Uploaded.
                var response = JSON.parse(res.text);
                // Get the first one
                var hash = Object.keys(response)[0];
                self.logger.debug('putMetadata - result', hash);
                deferred.resolve(hash);
            });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Adds multiple files to the blob storage.
     * @param {object.<string, string|Buffer|ArrayBuffer>} o - Keys are file names and values the content.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {object} <b>fileNamesToMetadataHashes</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.putFiles = function (o, callback) {
        var self = this,
            deferred = Q.defer(),
            error,
            filenames = Object.keys(o),
            remaining = filenames.length,
            hashes = {},
            putFile;

        if (remaining === 0) {
            deferred.resolve(hashes);
        }
        putFile = function (filename, data) {
            self.putFile(filename, data, function (err, hash) {
                remaining -= 1;

                hashes[filename] = hash;

                if (err) {
                    error = err;
                    self.logger.error('putFile failed with error', {metadata: err});
                }

                if (remaining === 0) {
                    if (error) {
                        deferred.reject(error);
                    } else {
                        deferred.resolve(hashes);
                    }
                }
            });
        };

        for (var j = 0; j < filenames.length; j += 1) {
            putFile(filenames[j], o[filenames[j]]);
        }

        return deferred.promise.nodeify(callback);
    };

    BlobClient.prototype.getSubObject = function (hash, subpath, callback) {
        return this.getObject(hash, callback, subpath);
    };

    /**
     * Retrieves object from blob storage as a Buffer under node and as an ArrayBuffer in the client.
     * N.B. if the retrieved file is a json-file and running in a browser, the content will be decoded and
     * the string parsed as a JSON.
     * @param {string} metadataHash - hash of metadata for object.
     * @param {function} [callback] - if provided no promise will be returned.
     * @param {string} [subpath] - optional file-like path to sub-object if complex blob
     *
     * @return {external:Promise} On success the promise will be resolved with {Buffer|ArrayBuffer|object}
     * <b>content</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getObject = function (metadataHash, callback, subpath) {
        var deferred = Q.defer(),
            self = this;

        this.logger.debug('getObject', metadataHash, subpath);

        superagent.parse['application/zip'] = function (obj, parseCallback) {
            if (parseCallback) {
                // Running on node; this should be unreachable due to req.pipe() below
            } else {
                return obj;
            }
        };
        //superagent.parse['application/json'] = superagent.parse['application/zip'];

        var req = superagent.get(this.getViewURL(metadataHash, subpath));
        if (this.webgmeToken) {
            req.set('Authorization', 'Bearer ' + this.webgmeToken);
        }

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
        }

        if (req.pipe) {
            // running on node
            var Writable = require('stream').Writable;
            var BuffersWritable = function (options) {
                Writable.call(this, options);

                var self = this;
                self.buffers = [];
            };
            require('util').inherits(BuffersWritable, Writable);

            BuffersWritable.prototype._write = function (chunk, encoding, cb) {
                this.buffers.push(chunk);
                cb();
            };

            var buffers = new BuffersWritable();
            buffers.on('finish', function () {
                if (req.req.res.statusCode > 399) {
                    deferred.reject(new Error(req.req.res.statusCode));
                } else {
                    deferred.resolve(Buffer.concat(buffers.buffers));
                }
            });
            buffers.on('error', function (err) {
                deferred.reject(err);
            });
            req.pipe(buffers);
        } else {
            req.removeAllListeners('end');
            req.on('request', function () {
                if (typeof this.xhr !== 'undefined') {
                    this.xhr.responseType = 'arraybuffer';
                }
            });
            // req.on('error', callback);
            req.on('end', function () {
                if (req.xhr.status > 399) {
                    deferred.reject(new Error(req.xhr.status));
                } else {
                    var contentType = req.xhr.getResponseHeader('content-type');
                    var response = req.xhr.response; // response is an arraybuffer
                    if (contentType === 'application/json') {
                        response = JSON.parse(UINT.uint8ArrayToString(new Uint8Array(response)));
                    }
                    self.logger.debug('getObject - result', {metadata: response});
                    deferred.resolve(response);
                }
            });
            // TODO: Why is there an end here too? Isn't req.on('end',..) enough?
            req.end(function (err, result) {
                if (err) {
                    deferred.reject(err);
                } else {
                    self.logger.debug('getObject - result', {metadata: result});
                    deferred.resolve(result);
                }
            });
        }

        return deferred.promise.nodeify(callback);
    };

    /**
     * Retrieves object from blob storage and parses the content as a string.
     * @param {string} metadataHash - hash of metadata for object.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {string} <b>contentString</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getObjectAsString = function (metadataHash, callback) {
        var self = this;
        return self.getObject(metadataHash)
            .then(function (content) {
                if (typeof content === 'string') {
                    // This does currently not happen..
                    return content;
                } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) {
                    return UINT.uint8ArrayToString(new Uint8Array(content));
                } else if (content instanceof ArrayBuffer) {
                    return UINT.uint8ArrayToString(new Uint8Array(content));
                } else if (content !== null && typeof content === 'object') {
                    return JSON.stringify(content);
                } else {
                    throw new Error('Unknown content encountered: ' + content);
                }
            })
            .nodeify(callback);
    };

    /**
     * Retrieves object from blob storage and parses the content as a JSON. (Will resolve with error if not valid JSON.)
     * @param {string} metadataHash - hash of metadata for object.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {object} <b>contentJSON</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getObjectAsJSON = function (metadataHash, callback) {
        var self = this;
        return self.getObject(metadataHash)
            .then(function (content) {
                if (typeof content === 'string') {
                    // This does currently not happen..
                    return JSON.parse(content);
                } else if (typeof Buffer !== 'undefined' && content instanceof Buffer) {
                    return JSON.parse(UINT.uint8ArrayToString(new Uint8Array(content)));
                } else if (content instanceof ArrayBuffer) {
                    return JSON.parse(UINT.uint8ArrayToString(new Uint8Array(content)));
                } else if (content !== null && typeof content === 'object') {
                    return content;
                } else {
                    throw new Error('Unknown content encountered: ' + content);
                }
            })
            .nodeify(callback);
    };

    /**
     * Retrieves metadata from blob storage.
     * @param {string} metadataHash - hash of metadata.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise} On success the promise will be resolved with {object} <b>metadata</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getMetadata = function (metadataHash, callback) {
        var req = superagent.get(this.getMetadataURL(metadataHash)),
            deferred = Q.defer(),
            self = this;

        this.logger.debug('getMetadata', metadataHash);

        if (this.webgmeToken) {
            req.set('Authorization', 'Bearer ' + this.webgmeToken);
        }

        if (typeof window === 'undefined') {
            req.agent(this.keepaliveAgent);
        }

        req.end(function (err, res) {
            if (err || res.status > 399) {
                deferred.reject(err || new Error(res.status));
            } else {
                self.logger.debug('getMetadata', res.text);
                deferred.resolve(JSON.parse(res.text));
            }
        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Creates a new artifact and adds it to array of artifacts of the instance.
     * @param {string} name - Name of artifact
     * @return {Artifact}
     */
    BlobClient.prototype.createArtifact = function (name) {
        var artifact = new Artifact(name, this);
        this.artifacts.push(artifact);
        return artifact;
    };

    /**
     * Retrieves the {@link Artifact} from the blob storage.
     * @param {hash} metadataHash - hash associated with the artifact.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with
     * {@link Artifact} <b>artifact</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.getArtifact = function (metadataHash, callback) {
        // TODO: get info check if complex flag is set to true.
        // TODO: get info get name.
        var self = this,
            deferred = Q.defer();
        this.logger.debug('getArtifact', metadataHash);
        this.getMetadata(metadataHash, function (err, info) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('getArtifact - return', {metadata: info});
            if (info.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {
                var artifact = new Artifact(info.name, self, info);
                self.artifacts.push(artifact);
                deferred.resolve(artifact);
            } else {
                deferred.reject(new Error('not supported contentType ' + JSON.stringify(info, null, 4)));
            }

        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Saves all the artifacts associated with the current instance.
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with
     * {string[]} <b>artifactHashes</b> (metadataHashes).<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    BlobClient.prototype.saveAllArtifacts = function (callback) {
        var promises = [];

        for (var i = 0; i < this.artifacts.length; i += 1) {
            promises.push(this.artifacts[i].save());
        }

        return Q.all(promises).nodeify(callback);
    };

    /**
     * Converts bytes to a human readable string.
     * @param {number} - File size in bytes.
     * @param {boolean} [si] - If true decimal conversion will be used (by default binary is used).
     * @returns {string}
     */
    BlobClient.prototype.getHumanSize = function (bytes, si) {
        var thresh = si ? 1000 : 1024,
            units = si ?
                ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'] :
                ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'],
            u = -1;

        if (bytes < thresh) {
            return bytes + ' B';
        }

        do {
            bytes = bytes / thresh;
            u += 1;
        } while (bytes >= thresh);

        return bytes.toFixed(1) + ' ' + units[u];
    };

    return BlobClient;
});

/*globals define*/
/*jshint node: true, browser: true, bitwise: false*/

/**
 * @author kecso / https://github.com/kecso
 */
define('js/Utils/SaveToDisk',['blob/BlobClient'], function (BlobClient) {
    'use strict';

    function saveUrlToDisk(fileURL, fileName) {
        // for non-IE
        if (!window.ActiveXObject) {
            var save = document.createElement('a'),
                event = document.createEvent('Event');

            save.href = fileURL;
            save.target = '_self';

            if (fileName) {
                save.download = fileName;
            }

            event.initEvent('click', true, true);
            save.dispatchEvent(event);
            (window.URL || window.webkitURL).revokeObjectURL(save.href);
        }

        // for IE
        else if (!!window.ActiveXObject && document.execCommand) {
            var _window = window.open(fileURL, '_self');
            _window.document.close();
            _window.document.execCommand('SaveAs', true, fileName || fileURL);
            _window.close();
        }
    }

    function downloadTextAsFile(filename, text) {
        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
    }

    function saveJsonToBlobStorage(fileName, data, logger, callback) {
        var bc = new BlobClient({logger: logger}),
            artifact = bc.createArtifact('uploaded');

        artifact.addFile(fileName, JSON.stringify(data, null, 4), function (err, fileHash) {
            callback(err, bc.getDownloadURL(fileHash));
        });
    }

    function saveJsonToDisk(fileName, data, logger, callback) {
        saveJsonToBlobStorage(fileName, data, logger, function (err, downloadUrl) {
            if (err) {
                return callback(err);
            }

            saveUrlToDisk(downloadUrl, fileName);
            callback(null, downloadUrl);
        });
    }

    return {
        saveToBlobStorage: saveJsonToBlobStorage,
        saveUrlToDisk: saveUrlToDisk,
        saveJsonToDisk: saveJsonToDisk,
        downloadTextAsFile: downloadTextAsFile
    };
});
/*globals define*/
/*jshint browser: true*/
/**
 * Contains helper functions for logging/downloading the state of the client.
 *
 * @author pmeijer / https://github.com/pmeijer
 */

define('js/client/stateloghelpers',[
    'js/Utils/SaveToDisk'
], function (saveToDisk) {
    'use strict';

    function _stateLogReplacer(key, value) {
        var chainItem,
            prevChain,
            nextChain,
            chain;
        if (key === 'project') {
            if (value) {
                return value.name;
            } else {
                return null;
            }

        } else if (key === 'core') {
            if (value) {
                return 'instantiated';
            } else {
                return 'notInstantiated';
            }
        } else if (key === 'metaNodes') {
            return Object.keys(value);
        } else if (key === 'nodes') {
            return Object.keys(value);
        } else if (key === 'loadNodes') {
            return Object.keys(value);
        } else if (key === 'users') {
            return Object.keys(value);
        } else if (key === 'rootObject') {
            return;
        } else if (key === 'undoRedoChain') {
            if (value) {
                chain = {
                    previous: null,
                    next: null
                };
                if (value.previous) {
                    prevChain = {};
                    chain.previous = prevChain;
                }
                chainItem = value;
                while (chainItem.previous) {
                    prevChain.previous = {
                        commitHash: chainItem.commitHash,
                        previous: null
                    };
                    prevChain = prevChain.previous;
                    chainItem = chainItem.previous;
                }
                if (value.next) {
                    nextChain = {};
                    chain.next = nextChain;
                }
                chainItem = value;
                while (chainItem.next) {
                    nextChain.next = {
                        commitHash: chainItem.commitHash,
                        next: null
                    };
                    nextChain = nextChain.next;
                    chainItem = chainItem.next;
                }
                return chain;
            }
        }

        return value;
    }

    function getStateLogString(client, state, doFullState, indent) {
        indent = indent || 0;
        if (doFullState === true) {
            return JSON.stringify(state, _stateLogReplacer, indent);
        } else {
            return JSON.stringify({
                connection: client.getNetworkStatus(),
                projectId: client.getActiveProjectId(),
                branchName: client.getActiveBranchName(),
                branchStatus: client.getBranchStatus(),
                commitHash: client.getActiveCommitHash(),
                rootHash: client.getActiveRootHash(),
                projectReadOnly: client.isProjectReadOnly(),
                commitReadOnly: client.isCommitReadOnly()
            }, null, indent);
        }
    }

    function downloadStateDump(client, state) {
        var errData = {
                timestamp: (new Date()).toISOString(),
                webgme: {
                    NpmVersion: 'n/a',
                    version: 'n/a',
                    GitHubVersion: 'n/a'
                },
                gmeConfig: client.gmeConfig,
                uiState: null,
                branchErrors: [],
                browserInfo: {
                    appCodeName: window.navigator.appCodeName,
                    appName: window.navigator.appName,
                    appVersion: window.navigator.appVersion,
                    onLine: window.navigator.onLine,
                    cookieEnabled: window.navigator.cookieEnabled,
                    platform: window.navigator.platform,
                    product: window.navigator.product,
                    userAgent: window.navigator.userAgent
                },
                clientState: JSON.parse(getStateLogString(client, state, true))
            };

        if (typeof WebGMEGlobal !== 'undefined') {
            /* jshint -W117 */
            errData.webgme.NpmVersion = WebGMEGlobal.NpmVersion;
            errData.webgme.GitHubVersion = WebGMEGlobal.GitHubVersion;
            errData.webgme.version = WebGMEGlobal.version;
            /* jshint +W117 */
        }

        if (typeof client.uiStateGetter === 'function') {
            errData.uiState = client.uiStateGetter();
        } else {
            errData.uiState = 'Client did not have an attached uiStateGetter.';
        }

        if (state.project && state.branchName && state.project.branches[state.branchName]) {
            state.project.branches[state.branchName].errorList.forEach(function (err) {
                errData.branchErrors.push({
                    message: err.message,
                    stack: err.stack});
            });
        }

        saveToDisk.downloadTextAsFile('webgme-client-dump.json', JSON.stringify(errData, null, 2));
    }

    function downloadCommitQueue(client, commitQueue) {
        var backupData = {
                webgmeVersion: client.getConnectedStorageVersion(),
                projectId: client.getActiveProjectId(),
                branchName: client.getActiveBranchName(),
                branchStatus: client.getBranchStatus(),
                commitQueue: commitQueue
            };

        saveToDisk.downloadTextAsFile('commit-queue-dump.json', JSON.stringify(backupData, null, 2));
    }

    return {
        downloadStateDump: downloadStateDump,
        getStateLogString: getStateLogString,
        downloadCommitQueue: downloadCommitQueue
    };
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * A module representing a PluginNodeDescription.
 *
 * @author lattmann / https://github.com/lattmann
 */


define('plugin/PluginNodeDescription',[], function () {
    'use strict';
    /**
     * Initializes a new instance of plugin node description object.
     *
     * Note: this object is JSON serializable see serialize method.
     *
     * @param config - deserializes an existing configuration to this object.
     * @constructor
     * @alias PluginNodeDescription
     */
    var PluginNodeDescription = function (config) {
        var keys,
            i;

        this.name = '';
        this.id = '';

        if (config) {
            keys = Object.keys(config);
            for (i = 0; i < keys.length; i += 1) {
                this[keys[i]] = config[keys[i]];
            }
        }
    };

    /**
     * Serializes this object to a JSON representation.
     *
     * @returns {{}}
     */
    PluginNodeDescription.prototype.serialize = function () {
        var keys = Object.keys(this),
            result = {},
            i;

        for (i = 0; i < keys.length; i += 1) {
            result[keys[i]] = this[keys[i]];
        }

        return result;
    };

    return PluginNodeDescription;
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * A module representing a PluginMessage.
 *
 * @author lattmann / https://github.com/lattmann
 */


define('plugin/PluginMessage',['plugin/PluginNodeDescription'], function (PluginNodeDescription) {
    'use strict';

    /**
     * Initializes a new instance of plugin message.
     *
     * Note: this object is JSON serializable see serialize method.
     *
     * @param {object} config - deserializes an existing configuration to this object.
     * @constructor
     * @alias PluginMessage
     */
    var PluginMessage = function (config) {
        if (config) {
            this.commitHash = config.commitHash;
            if (config.activeNode instanceof PluginNodeDescription) {
                this.activeNode = config.activeNode;
            } else {
                this.activeNode = new PluginNodeDescription(config.activeNode);
            }

            this.message = config.message;
            if (config.severity) {
                this.severity = config.severity;
            } else {
                this.severity = 'info';
            }
        } else {
            this.commitHash = '';
            this.activeNode = new PluginNodeDescription();
            this.message = '';
            this.severity = 'info';
        }
    };

    /**
     * Serializes this object to a JSON representation.
     *
     * @returns {object}
     */
    PluginMessage.prototype.serialize = function () {
        var result = {
            commitHash: this.commitHash,
            activeNode: this.activeNode.serialize(),
            message: this.message,
            severity: this.severity
        };

        return result;
    };

    return PluginMessage;
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * A module representing a PluginResult.
 *
 * @author lattmann / https://github.com/lattmann
 */

define('plugin/PluginResult',['plugin/PluginMessage'], function (PluginMessage) {
    'use strict';
    /**
     * Initializes a new instance of a plugin result object.
     *
     * Note: this object is JSON serializable see serialize method.
     *
     * @param config - deserializes an existing configuration to this object.
     * @constructor
     * @alias PluginResult
     */
    var PluginResult = function (config) {
        var pluginMessage,
            i;
        if (config) {
            this.success = config.success;
            this.pluginName = config.pluginName;
            this.startTime = config.startTime;
            this.finishTime = config.finishTime;
            this.messages = [];
            this.artifacts = config.artifacts;
            this.error = config.error;
            this.commits = config.commits;
            this.projectId = config.projectId;

            for (i = 0; i < config.messages.length; i += 1) {
                if (config.messages[i] instanceof PluginMessage) {
                    pluginMessage = config.messages[i];
                } else {
                    pluginMessage = new PluginMessage(config.messages[i]);
                }
                this.messages.push(pluginMessage);
            }
        } else {
            this.success = false;
            this.messages = []; // array of PluginMessages
            this.artifacts = []; // array of hashes
            this.pluginName = 'PluginName N/A';
            this.startTime = null;
            this.finishTime = null;
            this.error = null;
            this.projectId = null;
            this.commits = [];
        }
    };

    /**
     * Gets the success flag of this result object
     *
     * @returns {boolean}
     */
    PluginResult.prototype.getSuccess = function () {
        return this.success;
    };

    /**
     * Sets the success flag of this result.
     *
     * @param {boolean} value
     */
    PluginResult.prototype.setSuccess = function (value) {
        this.success = value;
    };

    /**
     * Returns with the plugin messages.
     *
     * @returns {PluginMessage[]}
     */
    PluginResult.prototype.getMessages = function () {
        return this.messages;
    };

    /**
     * Adds a new plugin message to the messages list.
     *
     * @param {PluginMessage} pluginMessage
     */
    PluginResult.prototype.addMessage = function (pluginMessage) {
        this.messages.push(pluginMessage);
    };

    PluginResult.prototype.getArtifacts = function () {
        return this.artifacts;
    };

    /**
     * Adds a saved artifact to the result - linked via its hash.
     *
     * @param {string} hash - Hash of saved artifact.
     */
    PluginResult.prototype.addArtifact = function (hash) {
        this.artifacts.push(hash);
    };

    /**
     *
     * @param {object} commitData
     * @param {string} commitData.commitHash - hash of the commit.
     * @param {string} commitData.status - storage.constants./SYNCED/FORKED/MERGED
     * @param {string} commitData.branchName - name of branch that got updated with the commitHash.
     */
    PluginResult.prototype.addCommit = function (commitData) {
        this.commits.push(commitData);
    };

    /**
     * Gets the name of the plugin to which the result object belongs to.
     *
     * @returns {string}
     */
    PluginResult.prototype.getPluginName = function () {
        return this.pluginName;
    };

    //------------------------------------------------------------------------------------------------------------------
    //--------------- Methods used by the plugin manager

    /**
     * Sets the name of the plugin to which the result object belongs to.
     *
     * @param {string} pluginName - name of the plugin
     */
    PluginResult.prototype.setPluginName = function (pluginName) {
        this.pluginName = pluginName;
    };

    /**
     * Sets the name of the projectId the result was generated from.
     *
     * @param {string} projectId - id of the project
     */
    PluginResult.prototype.setProjectId = function (projectId) {
        this.projectId = projectId;
    };

    /**
     * Gets the ISO 8601 representation of the time when the plugin started its execution.
     *
     * @returns {string}
     */
    PluginResult.prototype.getStartTime = function () {
        return this.startTime;
    };

    /**
     * Sets the ISO 8601 representation of the time when the plugin started its execution.
     *
     * @param {string} time
     */
    PluginResult.prototype.setStartTime = function (time) {
        this.startTime = time;
    };

    /**
     * Gets the ISO 8601 representation of the time when the plugin finished its execution.
     *
     * @returns {string}
     */
    PluginResult.prototype.getFinishTime = function () {
        return this.finishTime;
    };

    /**
     * Sets the ISO 8601 representation of the time when the plugin finished its execution.
     *
     * @param {string} time
     */
    PluginResult.prototype.setFinishTime = function (time) {
        this.finishTime = time;
    };

    /**
     * Gets error if any error occured during execution.
     * FIXME: should this be an Error object?
     * @returns {string}
     */
    PluginResult.prototype.getError = function () {
        return this.error;
    };

    /**
     * Sets the error string if any error occured during execution.
     * FIXME: should this be an Error object?
     * @param {string} time
     */
    PluginResult.prototype.setError = function (error) {
        if (error instanceof Error) {
            this.error = error.message;
        } else {
            this.error = error;
        }
    };

    /**
     * Serializes this object to a JSON representation.
     *
     * @returns {{success: boolean, messages: plugin.PluginMessage[], pluginName: string, finishTime: stirng}}
     */
    PluginResult.prototype.serialize = function () {
        var result = {
            success: this.success,
            projectId: this.projectId,
            messages: [],
            commits: this.commits,
            artifacts: this.artifacts,
            pluginName: this.pluginName,
            startTime: this.startTime,
            finishTime: this.finishTime,
            error: this.error
        },
            i;

        for (i = 0; i < this.messages.length; i += 1) {
            result.messages.push(this.messages[i].serialize());
        }

        return result;
    };

    return PluginResult;
});
/*globals define*/
/*jshint node:true, browser: true*/
/**
 * Helper functions used by plugins and plugin-managers.
 * @author pmeijer / https://github.com/pmeijer
 */

define('plugin/util',['q'], function (Q) {
    'use strict';

    /**
     *
     * @param {object} project
     * @param {object} core
     * @param {string} commitHash
     * @param {GmeLogger} logger
     * @param {object} options
     * @param {string} [options.activeNode=''] - path to active node
     * @param {string[]} [options.activeSelection=[]] - paths to selected nodes.
     * @param {string} [options.namespace=''] - used namespace during execution ('' represents all namespaces).
     * @param callback
     * @returns {*}
     */
    function loadNodesAtCommitHash(project, core, commitHash, logger, options, callback) {
        var result = {
            commitHash: commitHash,
            rootHash: null,
            rootNode: null,
            activeNode: null,
            activeSelection: null,
            META: {}
        };

        return Q.ninvoke(project, 'loadObject', commitHash)
            .then(function (commitObject) {
                result.rootHash = commitObject.root;
                logger.debug('commitObject loaded');

                // Load root node.
                return core.loadRoot(result.rootHash);
            })
            .then(function (rootNode) {
                result.rootNode = rootNode;
                logger.debug('rootNode loaded');

                // Load active node.
                return core.loadByPath(result.rootNode, options.activeNode || '');
            })
            .then(function (activeNode) {
                result.activeNode = activeNode;
                logger.debug('activeNode loaded');

                // Load active selection.
                options.activeSelection = options.activeSelection || [];

                return Q.all(options.activeSelection.map(function (nodePath) {
                    return core.loadByPath(result.rootNode, nodePath);
                }));
            })
            .then(function (activeSelection) {
                var paths2MetaNodes = core.getAllMetaNodes(result.rootNode),
                    libraryNames = core.getLibraryNames(result.rootNode),
                    metaNodeName,
                    nodeNamespace,
                    fullName,
                    path;

                result.activeSelection = activeSelection;
                logger.debug('activeSelection loaded');

                // Gather the META nodes and "sort" based on given namespace.
                function startsWith(str, pattern) {
                    return str.indexOf(pattern) === 0;
                }

                if (options.namespace) {
                    if (libraryNames.indexOf(options.namespace) === -1) {
                        throw new Error('Given namespace does not exist among the available: "' +
                            libraryNames + '".');
                    }

                    for (path in paths2MetaNodes) {
                        nodeNamespace = core.getNamespace(paths2MetaNodes[path]);
                        metaNodeName = core.getAttribute(paths2MetaNodes[path], 'name');

                        if (startsWith(nodeNamespace, options.namespace)) {
                            // Trim the based on the chosen namespace (+1 is to remove any dot).
                            nodeNamespace = nodeNamespace.substring(options.namespace.length + 1);
                            if (nodeNamespace) {
                                result.META[nodeNamespace + '.' + metaNodeName] = paths2MetaNodes[path];
                            } else {
                                result.META[metaNodeName] = paths2MetaNodes[path];
                            }
                        } else {
                            // Meta node is not within the given namespace and will not be added to META.
                        }
                    }
                } else {
                    for (path in paths2MetaNodes) {
                        fullName = core.getFullyQualifiedName(paths2MetaNodes[path]);
                        if (result.META[fullName]) {
                            logger.error('Meta-nodes share the same full name. Will still proceed..', fullName);
                        }

                        result.META[fullName] = paths2MetaNodes[path];
                    }
                }

                return result;
            })
            .nodeify(callback);
    }

    return {
        loadNodesAtCommitHash: loadNodesAtCommitHash
    };
});
/*globals requirejs, define*/
/*jshint node:true, newcap:false, browser: true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('plugin/managerbase',[
    'common/core/coreQ',
    'plugin/PluginResult',
    'plugin/PluginMessage',
    'plugin/util',
    'common/storage/project/interface',
    'common/storage/util',
    'q',
], function (Core,
             PluginResult,
             PluginMessage,
             pluginUtil,
             ProjectInterface,
             storageUtil,
             Q) {

    'use strict';

    /**
     *
     * @param blobClient
     * @param [project]
     * @param mainLogger
     * @param gmeConfig
     * @constructor
     */
    function PluginManagerBase(blobClient, project, mainLogger, gmeConfig) {
        var self = this;

        this.logger = mainLogger.fork('PluginManagerBase');
        this.notificationHandlers = [];

        /**
         * These are used to determine if the user is allowed to execute a plugin based on
         * the project access level. It also determines if the user is allowed to modify certain config
         * parameters of the plugin.
         * N.B. When reading or writing to the project from the plugin the access level is always checked
         * by the storage.
         * @type {{read: boolean, write: boolean, delete: boolean}}
         */
        this.projectAccess = {
            read: true,
            write: true,
            delete: true
        };

        /**
         *
         */
        this.blobClient = blobClient;

        /**
         *
         * @param {string} pluginId
         * @param {object} pluginConfig - configuration for the plugin.
         * @param {object} context
         * @param {string} [context.branchName] - name of branch that should be updated
         * @param {string} [context.commitHash=<%brashHash%>] - commit from which to start the plugin.
         * @param {ProjectInterface} [context.project=project] - project instance if different from the one passed in.
         * @param {string} [context.activeNode=''] - path to active node
         * @param {string[]} [context.activeSelection=[]] - paths to selected nodes.
         * @param {string} [context.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {function} callback
         */
        this.executePlugin = function (pluginId, pluginConfig, context, callback) {
            var plugin;
            self.initializePlugin(pluginId)
                .then(function (plugin_) {
                    plugin = plugin_;
                    return self.configurePlugin(plugin, pluginConfig, context);
                })
                .then(function () {
                    self.runPluginMain(plugin, callback);
                })
                .catch(function (err) {
                    var pluginResult = self.getPluginErrorResult(pluginId, 'Exception was raised, err: ' + err.stack,
                        plugin && plugin.projectId);
                    self.logger.error(err.stack);
                    callback(err.message, pluginResult);
                });
        };

        /**
         * Retrieves plugin script files and creates instance.
         * @param {string} - pluginId
         * @param {function} callback
         * @returns {promise}
         */
        this.initializePlugin = function (pluginId, callback) {
            return getPlugin(pluginId)
                .then(function (PluginClass) {
                    var pluginLogger = self.logger.fork('plugin:' + pluginId),
                        plugin;

                    plugin = new PluginClass();
                    plugin.initialize(pluginLogger, self.blobClient, gmeConfig);

                    return plugin;
                })
                .nodeify(callback);
        };

        /**
         *
         * @param {object} plugin
         * @param {object} pluginConfig - configuration for the plugin.
         * @param {object} context
         * @param {string} context.branchName - name of branch that should be updated
         * @param {string} [context.commitHash=<%brashHash%>] - commit from which to start the plugin.
         * @param {ProjectInterface} [context.project=project] - project instance if different from the one passed in.
         * @param {string} [context.activeNode=''] - path to active node
         * @param {string[]} [context.activeSelection=[]] - paths to selected nodes.
         * @param {string} [context.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {function} callback
         * @returns {promise}
         */
        this.configurePlugin = function (plugin, pluginConfig, context, callback) {
            var deferred = Q.defer(),
                self = this,
                defaultConfig = plugin.getDefaultConfig(),
                writeAccessKeys = {},
                readOnlyKeys = {},
                faultyKeys = [],
                key;

            context.project = context.project || project;

            if (context.project instanceof ProjectInterface === false) {
                deferred.reject(new Error('project is not an instance of ProjectInterface, ' +
                    'pass it via context or set it in the constructor of PluginManagerBase.'));
            } else if (plugin.pluginMetadata.writeAccessRequired === true && self.projectAccess.write === false) {
                deferred.reject(new Error('Plugin requires write access to the project for execution!'));
            } else {
                plugin.pluginMetadata.configStructure.forEach(function (configStructure) {
                    if (configStructure.writeAccessRequired === true && self.projectAccess.write === false) {
                        writeAccessKeys[configStructure.name] = true;
                    }
                    if (configStructure.readOnly === true) {
                        readOnlyKeys[configStructure.name] = true;
                    }
                });

                pluginConfig = pluginConfig || {};

                for (key in pluginConfig) {

                    if (readOnlyKeys[key] || writeAccessKeys[key]) {
                        // Parameter is not allowed to be modified, check if it was.
                        if (pluginConfig.hasOwnProperty(key) &&
                            pluginConfig[key] !== defaultConfig[key]) {
                            faultyKeys.push(key);
                        }
                    }

                    // We do allow extra config-parameters that aren't specified in the default config.
                    defaultConfig[key] = pluginConfig[key];
                }

                if (faultyKeys.length > 0) {
                    deferred.reject(new Error('User not allowed to modify configuration parameter(s): "' +
                        faultyKeys + '".'));
                } else {

                    plugin.setCurrentConfig(defaultConfig);

                    self.loadContext(context)
                        .then(function (pluginContext) {
                            plugin.configure(pluginContext);
                            deferred.resolve();
                        })
                        .catch(deferred.reject);
                }
            }

            return deferred.promise.nodeify(callback);
        };

        /**
         *
         * @param plugin
         * @param callback
         */
        this.runPluginMain = function (plugin, callback) {
            var startTime = (new Date()).toISOString(),
                mainCallbackCalls = 0,
                multiCallbackHandled = false;

            self.logger.debug('plugin configured, invoking main');

            if (plugin.isConfigured === false) {
                callback('Plugin is not configured.', self.getPluginErrorResult(plugin.getName(),
                    'Plugin is not configured.', project && project.projectId));
                return;
            }

            plugin.notificationHandlers = self.notificationHandlers;

            plugin.main(function (err, result) {
                var stackTrace;
                if (result) {
                    self.logger.debug('plugin main callback called', {result: result.serialize()});
                }
                mainCallbackCalls += 1;
                // set common information (meta info) about the plugin and measured execution times
                result.setFinishTime((new Date()).toISOString());
                result.setStartTime(startTime);

                result.setPluginName(plugin.getName());

                if (mainCallbackCalls > 1) {
                    stackTrace = new Error().stack;
                    self.logger.error('The main callback is being called more than once!', {metadata: stackTrace});
                    result.setError('The main callback is being called more than once!');
                    if (multiCallbackHandled === true) {
                        plugin.createMessage(null, stackTrace);
                        return;
                    }
                    multiCallbackHandled = true;
                    result.setSuccess(false);
                    plugin.createMessage(null, 'The main callback is being called more than once.');
                    plugin.createMessage(null, stackTrace);
                    callback('The main callback is being called more than once!', result);
                } else {
                    result.setError(err);
                    plugin.notificationHandlers = [];
                    callback(err, result);
                }
            });
        };

        function getPlugin(pluginId, callback) {
            var deferred = Q.defer(),
                rejected = false,
                pluginPath = 'plugin/' + pluginId + '/' + pluginId + '/' + pluginId;

            if (self.serverSide && !gmeConfig.plugin.allowServerExecution) {
                deferred.reject(new Error('Plugin execution on server side is disabled from gmeConfig.'));
                rejected = true;
            } else if (self.browserSide && !gmeConfig.plugin.allowBrowserExecution) {
                deferred.reject(new Error('Plugin execution in browser is disabled from gmeConfig.'));
                rejected = true;
            } else {
                self.logger.debug('Running as CLI - does not respect gmeConfig.plugin.allowServerExecution..');
            }

            if (rejected === false) {
                requirejs([pluginPath],
                    function (PluginClass) {
                        self.logger.debug('requirejs plugin from path: ' + pluginPath);
                        deferred.resolve(PluginClass);
                    },
                    function (err) {
                        deferred.reject(err);
                    }
                );
            }

            return deferred.promise.nodeify(callback);
        }

        this.getPluginErrorResult = function (pluginName, message, projectId) {
            var pluginResult = new PluginResult(),
                pluginMessage = new PluginMessage();
            pluginMessage.severity = 'error';
            pluginMessage.message = message;
            pluginResult.setSuccess(false);
            pluginResult.setPluginName(pluginName);
            pluginResult.setProjectId(projectId || 'N/A');
            pluginResult.addMessage(pluginMessage);
            pluginResult.setStartTime((new Date()).toISOString());
            pluginResult.setFinishTime((new Date()).toISOString());
            pluginResult.setError(pluginMessage.message);

            return pluginResult;
        };

        function getBranchHash(project, branchName) {
            if (branchName) {
                return project.getBranchHash(branchName);
            } else {
                return Q(null);
            }
        }

        /**
         *
         * @param {object} context
         * @param {object} context.project - project form where to load the context.
         * @param {string} [context.branchName] - name of branch that should be updated
         * @param {string} [context.commitHash=<%branchHash%>] - commit from which to start the plugin.
         * @param {string} [context.activeNode=''] - path to active node
         * @param {string[]} [context.activeSelection=[]] - paths to selected nodes.
         * @param {string} [context.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {object} pluginLogger - logger for the plugin.
         */
        this.loadContext = function (context) {
            var deferred = Q.defer(),
                pluginContext = {
                    branchName: context.branchName,
                    commitHash: context.commitHash || context.commit,

                    rootNode: null,
                    activeNode: null,
                    activeSelection: null,
                    META: {},
                    namespace: context.namespace || '',

                    project: context.project,
                    projectId: context.project.projectId,
                    projectName: storageUtil.getProjectNameFromProjectId(context.project.projectId),
                    core: new Core(context.project, {
                        globConf: gmeConfig,
                        logger: self.logger.fork('core')
                    })
                };

            self.logger.debug('loading context');
            getBranchHash(pluginContext.project, pluginContext.branchName)
                .then(function (branchHash) {
                    pluginContext.commitHash = context.commitHash || branchHash;
                    if (!pluginContext.commitHash) {
                        throw new Error('Neither commitHash nor branchHash from branch was obtained, branchName: [' +
                            context.branchName + ']');
                    }

                    return pluginUtil.loadNodesAtCommitHash(
                        pluginContext.project,
                        pluginContext.core,
                        pluginContext.commitHash,
                        self.logger,
                        context);
                })
                .then(function (result) {
                    pluginContext.rootNode = result.rootNode;
                    pluginContext.activeNode = result.activeNode;
                    pluginContext.activeSelection = result.activeSelection;
                    pluginContext.META = result.META;

                    deferred.resolve(pluginContext);
                })
                .catch(function (err) {
                    deferred.reject(err);
                });

            return deferred.promise;
        };
    }

    return PluginManagerBase;
});
/*globals define*/
/*jshint browser: true*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */


define('js/client/pluginmanager',[
    'plugin/managerbase',
    'blob/BlobClient',
    'common/storage/project/project',
    'js/RegistryKeys'
], function (PluginManagerBase, BlobClient, Project, REG_KEYS) {
    'use strict';

    var ROOT_PATH = '';

    /**
     *
     * @param client
     * @param storage
     * @param state
     * @param mainLogger
     * @param gmeConfig
     * @constructor
     */
    function PluginManager(client, storage, state, mainLogger, gmeConfig) {

        var self = this,
            logger = mainLogger.fork('PluginManager');

        this.getCurrentPluginContext = function (pluginId, activeNodeId) {
            var activeNode,
                validPlugins,
                context =  {
                managerConfig: {
                    project: client.getProjectObject(),
                    branchName: client.getActiveBranchName(),
                    commitHash: client.getActiveCommitHash(),
                    activeNode: ROOT_PATH,
                    activeSelection: [],
                    namespace: ''
                },
                pluginConfig: null
            };

            // If executed from the Generic UI we can access the active- and selected-nodes.
            if (typeof WebGMEGlobal !== 'undefined') {
                /* jshint -W117 */
                activeNodeId = typeof activeNodeId === 'string' ? activeNodeId : WebGMEGlobal.State.getActiveObject();
                context.managerConfig.activeSelection = WebGMEGlobal.State.getActiveSelection();
                context.managerConfig.activeNode = activeNodeId;
                /* jshint +W117 */
            }

            // Given the active-node we infer the namespace (user may still select another one).
            if (activeNodeId && pluginId) {
                activeNode = client.getNode(activeNodeId);
                do {
                    validPlugins = activeNode.getOwnRegistry(REG_KEYS.VALID_PLUGINS);
                    if (validPlugins && validPlugins.indexOf(pluginId) > -1) {
                        // The plugin was defined at this particular node, we use the namespace of it.
                        context.managerConfig.namespace = activeNode.getNamespace();
                        break;
                    }

                    activeNode = activeNode.getBaseId() ? client.getNode(activeNode.getBaseId()) : null;
                } while (activeNode);
            }

            return context;
        };

        /**
         * Run the plugin in the browser.
         * @param {string} pluginId - id of plugin.
         * @param {object} context
         * @param {object} context.managerConfig - where the plugin should execute.
         * @param {Project} context.managerConfig.project - project (e.g. client.getProjectObject()).
         * @param {string} [context.managerConfig.activeNode=''] - path to activeNode.
         * @param {string} [context.managerConfig.activeSelection=[]] - paths to selected nodes.
         * @param {string} context.managerConfig.commitHash - commit hash to start the plugin from.
         * @param {string} [context.managerConfig.branchName] - branch which to save to.
         * @param {string} [context.managerConfig.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {object} [context.pluginConfig=%defaultForPlugin%] - specific configuration for the plugin.
         * @param {function(err, PluginResult)} callback
         */
        this.runBrowserPlugin = function (pluginId, context, callback) {
            var blobClient = new BlobClient({logger: logger.fork('BlobClient')}),
                pluginManager = new PluginManagerBase(blobClient, null, mainLogger, gmeConfig);

            pluginManager.browserSide = true;

            pluginManager.notificationHandlers = [function (data, callback) {
                self.dispatchPluginNotification(data);
                callback(null);
            }];

            pluginManager.projectAccess = client.getProjectAccess();

            pluginManager.executePlugin(pluginId, context.pluginConfig, context.managerConfig, callback);
        };

        /**
         * Run the plugin on the server inside a worker process.
         * @param {string} pluginId - id of plugin.
         * @param {object} context
         * @param {object} context.managerConfig - where the plugin should execute.
         * @param {Project|string} context.managerConfig.project - id of project.
         * @param {string} [context.managerConfig.activeNode=''] - path to activeNode.
         * @param {string} [context.managerConfig.activeSelection=[]] - paths to selected nodes.
         * @param {string} context.managerConfig.commitHash - commit hash to start the plugin from.
         * @param {string} [context.managerConfig.branchName] - branch which to save to.
         * @param {string} [context.managerConfig.namespace=''] - used namespace during execution ('' represents all namespaces).
         * @param {object} [context.pluginConfig=%defaultForPlugin%] - specific configuration for the plugin.
         * @param {function} callback
         */
        this.runServerPlugin = function (pluginId, context, callback) {

            if (context.managerConfig.project instanceof Project) {
                context.managerConfig.project = context.managerConfig.project.projectId;
            }

            storage.simpleRequest({command: 'executePlugin', name: pluginId, context: context}, callback);
        };

        /**
         * @param {string[]} pluginIds - All available plugins on the server.
         * @param {string} [nodePath=''] - Node to get the validPlugins from.
         * @returns {string[]} - Filtered plugin ids.
         */
        this.filterPlugins = function (pluginIds, nodePath) {
            var filteredIds = [],
                validPlugins,
                i,
                node;

            logger.debug('filterPluginsBasedOnNode allPlugins, given nodePath', pluginIds, nodePath);
            if (!nodePath) {
                logger.debug('filterPluginsBasedOnNode nodePath not given - will fall back on root-node.');
                nodePath = ROOT_PATH;
            }

            node = state.nodes[nodePath];

            if (!node) {
                logger.warn('filterPluginsBasedOnNode node not loaded - will fall back on root-node.', nodePath);
                nodePath = ROOT_PATH;
                node = state.nodes[nodePath];
            }

            if (!node) {
                logger.warn('filterPluginsBasedOnNode root node not loaded - will return full list.');
                return pluginIds;
            }

            validPlugins = (state.core.getRegistry(node.node, 'validPlugins') || '').split(' ');
            for (i = 0; i < validPlugins.length; i += 1) {
                if (pluginIds.indexOf(validPlugins[i]) > -1) {
                    filteredIds.push(validPlugins[i]);
                } else if (validPlugins[i] === '') {
                    // Skip empty strings..
                } else {
                    logger.warn('Registered plugin for node at path "' + nodePath +
                        '" is not amongst available plugins', pluginIds);
                }
            }

            return filteredIds;
        };

        this.dispatchPluginNotification = function (data) {
            var notification = {
                severity: data.notification.severity || 'info',
                message: '[Plugin] ' + data.pluginName + ' - ' + data.notification.message
            };

            if (typeof data.notification.progress === 'number') {
                notification.message += ' [' + data.notification.progress + '%]';
            }

            logger.debug('plugin notification', data);
            client.dispatchEvent(client.CONSTANTS.NOTIFICATION, notification);
            client.dispatchEvent(client.CONSTANTS.PLUGIN_NOTIFICATION, data);
        };
    }

    return PluginManager;

});
/*globals define, console*/
/*jshint browser: true*/
/**
 * @author kecso / https://github.com/kecso
 * @author pmeijer / https://github.com/pmeijer
 */
define('client/js/client',[
    'js/logger',
    'common/storage/browserstorage',
    'common/EventDispatcher',
    'common/core/coreQ',
    'js/client/constants',
    'common/util/assert',
    'common/core/tasync',
    'common/util/guid',
    'common/util/url',
    'js/client/gmeNodeGetter',
    'js/client/gmeNodeSetter',
    'js/client/libraries',
    'blob/BlobClient',
    'js/client/stateloghelpers',
    'js/client/pluginmanager',
    'superagent'
], function (Logger,
             Storage,
             EventDispatcher,
             Core,
             CONSTANTS,
             ASSERT,
             TASYNC,
             GUID,
             URL,
             getNode,
             getNodeSetters,
             getLibraryFunctions,
             BlobClient,
             stateLogHelpers,
             PluginManager,
             superagent) {
    'use strict';

    function Client(gmeConfig) {
        var self = this,
            logger = Logger.create('gme:client', gmeConfig.client.log),
            storage = Storage.getStorage(logger, gmeConfig, true),
            state = {
                connection: null, // CONSTANTS.STORAGE. CONNECTED/DISCONNECTED/RECONNECTED/INCOMPATIBLE_CONNECTION/CONNECTION_ERROR
                renewingToken: false,
                exception: null,
                project: null,
                projectAccess: null,
                core: null,
                branchName: null,
                branchStatus: null, //CONSTANTS.BRANCH_STATUS. SYNC/AHEAD_SYNC/AHEAD_FORKED/PULLING/ERROR or null
                readOnlyProject: false,
                viewer: false, // This means that a specific commit is selected w/o regards to any branch.

                users: {},
                nodes: {},
                loadNodes: {},

                rootHash: null,
                rootObject: null,
                commitHash: null,

                undoRedoChain: null, //{commitHash: '#hash', rootHash: '#hash', previous: object, next: object}

                inTransaction: false,
                msg: '',
                gHash: 0,
                loadError: null,
                ongoingTerritoryUpdateCounter: 0,
                ongoingLoadPatternsCounter: 0,
                pendingTerritoryUpdatePatterns: {},
                loadingStatus: null,
                inLoading: false,
                loading: {
                    rootHash: null,
                    commitHash: null,
                    changedNodes: null,
                    next: null
                }

            },
            blobClient,
            monkeyPatchKey,
            pluginManager,
            nodeSetterFunctions,
            coreLibraryFunctions,
            ROOT_PATH = '',
            //addOnFunctions = new AddOn(state, storage, logger, gmeConfig),
            loadPatternThrottled = TASYNC.throttle(loadPattern, 1); //magic number could be fine-tuned
        //loadPatternThrottled = loadPattern; //magic number could be fine-tuned

        blobClient = new BlobClient({logger: logger.fork('BlobClient')});
        EventDispatcher.call(this);

        this.CONSTANTS = CONSTANTS;

        function logState(level, msg) {
            var indent = gmeConfig.debug ? 2 : 0;

            if (level === 'console') {
                console.log('state at ' + msg,
                    stateLogHelpers.getStateLogString(self, state, gmeConfig.debug, indent));
            } else {
                logger[level]('state at ' + msg,
                    stateLogHelpers.getStateLogString(self, state, gmeConfig.debug, indent));
            }
        }

        function renewTokenCookie(callback) {
            callback = callback || function (err, res) {
                    state.renewingToken = false;
                    if (err) {
                        logger.error('Failed to renew token cookie', err);
                    } else {
                        logger.debug('Token cookie renewed');
                    }
                };

            if (state.renewingToken === false) {
                state.renewingToken = true;
                (new superagent.Request('GET', 'api/user/token'))
                    .end(callback);
            } else {
                logger.debug('Awaiting token renewal..');
            }
        }

        // Forwarded functions
        function saveRoot(msg, callback) {
            var persisted,
                numberOfPersistedObjects,
                wrappedCallback,
                newCommitObject;

            logger.debug('saveRoot msg', msg);
            if (callback) {
                wrappedCallback = function (err, result) {
                    if (err) {
                        logger.error('saveRoot failure', err);
                    } else {
                        logger.debug('saveRoot', result);
                    }
                    callback(err, result);
                };
            } else {
                wrappedCallback = function (err, result) {
                    if (err) {
                        logger.error('saveRoot failure', err);
                    } else {
                        logger.debug('saveRoot', result);
                    }
                };
            }

            if (!state.viewer && !state.readOnlyProject) {
                if (state.msg) {
                    state.msg += '\n' + msg;
                } else {
                    state.msg += msg;
                }
                if (!state.inTransaction) {
                    ASSERT(state.project && state.core && state.branchName);

                    logger.debug('is NOT in transaction - will persist.');
                    persisted = state.core.persist(state.nodes[ROOT_PATH].node);
                    logger.debug('persisted', persisted);
                    numberOfPersistedObjects = Object.keys(persisted.objects).length;
                    if (numberOfPersistedObjects === 0) {
                        logger.warn('No changes after persist will return from saveRoot.');
                        wrappedCallback(null);
                        return;
                    } else if (numberOfPersistedObjects > 200) {
                        //This is just for debugging
                        logger.warn('Lots of persisted objects', numberOfPersistedObjects);
                    }

                    // Make the commit on the storage (will emit hashUpdated)
                    newCommitObject = storage.makeCommit(
                        state.project.projectId,
                        state.branchName,
                        [state.commitHash],
                        persisted.rootHash,
                        persisted.objects,
                        state.msg,
                        wrappedCallback
                    );

                    state.msg = '';
                } else {
                    logger.debug('is in transaction - will NOT persist.');
                }
            } else {
                //TODO: Why is this set to empty here?
                state.msg = '';
                wrappedCallback(null);
            }
        }

        function storeNode(node /*, basic */) {
            var path;
            //basic = basic || true;
            if (node) {
                path = state.core.getPath(node);
                //state.metaNodes[path] = node;
                if (state.nodes[path]) {
                    //TODO we try to avoid this
                } else {
                    state.nodes[path] = {
                        node: node
                    };
                    //TODO this only needed when real eventing will be reintroduced
                    //_inheritanceHash[path] = getInheritanceChain(node);
                }
                return path;
            }
            return null;
        }

        // Plugin Manager
        pluginManager = new PluginManager(self, storage, state, logger, gmeConfig);
        this.getCurrentPluginContext = pluginManager.getCurrentPluginContext;
        this.runBrowserPlugin = pluginManager.runBrowserPlugin;
        this.runServerPlugin = pluginManager.runServerPlugin;
        this.filterPlugins = pluginManager.filterPlugins;
        this.dispatchPluginNotification = pluginManager.dispatchPluginNotification;

        function checkMetaNameCollision(core, rootNode) {
            var names = [],
                nodes = core.getAllMetaNodes(rootNode),
                i,
                keys = Object.keys(nodes || {}),
                name;
            for (i = 0; i < keys.length; i += 1) {
                //name = core.getAttribute(nodes[keys[i]], 'name');
                name = core.getFullyQualifiedName(nodes[keys[i]]);
                if (names.indexOf(name) === -1) {
                    names.push(name);
                } else {
                    self.dispatchEvent(CONSTANTS.NOTIFICATION, {
                        type: 'META',
                        severity: 'error',
                        message: 'Duplicate name on META level: \'' + name + '\'',
                        hint: 'Rename one of the objects'
                    });
                }
            }

        }

        function checkMixinErrors(core, rootNode) {
            var metaNodes = core.getAllMetaNodes(rootNode),
                i, key,
                notifications = {},
                notificationKeys = [],
                errors;

            for (key in metaNodes) {
                errors = core.getMixinErrors(metaNodes[key]);

                for (i = 0; i < errors.length; i += 1) {
                    notifications[errors[i].message] = {
                        type: 'META',
                        severity: errors[i].severity,
                        message: errors[i].message,
                        hint: errors[i].hint
                    };
                    notificationKeys.push(errors[i].message);
                }
            }

            //now sort simply by the messages
            notificationKeys.sort();
            for (i = 0; i < notificationKeys.length; i += 1) {
                self.dispatchEvent(CONSTANTS.NOTIFICATION, notifications[notificationKeys[i]]);
            }
        }

        function printCoreError(error) {
            logger.error('Faulty core usage raised an error', error);
            self.dispatchEvent(CONSTANTS.NOTIFICATION, {
                type: 'CORE',
                severity: 'error',
                message: error.message
            });
        }

        // Node setters and getters.

        nodeSetterFunctions = getNodeSetters(logger, state, saveRoot, storeNode, printCoreError);

        for (monkeyPatchKey in nodeSetterFunctions) {
            if (nodeSetterFunctions.hasOwnProperty(monkeyPatchKey)) {
                self[monkeyPatchKey] = nodeSetterFunctions[monkeyPatchKey];
            }
        }

        coreLibraryFunctions = getLibraryFunctions(logger, state, storage, saveRoot);

        for (monkeyPatchKey in coreLibraryFunctions) {
            if (coreLibraryFunctions.hasOwnProperty(monkeyPatchKey)) {
                self[monkeyPatchKey] = coreLibraryFunctions[monkeyPatchKey];
            }
        }

        // Main API functions (with helpers) for connecting, selecting project and branches etc.
        this.connectToDatabase = function (callback) {
            if (self.isConnected()) {
                logger.warn('connectToDatabase - already connected');
                callback(null);
                return;
            }
            storage.open(function (connectionState) {
                state.connection = connectionState;
                if (connectionState === CONSTANTS.STORAGE.CONNECTED) {
                    //N.B. this event will only be triggered once.
                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                    storage.webSocket.addEventListener(CONSTANTS.STORAGE.NOTIFICATION,
                        function (emitter, eventData) {
                            logger.info('recieved notification', eventData);
                            if (eventData.type === CONSTANTS.STORAGE.BRANCH_ROOM_SOCKETS) {
                                self.dispatchConnectedUsersChanged(eventData);
                                // If a new socket joined our branch -> emit to the branch room letting
                                // any newly connected users know that we are in this branch too.
                                // If a socket with the same userId as us disconnected -> emit to
                                // make sure we're not deleted from the other users.
                                self.emitStateNotification();

                            } else if (eventData.type === CONSTANTS.STORAGE.PLUGIN_NOTIFICATION) {
                                self.dispatchPluginNotification(eventData);
                            } else if (eventData.type === CONSTANTS.STORAGE.ADD_ON_NOTIFICATION) {
                                self.dispatchAddOnNotification(eventData);
                            } else if (eventData.type === CONSTANTS.STORAGE.CLIENT_STATE_NOTIFICATION) {
                                self.dispatchConnectedUsersChanged(eventData);
                            } else {
                                logger.error('Unknown notification type', eventData.type, eventData);
                            }
                        }
                    );
                    reLaunchUsers();
                    callback(null);
                } else if (connectionState === CONSTANTS.STORAGE.DISCONNECTED) {
                    if (state.connection !== CONSTANTS.STORAGE.INCOMPATIBLE_CONNECTION) {
                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                    }
                } else if (connectionState === CONSTANTS.STORAGE.RECONNECTED) {
                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                } else if (connectionState === CONSTANTS.STORAGE.INCOMPATIBLE_CONNECTION) {
                    self.disconnectFromDatabase(function (err) {
                        if (err) {
                            logger.error(err);
                        }

                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);
                    });
                } else if (connectionState === CONSTANTS.STORAGE.JWT_ABOUT_TO_EXPIRE) {
                    logger.warn('Token about is about to expire');
                    renewTokenCookie();
                } else if (connectionState === CONSTANTS.STORAGE.JWT_EXPIRED) {
                    self.disconnectFromDatabase(function (err) {
                        if (err) {
                            logger.error(err);
                        }

                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, CONSTANTS.STORAGE.JWT_EXPIRED);
                    });
                } else {
                    logger.error(new Error('Connection failed error ' + connectionState));
                    self.disconnectFromDatabase(function (err) {
                        if (err) {
                            logger.error(err);
                        }

                        self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, CONSTANTS.STORAGE.CONNECTION_ERROR);
                        callback(new Error('Connection failed! ' + connectionState));
                    });
                }
            });
        };

        this.disconnectFromDatabase = function (callback) {

            function closeStorage(err) {
                storage.close(function (err2) {
                    if (state.connection !== CONSTANTS.STORAGE.INCOMPATIBLE_CONNECTION &&
                        state.connection !== CONSTANTS.STORAGE.CONNECTION_ERROR) {
                        state.connection = CONSTANTS.STORAGE.DISCONNECTED;
                    }

                    callback(err || err2);
                });
            }

            if (state.project) {
                closeProject(state.project.projectId, closeStorage);
            } else {
                closeStorage(null);
            }
        };

        /**
         * If branchName is given and it does not exist, the project will be closed and callback resolved with an error.
         * If branchName NOT given it will attempt the following in order and break if successful at any step:
         *  1) Select the master if available.
         *  2) Select any available branch.
         *  3) Select the latest commit.
         *  4) Close the project and resolve with error.
         * @param {string} projectId
         * @param {string} [branchName='master']
         * @param {function} callback
         */
        this.selectProject = function (projectId, branchName, callback) {
            if (callback === undefined && typeof branchName === 'function') {
                callback = branchName;
                branchName = undefined;
            }
            if (self.isConnected() === false) {
                callback(new Error('There is no open database connection!'));
            }
            var prevProjectId,
                branchToOpen = branchName || 'master';

            logger.debug('selectProject', projectId, branchToOpen);

            function projectOpened(err, project, branches, access) {
                if (err) {
                    callback(new Error(err));
                    return;
                }
                state.project = project;
                state.readOnlyProject = access.write === false;
                state.core = new Core(project, {
                    globConf: gmeConfig,
                    logger: logger.fork('core')
                });
                state.projectAccess = access;

                logState('info', 'projectOpened');
                logger.debug('projectOpened, branches: ', branches);
                self.dispatchEvent(CONSTANTS.PROJECT_OPENED, projectId);

                if (branches.hasOwnProperty(branchToOpen) === false) {
                    if (branchName) {
                        logger.error('Given branch does not exist "' + branchName + '"');
                        closeProject(projectId, function (err) {
                            if (err) {
                                logger.error('closeProject after missing branch failed with err', err);
                            }
                            callback(new Error('Given branch does not exist "' + branchName + '"'));
                        });
                        return;
                    }
                    logger.warn('Project "' + projectId + '" did not have branch', branchToOpen);
                    branchToOpen = Object.keys(branches)[0] || null;
                    logger.debug('Picked "' + branchToOpen + '".');
                }

                if (branchToOpen) {
                    self.selectBranch(branchToOpen, null, function (err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        logState('info', 'selectBranch');
                        reLaunchUsers();
                        callback(null);
                    });
                } else {
                    logger.warn('No branches available in project, will attempt to select latest commit.');
                    self.getCommits(projectId, (new Date()).getTime(), 1, function (err, commitObjects) {
                        if (err || commitObjects.length === 0) {
                            logger.error(err);
                            closeProject(projectId, function (err) {
                                if (err) {
                                    logger.error('closeProject after missing any commits failed with err', err);
                                }
                                callback(new Error('Project does not have any commits.'));
                            });
                            return;
                        }
                        self.selectCommit(commitObjects[0]._id, function (err) {
                            if (err) {
                                logger.error(err);
                                closeProject(projectId, function (err) {
                                    if (err) {
                                        logger.error('closeProject after missing any commits failed with err', err);
                                    }
                                    callback(new Error('Failed selecting commit when opening project.'));
                                });
                                return;
                            }
                            reLaunchUsers();
                            callback(null);
                        });
                    });
                }
            }

            if (state.project) {
                prevProjectId = state.project.projectId;
                logger.debug('A project was open, closing it', prevProjectId);

                if (prevProjectId === projectId) {
                    logger.warn('projectId is already opened', projectId);
                    callback(null);
                    return;
                }
                closeProject(prevProjectId, function (err) {
                    if (err) {
                        logger.error('problems closing previous project', err);
                        callback(err);
                        return;
                    }
                    storage.openProject(projectId, projectOpened);
                });
            } else {
                storage.openProject(projectId, projectOpened);
            }
        };

        function closeProject(projectId, callback) {

            state.project = null;
            //TODO what if for some reason we are in transaction?
            storage.closeProject(projectId, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                state.core = null;
                state.branchName = null;
                //self.dispatchEvent(null);
                state.patterns = {};
                //state.gHash = 0;
                state.nodes = {};
                state.loadNodes = {};
                state.loadError = 0;
                state.rootHash = null;
                //state.rootObject = null;
                state.inTransaction = false;
                state.msg = '';

                cleanUsersTerritories();
                self.dispatchEvent(CONSTANTS.PROJECT_CLOSED, projectId);

                callback(null);
            });
        }

        /**
         *
         * @param {string} branchName - name of branch to open.
         * @param {function} [branchStatusHandler=getDefaultCommitHandler()] - Handles returned statuses after commits.
         * @param callback
         */
        this.selectBranch = function (branchName, branchStatusHandler, callback) {
            var prevBranchName = state.branchName;
            logger.debug('selectBranch', branchName);
            if (self.isConnected() === false) {
                callback(new Error('There is no open database connection!'));
                return;
            }
            if (!state.project) {
                callback(new Error('selectBranch invoked without an opened project'));
                return;
            }

            if (branchStatusHandler) {
                logger.warn('passing branchStatusHandler is deprecated, use addHashUpdateHandler or' +
                    ' addBranchStatusHandler on the branch object instead (getProjectObject().branches[branchName]).');
            }

            function openBranch(err) {
                if (err) {
                    logger.error('Problems closing existing branch', err);
                    callback(err);
                    return;
                }

                state.branchName = branchName;
                logger.debug('openBranch, calling storage openBranch', state.project.projectId, branchName);
                storage.openBranch(state.project.projectId, branchName,
                    getHashUpdateHandler(), getBranchStatusHandler(),
                    function (err /*, latestCommit*/) {
                        if (err) {
                            logger.error('storage.openBranch returned with error', err);
                            self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                            callback(err);
                            return;
                        }

                        state.viewer = false;
                        state.branchName = branchName;
                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, branchName);
                        logState('info', 'openBranch');
                        callback(null);
                    }
                );
            }

            if (prevBranchName !== null) {
                logger.debug('Branch was open, closing it first', prevBranchName);
                storage.closeBranch(state.project.projectId, prevBranchName, openBranch);
            } else {
                openBranch(null);
            }
        };

        this.selectCommit = function (commitHash, callback) {
            logger.debug('selectCommit', commitHash);
            if (self.isConnected() === false) {
                callback(new Error('There is no open database connection!'));
                return;
            }
            if (!state.project) {
                callback(new Error('selectCommit invoked without open project'));
                return;
            }
            var prevBranchName;

            function openCommit(err) {
                if (err) {
                    logger.error('Problems closing existing branch', err);
                    callback(err);
                    return;
                }

                state.viewer = true;

                state.project.loadObject(commitHash, function (err, commitObj) {
                    if (!err && commitObj) {
                        logState('info', 'selectCommit loaded commit');
                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                        loading(commitObj.root, commitHash, null, function (err, aborted) {
                            if (err) {
                                logger.error('loading returned error', commitObj.root, err);
                                logState('error', 'selectCommit loading');
                                callback(err);
                            } else if (aborted === true) {
                                logState('warn', 'selectCommit loading');
                                callback(new Error('Loading selected commit was aborted'));
                            } else {
                                logger.debug('loading complete for selectCommit rootHash', commitObj.root);
                                logState('info', 'selectCommit loading');
                                self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);
                                callback(null);
                            }
                        });
                    } else {
                        logger.error('Cannot view given ' + commitHash + ' commit as it\'s root cannot be loaded! [' +
                            JSON.stringify(err) + ']');
                        callback(err || new Error('commit object cannot be found!'));
                    }
                });
            }

            if (state.branchName !== null) {
                logger.debug('Branch was open, closing it first', state.branchName);
                prevBranchName = state.branchName;
                state.branchName = null;
                storage.closeBranch(state.project.projectId, prevBranchName, openCommit);
            } else {
                openCommit(null);
            }
        };

        function getBranchStatusHandler() {
            return function (branchStatus, commitQueue, updateQueue) {
                logger.debug('branchStatus changed', branchStatus, commitQueue, updateQueue);
                logState('debug', 'branchStatus');
                state.branchStatus = branchStatus;
                self.dispatchEvent(CONSTANTS.BRANCH_STATUS_CHANGED, {
                        status: branchStatus,
                        commitQueue: commitQueue,
                        updateQueue: updateQueue
                    }
                );
            };
        }

        function getHashUpdateHandler() {
            return function (data, commitQueue, updateQueue, callback) {
                var commitData = data.commitData,
                    clearUndoRedo = data.local !== true,
                    commitHash = commitData.commitObject[CONSTANTS.STORAGE.MONGO_ID];
                logger.debug('hashUpdateHandler invoked. project, branch, commitHash',
                    commitData.projectId, commitData.branchName, commitHash);

                if (state.inTransaction) {
                    logger.warn('Is in transaction, will not load in changes');
                    callback(null, false); // proceed: false
                    return;
                }

                //undo-redo
                addModification(commitData.commitObject, clearUndoRedo);
                self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());
                self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());

                logger.debug('loading commitHash, local?', commitHash, data.local);
                loading(commitData.commitObject.root, commitHash, commitData.changedNodes, function (err, aborted) {
                    if (err) {
                        logger.error('hashUpdateHandler invoked loading and it returned error',
                            commitData.commitObject.root, err);
                        logState('error', 'hashUpdateHandler');
                        callback(err, false); // proceed: false
                    } else if (aborted === true) {
                        logState('warn', 'hashUpdateHandler');
                        callback(null, false); // proceed: false
                    } else {
                        logger.debug('loading complete for incoming rootHash', commitData.commitObject.root);
                        logState('debug', 'hashUpdateHandler');
                        callback(null, true); // proceed: true
                    }
                });
            };
        }

        this.forkCurrentBranch = function (newName, commitHash, callback) {
            var self = this,
                activeBranchName = self.getActiveBranchName(),
                activeProjectId = self.getActiveProjectId(),
                forkName;

            logger.debug('forkCurrentBranch', newName, commitHash);
            if (!state.project) {
                callback('Cannot fork without an open project!');
                return;
            }
            if (activeBranchName === null) {
                callback('Cannot fork without an open branch!');
                return;
            }
            forkName = newName || activeBranchName + '_' + (new Date()).getTime();
            storage.forkBranch(activeProjectId, activeBranchName, forkName, commitHash,
                function (err, forkHash) {
                    if (err) {
                        logger.error('Could not fork branch:', newName, err);
                        callback(err);
                        return;
                    }
                    callback(null, forkName, forkHash);
                }
            );
        };

        // State getters.
        this.isConnected = function () {
            return state.connection === CONSTANTS.STORAGE.CONNECTED ||
                state.connection === CONSTANTS.STORAGE.RECONNECTED;
        };

        this.getNetworkStatus = function () {
            return state.connection;
        };

        this.getConnectedStorageVersion = function () {
            // This is the version of the server the storage is currently connected to.
            return storage.serverVersion;
        };

        this.getBranchStatus = function () {
            return state.branchStatus;
        };

        this.getActiveProjectId = function () {
            return state.project && state.project.projectId;
        };

        this.getActiveProjectName = function () {
            return state.project && state.project.projectName;
        };

        this.getActiveBranchName = function () {
            return state.branchName;
        };

        this.getActiveCommitHash = function () {
            return state.commitHash;
        };

        this.getActiveRootHash = function () {
            return state.rootHash;
        };

        this.isProjectReadOnly = function () {
            return state.readOnlyProject;
        };

        this.isCommitReadOnly = function () {
            // This means that a specific commit is selected w/o regards to any branch.
            return state.viewer;
        };

        this.isReadOnly = function () {
            return state.viewer || state.readOnlyProject;
        };

        this.getProjectObject = function () {
            return state.project;
        };

        this.getCommitQueue = function () {
            if (state.project && state.branchName && state.project.branches.hasOwnProperty(state.branchName)) {
                return state.project.branches[state.branchName].getCommitQueue();
            }

            return [];
        };

        this.downloadCommitQueue = function () {
            var commitQueue = self.getCommitQueue();

            if (commitQueue.length > 0) {
                stateLogHelpers.downloadCommitQueue(self, commitQueue);
                return true;
            }

            return false;
        };

        this.getProjectAccess = function () {
            return state.projectAccess;
        };

        this.downloadError = function () {
            stateLogHelpers.downloadStateDump(self, state);
        };

        // Undo/Redo functionality
        function addModification(commitObject, clear) {
            var newItem,
                commitHash = commitObject[CONSTANTS.STORAGE.MONGO_ID],
                currItem;
            if (clear) {
                logger.debug('foreign modification clearing undo-redo chain');
                state.undoRedoChain = {
                    commitHash: commitHash,
                    rootHash: commitObject.root,
                    previous: null,
                    next: null
                };
                return;
            }

            // Check if the modification already exist, i.e. commit is from undoing or redoing.
            currItem = state.undoRedoChain;
            while (currItem) {
                if (currItem.commitHash === commitHash) {
                    return;
                }
                currItem = currItem.previous;
            }

            currItem = state.undoRedoChain;
            while (currItem) {
                if (currItem.commitHash === commitHash) {
                    return;
                }
                currItem = currItem.next;
            }

            newItem = {
                commitHash: commitHash,
                rootHash: commitObject.root,
                previous: state.undoRedoChain,
                next: null
            };
            state.undoRedoChain.next = newItem;
            state.undoRedoChain = newItem;
        }

        function canUndo() {
            var result = false;
            if (state.undoRedoChain && state.undoRedoChain.previous && state.undoRedoChain.previous.commitHash) {
                result = true;
            }

            return result;
        }

        function canRedo() {
            var result = false;
            if (state.undoRedoChain && state.undoRedoChain.next) {
                result = true;
            }

            return result;
        }

        this.undo = function (branchName, callback) {
            if (canUndo() === false) {
                callback(new Error('unable to make undo'));
                return;
            }

            state.undoRedoChain = state.undoRedoChain.previous;

            logState('info', 'undo [before setBranchHash]');
            storage.setBranchHash(state.project.projectId, branchName, state.undoRedoChain.commitHash, state.commitHash,
                function (err) {
                    if (err) {
                        //TODO do we need to handle this? How?
                        callback(err);
                        return;
                    }
                    logState('info', 'undo [after setBranchHash]');
                    callback(null);
                }
            );

        };

        this.redo = function (branchName, callback) {
            if (canRedo() === false) {
                callback(new Error('unable to make redo'));
                return;
            }

            state.undoRedoChain = state.undoRedoChain.next;

            logState('info', 'redo [before setBranchHash]');
            storage.setBranchHash(state.project.projectId, branchName, state.undoRedoChain.commitHash, state.commitHash,
                function (err) {
                    if (err) {
                        //TODO do we need to handle this? How?
                        callback(err);
                        return;
                    }
                    logState('info', 'redo [after setBranchHash]');
                    callback(null);
                }
            );
        };

        /**
         * Persists all commits in commitQueue and optionally tries to fast-forward the current branch.
         * If not fast-forwarding or it fails to do that - a new branch will be created.
         *
         * @param {commitQueue} commitQueue -
         * @param {object} [options] - optional parameters
         * @param {object} [options.fastForward] - If truthy will attempt to setBranchHash from current branch to last in queue.
         * @param {object} [options.newBranchName=%currentBranch_time-now%] - Name of new branch if needed.
         */
        this.applyCommitQueue = function (commitQueue, options, callback) {
            var branchName = self.getActiveBranchName(),
                projectId = commitQueue[0].projectId,
                firstCommitsParents = commitQueue[0].commitObject.parents,
                lastCommitHash = commitQueue[commitQueue.length - 1].commitObject._id;

            options = options || {};
            options.newBranchName = options.newBranchName || self.getActiveBranchName() + '_' + Date.now();

            function createNewBranch() {
                storage.createBranch(projectId, options.newBranchName, lastCommitHash, callback);
            }

            storage.persistCommits(commitQueue, function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                if (options.fastForward && firstCommitsParents.indexOf(self.getActiveCommitHash()) > -1) {
                    storage.setBranchHash(projectId, branchName, lastCommitHash, self.getActiveCommitHash(),
                        function (err, result) {
                            if (err) {
                                callback(err);
                            } else if (result.status !== CONSTANTS.STORAGE.SYNCED) {
                                createNewBranch();
                            } else {
                                callback();
                            }
                        }
                    );
                } else {
                    createNewBranch();
                }
            });
        };

        // REST-like functions and forwarded to storage TODO: add these to separate base class

        //  Getters
        this.getProjects = function (options, callback) {
            var asObject;
            if (self.isConnected()) {
                if (options.asObject) {
                    asObject = true;
                    delete options.asObject;
                }
                storage.getProjects(options, function (err, result) {
                    var i,
                        resultObj = {};
                    if (err) {
                        callback(err);
                        return;
                    }
                    if (asObject === true) {
                        for (i = 0; i < result.length; i += 1) {
                            resultObj[result[i]._id] = result[i];
                        }
                        callback(null, resultObj);
                    } else {
                        callback(null, result);
                    }
                });
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getProjectsAndBranches = function (asObject, callback) {
            //This is kept for the tests.
            self.getProjects({rights: true, branches: true, asObject: asObject}, callback);
        };

        this.getBranches = function (projectId, callback) {
            if (self.isConnected()) {
                storage.getBranches(projectId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getTags = function (projectId, callback) {
            if (self.isConnected()) {
                storage.getTags(projectId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getCommits = function (projectId, before, number, callback) {
            if (self.isConnected()) {
                storage.getCommits(projectId, before, number, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getHistory = function (projectId, start, number, callback) {
            if (self.isConnected()) {
                storage.getHistory(projectId, start, number, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.getLatestCommitData = function (projectId, branchName, callback) {
            if (self.isConnected()) {
                storage.getLatestCommitData(projectId, branchName, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        //  Setters
        this.createProject = function (projectName, parameters, callback) {
            if (self.isConnected()) {
                storage.createProject(projectName, parameters, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.deleteProject = function (projectId, callback) {
            if (self.isConnected()) {
                storage.deleteProject(projectId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.transferProject = function (projectId, newOwnerId, callback) {
            if (self.isConnected()) {
                storage.transferProject(projectId, newOwnerId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.duplicateProject = function (projectId, projectName, newOwnerId, callback) {
            if (self.isConnected()) {
                storage.duplicateProject(projectId, projectName, newOwnerId, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.createBranch = function (projectId, branchName, newHash, callback) {
            if (self.isConnected()) {
                storage.createBranch(projectId, branchName, newHash, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.deleteBranch = function (projectId, branchName, oldHash, callback) {
            if (self.isConnected()) {
                storage.deleteBranch(projectId, branchName, oldHash, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.createTag = function (projectId, tagName, commitHash, callback) {
            if (self.isConnected()) {
                storage.createTag(projectId, tagName, commitHash, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.deleteTag = function (projectId, tagName, callback) {
            if (self.isConnected()) {
                storage.deleteTag(projectId, tagName, callback);
            } else {
                callback(new Error('There is no open database connection!'));
            }
        };

        this.squashCommits = function(projectId, fromCommit, toCommitOrBranch, msg, callback) {
            // logger.debug('squashing latest commits of branch: ', parameters);
            storage.squashCommits(projectId,fromCommit,toCommitOrBranch,msg,callback);
        };

        // Watchers (used in e.g. ProjectNavigator).
        /**
         * Triggers eventHandler(storage, eventData) on PROJECT_CREATED and PROJECT_DELETED.
         *
         * eventData = {
         *    etype: PROJECT_CREATED||DELETED,
         *    projectId: %id of project%
         * }
         *
         * @param {function} eventHandler
         * @param {function} [callback]
         */
        this.watchDatabase = function (eventHandler, callback) {
            callback = callback || function (err) {
                    if (err) {
                        logger.error('Problems watching database room');
                    }
                };
            storage.watchDatabase(eventHandler, callback);
        };

        this.unwatchDatabase = function (eventHandler, callback) {
            callback = callback || function (err) {
                    if (err) {
                        logger.error('Problems unwatching database room');
                    }
                };
            storage.unwatchDatabase(eventHandler, callback);
        };

        /**
         * Triggers eventHandler(storage, eventData) on BRANCH_CREATED, BRANCH_DELETED and BRANCH_HASH_UPDATED
         * for the given projectId.
         *
         *
         * eventData = {
         *    etype: BRANCH_CREATED||DELETED||HASH_UPDATED,
         *    projectId: %id of project%,
         *    branchName: %name of branch%,
         *    newHash: %new commitHash (='' when DELETED)%
         *    oldHash: %previous commitHash (='' when CREATED)%
         * }
         *
         * @param {string} projectId
         * @param {function} eventHandler
         * @param {function} [callback]
         */
        this.watchProject = function (projectId, eventHandler, callback) {
            callback = callback || function (err) {
                    if (err) {
                        logger.error('Problems watching project room', projectId);
                    }
                };
            storage.watchProject(projectId, eventHandler, callback);
        };

        this.unwatchProject = function (projectId, eventHandler, callback) {
            callback = callback || function (err) {
                    if (err) {
                        logger.error('Problems unwatching project room', projectId);
                    }
                };
            storage.unwatchProject(projectId, eventHandler, callback);
        };

        // Internal functions

        function COPY(object) {
            if (object) {
                return JSON.parse(JSON.stringify(object));
            }
            return null;
        }

        // Node handling
        this.getNode = function (nodePath) {
            return getNode(nodePath, logger, state, storeNode);
        };

        this.getAllMetaNodes = function () {
            if (state && state.core && state.nodes && state.nodes[ROOT_PATH]) {
                var metaNodes = state.core.getAllMetaNodes(state.nodes[ROOT_PATH].node),
                    gmeNodes = [],
                    keys = Object.keys(metaNodes || {}),
                    i;

                for (i = 0; i < keys.length; i += 1) {
                    gmeNodes.push(self.getNode(storeNode(metaNodes[keys[i]]), logger, state, storeNode));
                }

                return gmeNodes;
            }

            return [];
        };

        function addLoadUnloadPathToUpdates(paths) {
            var i,
                pathPieces;

            for (i = 0; i < paths.length; i += 1) {
                pathPieces = paths[i].split(CONSTANTS.CORE.PATH_SEP);
                while (pathPieces.length > 1) {
                    state.loading.changedNodes.update[pathPieces.join(CONSTANTS.CORE.PATH_SEP)] = true;
                    pathPieces.pop();
                }
            }
        }

        function getModifiedNodes(newerNodes) {
            var modifiedNodes = [],
                updatedMetaPaths = [],
                metaNodes,
                metaPath,
                updatePath,
                nodePath,
                i;

            // For the client these rules apply for finding the affected nodes.
            // 1. Updates should be triggered to any node that core.isTypeOf (i.e. mixins accounted for).
            // 2. Root node should always be triggered.
            // 3. loads/unloads should trigger updates for the parent chain.

            if (state.loading.changedNodes) {
                // 1. Account for mixins - i.e resolve isTypeOf.
                // Gather all meta-nodes that had an update.
                metaNodes = state.core.getAllMetaNodes(newerNodes[ROOT_PATH].node);
                for (updatePath in state.loading.changedNodes.update) {
                    if (metaNodes.hasOwnProperty(updatePath)) {
                        updatedMetaPaths.push(updatePath);
                    }
                }

                if (updatedMetaPaths.length > 0) {
                    // There are meta-nodes with updates.
                    for (metaPath in metaNodes) {
                        // For all meta nodes..
                        if (metaNodes.hasOwnProperty(metaPath)) {
                            for (i = 0; i < updatedMetaPaths.length; i += 1) {
                                // check if it is a typeOf (includes mixins) any of the updated meta-nodes
                                if (state.core.isTypeOf(metaNodes[metaPath],
                                        metaNodes[updatedMetaPaths[i]]) === true) {
                                    // if so add its path to the update nodes.
                                    state.loading.changedNodes.update[metaPath] = true;
                                }
                            }
                        }
                    }
                }
                //console.log('Update after meta considered', Object.keys(state.loading.changedNodes.update));

                // 2. Add Root node
                state.loading.changedNodes.update[ROOT_PATH] = true;

                // 3. Account for loads and unloads.
                addLoadUnloadPathToUpdates(Object.keys(state.loading.changedNodes.load));
                addLoadUnloadPathToUpdates(Object.keys(state.loading.changedNodes.unload));

                //console.log('Update after loads and unloads considered',
                //    Object.keys(state.loading.changedNodes.update));
            }

            for (nodePath in state.nodes) {
                if (state.nodes.hasOwnProperty(nodePath) && newerNodes.hasOwnProperty(nodePath) &&
                    wasNodeUpdated(state.loading.changedNodes, newerNodes[nodePath].node)) {

                    modifiedNodes.push(nodePath);
                }
            }
            //console.log('NewerNodes, modifiedNodes', Object.keys(newerNodes).length, modifiedNodes.length);
            return modifiedNodes;
        }

        //this is just a first brute implementation it needs serious optimization!!!
        function fitsInPatternTypes(path, pattern) {
            var i;

            if (pattern.items && pattern.items.length > 0) {
                for (i = 0; i < pattern.items.length; i += 1) {
                    if (self.isTypeOf(path, pattern.items[i])) {
                        return true;
                    }
                }
                return false;
            } else {
                return true;
            }
        }

        function patternToPaths(patternId, pattern, pathsSoFar) {
            var children,
                subPattern,
                i;

            if (state.nodes[patternId]) {
                pathsSoFar[patternId] = true;
                if (pattern.children && pattern.children > 0) {
                    children = state.core.getChildrenPaths(state.nodes[patternId].node);
                    subPattern = COPY(pattern);
                    subPattern.children -= 1;
                    for (i = 0; i < children.length; i += 1) {
                        if (fitsInPatternTypes(children[i], pattern)) {
                            patternToPaths(children[i], subPattern, pathsSoFar);
                        }
                    }
                }
            } else {
                state.loadError++;
            }
        }

        function userEvents(userId, modifiedNodes) {
            var newPaths = {},
                startErrorLevel = state.loadError,
                loadedOrUnloaded = {},
                i,
                events = [];

            for (i in state.users[userId].PATTERNS) {
                if (state.users[userId].PATTERNS.hasOwnProperty(i)) {
                    if (state.nodes[i]) { //TODO we only check pattern if its root is there...
                        patternToPaths(i, state.users[userId].PATTERNS[i], newPaths);
                    }
                }
            }

            if (startErrorLevel !== state.loadError) {
                return; //we send events only when everything is there correctly
            }

            //deleted items
            for (i in state.users[userId].PATHS) {
                if (!newPaths[i]) {
                    events.push({etype: 'unload', eid: i});
                    loadedOrUnloaded[i] = true;
                }
            }

            //added items
            for (i in newPaths) {
                if (!state.users[userId].PATHS[i]) {
                    events.push({etype: 'load', eid: i});
                    loadedOrUnloaded[i] = true;
                }
            }

            //updated items
            for (i = 0; i < modifiedNodes.length; i++) {
                // Check that there wasn't a load or unload event for the node
                if (newPaths[modifiedNodes[i]] && !loadedOrUnloaded[modifiedNodes[i]]) {
                    events.push({etype: 'update', eid: modifiedNodes[i]});
                }
            }

            state.users[userId].PATHS = newPaths;

            //this is how the events should go
            if (events.length > 0) {
                if (state.loadError > startErrorLevel) {
                    events.unshift({etype: 'incomplete', eid: null});
                } else {
                    events.unshift({etype: 'complete', eid: null});
                }
            } else {
                events.unshift({etype: 'complete', eid: null});
            }

            state.users[userId].FN(events);
        }

        function loadChildrenPattern(core, nodesSoFar, node, level, callback) {
            var path = core.getPath(node),
                childrenPaths = core.getChildrenPaths(node),
                childrenRelids = core.getChildrenRelids(node),
                missing = childrenPaths.length,
                error = null,
                i,
                childLoaded = function (err, child) {
                    if (err || child === null) {
                        error = error || err;
                        missing -= 1;
                        if (missing === 0) {
                            callback(error);
                        }
                    } else {
                        loadChildrenPattern(core, nodesSoFar, child, level - 1, childrenPatternLoaded);
                    }
                },
                childrenPatternLoaded = function (err) {
                    error = error || err;
                    missing -= 1;
                    if (missing === 0) {
                        callback(error);
                    }
                };

            if (!nodesSoFar[path]) {
                nodesSoFar[path] = {
                    node: node
                };
            }
            if (level > 0) {
                if (missing > 0) {
                    for (i = 0; i < childrenPaths.length; i++) {
                        if (nodesSoFar[childrenPaths[i]]) {
                            loadChildrenPattern(core,
                                nodesSoFar,
                                nodesSoFar[childrenPaths[i]].node,
                                level - 1, childrenPatternLoaded);
                        } else {
                            core.loadChild(node, childrenRelids[i], childLoaded);
                        }
                    }
                } else {
                    callback(error);
                }
            } else {
                callback(error);
            }
        }

        function loadPattern(core, id, pattern, nodesSoFar, callback) {
            //console.log('LP',id,pattern);
            //var _callback = callback;
            //callback = function(error){
            //    console.log('LPF',id,pattern);
            //    _callback(error);
            //};

            var base = null,
                baseLoaded = function () {
                    if (pattern.children && pattern.children > 0) {
                        var level = pattern.children;
                        loadChildrenPattern(core, nodesSoFar, base, level, callback);
                    } else {
                        callback(null);
                    }
                };

            if (nodesSoFar[id]) {
                base = nodesSoFar[id].node;
                baseLoaded();
            } else {
                if (!nodesSoFar[ROOT_PATH]) {
                    logger.error('pattern cannot be loaded if there is no root!!!');
                }
                base = nodesSoFar[ROOT_PATH].node;

                core.loadByPath(base, id, function (err, node) {
                    var path;
                    if (!err && node && !core.isEmpty(node)) {
                        path = core.getPath(node);
                        if (!nodesSoFar[path]) {
                            nodesSoFar[path] = {
                                node: node
                            };
                        }
                        base = node;
                        baseLoaded();
                    } else {
                        callback(err);
                    }
                });
            }
        }

        this.startTransaction = function (msg) {
            if (state.inTransaction) {
                logger.error('Already in transaction, will proceed though..');
            }
            if (state.core) {
                state.inTransaction = true;
                msg = msg || '[';
                saveRoot(msg);
            } else {
                logger.error('Can not start transaction with no core avaliable.');
            }
        };

        this.completeTransaction = function (msg, callback) {
            state.inTransaction = false;
            if (state.core) {
                msg = msg || ']';
                saveRoot(msg, callback);
            }
        };

        //territory functions
        this.addUI = function (ui, fn, guid) {
            ASSERT(fn);
            ASSERT(typeof fn === 'function');
            guid = guid || GUID();
            state.users[guid] = {type: 'notused', UI: ui, PATTERNS: {}, PATHS: {}, SENDEVENTS: true, FN: fn};
            return guid;
        };

        this.removeUI = function (guid) {
            logger.debug('removeUI', guid);
            delete state.users[guid];
        };

        this._removeAllUIs = function () {
            // This is mainly intended for clean up during testing.
            logger.debug('_removeAllUIs called');
            state.users = {};
        };

        function reLaunchUsers() {
            var i;
            for (i in state.users) {
                if (state.users.hasOwnProperty(i)) {
                    if (state.users[i].UI.reLaunch) {
                        state.users[i].UI.reLaunch();
                    }
                }
            }
        }

        function _updateTerritoryAllDone(guid, patterns, error) {

            logger.debug('updateTerritory related loads finished', {
                metadata: {
                    userId: guid, patterns: patterns, error: error
                }
            });

            if (state.users[guid]) {
                state.users[guid].PATTERNS = COPY(patterns);
                if (!error) {
                    userEvents(guid, []);
                }
            }
        }

        function canSwitchStates() {
            if (state.inLoading && state.ongoingTerritoryUpdateCounter === 0 &&
                state.ongoingLoadPatternsCounter === 0) {
                return true;
            }
            return false;
        }

        function loadingPatternFinished(err) {
            state.loadingStatus = state.loadingStatus || err;
            state.ongoingLoadPatternsCounter -= 1;

            if (canSwitchStates()) {
                switchStates();
            }
        }

        this.updateTerritory = function (guid, patterns) {
            var loadRequestCounter = 0,
                updateRequestId = GUID(),
                error = null,
                keys = Object.keys(patterns || {}),
                i,
                patternLoaded = function (err) {
                    error = error || err;
                    if (--loadRequestCounter === 0) {
                        delete state.pendingTerritoryUpdatePatterns[updateRequestId];
                        _updateTerritoryAllDone(guid, patterns, error);
                        state.ongoingTerritoryUpdateCounter -= 1;
                        if (state.ongoingTerritoryUpdateCounter < 0) {
                            logger.error('patternLoaded callback have been called multiple times!!');
                            state.ongoingTerritoryUpdateCounter = 0; //FIXME
                        }
                        if (canSwitchStates()) {
                            switchStates();
                        }
                    }
                };

            logger.debug('updatingTerritory', {
                metadata: {
                    userId: guid,
                    patterns: patterns
                }
            });

            if (!state.nodes[ROOT_PATH]) {
                if (state.users[guid]) {
                    logger.debug('early updateTerritory for user[' + guid + ']. No loaded project state yet.');
                    state.users[guid].PATTERNS = COPY(patterns);
                }
                return;
            }

            //empty territory check
            if (keys.length === 0) {
                _updateTerritoryAllDone(guid, patterns, null);
                return;
            }

            state.ongoingTerritoryUpdateCounter += 1;

            //first we have to set the internal counter as the actual load can get synchronous :(
            loadRequestCounter = keys.length;

            for (i = 0; i < keys.length; i += 1) {
                if (state.inLoading) {
                    state.ongoingLoadPatternsCounter += 1;
                    loadPatternThrottled(state.core,
                        keys[i], patterns[keys[i]], state.loadNodes, loadingPatternFinished);
                } else {
                    //we should save the patterns to a pending directory
                    state.pendingTerritoryUpdatePatterns[updateRequestId] = patterns;
                }
                loadPatternThrottled(state.core, keys[i], patterns[keys[i]], state.nodes, patternLoaded);
            }

        };

        function switchStates() {
            //it is safe now to move the loadNodes into nodes,
            // refresh the metaNodes and generate events - all in a synchronous manner!!!
            var modifiedPaths,
                i;

            //console.time('switchStates');

            logger.debug('switching project state [C#' +
                state.commitHash + ']->[C#' + state.loading.commitHash + '] : [R#' +
                state.rootHash + ']->[R#' + state.loading.rootHash + ']');

            //console.time('getModifiedNodes');
            modifiedPaths = getModifiedNodes(state.loadNodes);
            //console.timeEnd('getModifiedNodes');
            state.nodes = state.loadNodes;
            state.loadNodes = {};
            self.getAllMetaNodes(); //This ensures that all language elements can be accessed with getNode

            state.inLoading = false;
            state.rootHash = state.loading.rootHash;
            state.loading.rootHash = null;
            state.commitHash = state.loading.commitHash;
            state.loading.commitHash = null;

            checkMetaNameCollision(state.core, state.nodes[ROOT_PATH].node);
            checkMixinErrors(state.core, state.nodes[ROOT_PATH].node);

            for (i in state.users) {
                if (state.users.hasOwnProperty(i)) {
                    userEvents(i, modifiedPaths);
                }
            }

            if (state.loadingStatus) {
                state.loading.next(state.loadingStatus);
            } else {
                state.loading.next(null);
            }

            //console.timeEnd('switchStates');
        }

        function loading(newRootHash, newCommitHash, changedNodes, callback) {
            var i, j,
                userIds,
                patternPaths,
                patternsToLoad = [];

            if (state.ongoingLoadPatternsCounter !== 0) {
                callback(new Error('at the start of loading counter should bee zero!!! [' +
                    state.ongoingLoadPatternsCounter + ']'));
                return;
            }

            state.loadingStatus = null;
            state.loadNodes = {};
            state.loading.rootHash = newRootHash;
            state.loading.commitHash = newCommitHash;
            state.loading.next = callback;
            state.loading.changedNodes = changedNodes;

            state.core.loadRoot(state.loading.rootHash, function (err, root) {
                if (err) {
                    state.loading.next(err);
                    return;
                }

                state.inLoading = true;
                state.loadNodes[state.core.getPath(root)] = {
                    node: root
                };

                //we first only set the counter of patterns but we also generate a completely separate pattern queue
                //as we cannot be sure if all the users will remain at the point of giving the actual load command!
                userIds = Object.keys(state.users);
                for (i = 0; i < userIds.length; i += 1) {
                    state.ongoingLoadPatternsCounter += Object.keys(state.users[userIds[i]].PATTERNS || {}).length;
                    patternPaths = Object.keys(state.users[userIds[i]].PATTERNS || {});
                    for (j = 0; j < patternPaths.length; j += 1) {
                        patternsToLoad.push({
                            id: patternPaths[j],
                            pattern: COPY(state.users[userIds[i]].PATTERNS[patternPaths[j]])
                        });
                    }
                }
                userIds = Object.keys(state.pendingTerritoryUpdatePatterns);
                for (i = 0; i < userIds.length; i += 1) {
                    state.ongoingLoadPatternsCounter +=
                        Object.keys(state.pendingTerritoryUpdatePatterns[userIds[i]] || {}).length;
                    patternPaths = Object.keys(state.pendingTerritoryUpdatePatterns[userIds[i]] || {});
                    for (j = 0; j < patternPaths.length; j += 1) {
                        patternsToLoad.push({
                            id: patternPaths[j],
                            pattern: COPY(state.pendingTerritoryUpdatePatterns[userIds[i]][patternPaths[j]])
                        });
                    }
                }

                //empty load check
                if (state.ongoingLoadPatternsCounter === 0) {
                    if (canSwitchStates()) {
                        switchStates();
                        reLaunchUsers();
                    }
                    return;
                }

                for (i = 0; i < patternsToLoad.length; i += 1) {
                    loadPatternThrottled(state.core,
                        patternsToLoad[i].id, patternsToLoad[i].pattern, state.loadNodes, loadingPatternFinished);
                }
            });
        }

        function wasNodeUpdated(changedNodes, node) {
            // Is changedNodes available at all?  If not (undo/redo) emit for all nodes...
            if (!changedNodes) {
                return true;
            }

            // Did the node have a collection update?
            if (changedNodes.partialUpdate[state.core.getPath(node)] === true) {
                return true;
            }

            // Did any of the base classes have a non-collection update?
            while (node) {
                if (changedNodes.update[state.core.getPath(node)] === true) {
                    return true;
                }

                node = state.core.getBase(node);
            }

            return false;
        }

        function cleanUsersTerritories() {
            //look out as the user can remove itself at any time!!!
            var userIds = Object.keys(state.users),
                i,
                j,
                events;

            for (i = 0; i < userIds.length; i++) {
                if (state.users[userIds[i]]) {
                    events = [{eid: null, etype: 'complete'}];
                    for (j in state.users[userIds[i]].PATHS
                        ) {
                        events.push({etype: 'unload', eid: j});
                    }
                    state.users[userIds[i]].PATTERNS = {};
                    state.users[userIds[i]].PATHS = {};
                    state.users[userIds[i]].SENDEVENTS = true;
                    state.users[userIds[i]].FN(events);
                }
            }
        }

        this.getUserId = function () {
            throw new Error('Deprecated! Username is not stored in a cookie anymore. If available, use ' +
                'WebGMEGlobal.userInfo, if not the user info is available at GET /api/user');
        };

        this.importProjectFromFile = function (projectName, branchName, blobHash, ownerId, url, callback) {
            var parameters = {
                command: 'importProjectFromFile',
                projectName: projectName,
                blobHash: blobHash,
                branchName: branchName,
                ownerId: ownerId,
                url: url
            };

            logger.debug('creating project from package', parameters);

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        };

        this.updateProjectFromFile = function (projectId, branchName, blobHash, callback) {
            var parameters = {
                command: 'updateProjectFromFile',
                blobHash: blobHash,
                projectId: projectId,
                branchName: branchName
            };

            logger.debug('updating project from package', parameters);

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        };

        //meta rules checking
        /**
         *
         * @param {string[]} nodePaths - Paths to nodes of which to check.
         * @param includeChildren
         * @param callback
         */
        this.checkMetaRules = function (nodePaths, includeChildren, callback) {
            var parameters = {
                command: 'checkConstraints',
                checkType: 'META', //TODO this should come from a constant
                includeChildren: includeChildren,
                nodePaths: nodePaths,
                commitHash: state.commitHash,
                projectId: state.project.projectId
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }

                self.dispatchEvent(CONSTANTS.META_RULES_RESULT, result);

                if (callback) {
                    callback(err, result);
                }
            });
        };

        /**
         *
         * @param {string[]} nodePaths - Paths to nodes of which to check.
         * @param {boolean} includeChildren - If true will recursively check the children of the nodes to check.
         * @param {function(Error, Object)} callback
         */
        this.checkCustomConstraints = function (nodePaths, includeChildren, callback) {
            var parameters = {
                command: 'checkConstraints',
                checkType: 'CUSTOM', //TODO this should come from a constant
                includeChildren: includeChildren,
                nodePaths: nodePaths,
                commitHash: state.commitHash,
                projectId: state.project.projectId
            };

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }

                self.dispatchEvent(CONSTANTS.CONSTRAINT_RESULT, result);

                if (callback) {
                    callback(err, result);
                }
            });
        };

        //seed
        this.seedProject = function (parameters, callback) {
            logger.debug('seeding project', parameters);
            parameters.command = 'seedProject';
            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        };

        this.dispatchAddOnNotification = function (data) {
            var notification = {
                severity: data.notification.severity || 'info',
                message: '[AddOn] ' + data.addOnName + ' - ' + data.notification.message
            };

            logger.debug('addOn notification', data);
            self.dispatchEvent(self.CONSTANTS.NOTIFICATION, notification);
            self.dispatchEvent(self.CONSTANTS.ADD_ON_NOTIFICATION, data);
        };

        // Constraints
        this.setConstraint = function (path, name, constraintObj) {
            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {
                state.core.setConstraint(state.nodes[path].node, name, constraintObj);
                saveRoot('setConstraint(' + path + ',' + name + ')');
            }
        };

        this.delConstraint = function (path, name) {
            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {
                state.core.delConstraint(state.nodes[path].node, name);
                saveRoot('delConstraint(' + path + 'name' + ')');
            }
        };

        //automerge
        this.autoMerge = function (projectId, mine, theirs, callback) {
            var command = {
                command: 'autoMerge',
                projectId: projectId,
                mine: mine,
                theirs: theirs
            };
            storage.simpleRequest(command, function (err, result) {
                if (err) {
                    logger.error('autoMerge failed with error', err);
                    callback(err);
                } else {
                    callback(null, result);
                }
            });
        };

        this.resolve = function (mergeResult, callback) {
            var command = {
                command: 'resolve',
                partial: mergeResult
            };
            storage.simpleRequest(command, function (err, result) {
                if (err) {
                    logger.error('resolve failed with error', err);
                    callback(err);
                } else {
                    callback(null, result);
                }
            });
        };

        //package save
        this.exportProjectToFile = function (projectId, branchName, commitHash, withAssets, callback) {
            var command = {};
            command.command = 'exportProjectToFile';
            command.projectId = projectId;
            command.branchName = branchName;
            command.commitHash = commitHash;
            command.withAssets = withAssets;
            logger.debug('exportProjectToFile, command', command);
            if (command.projectId && (command.branchName || commitHash)) {
                storage.simpleRequest(command, function (err, result) {
                    if (err && !result) {
                        logger.error('exportProjectToFile failed with error', err);
                        callback(err);
                    } else {
                        callback(err, result);
                    }
                });
            } else {
                callback(new Error('invalid parameters!'));
            }
        };

        this.exportSelectionToFile = function (projectId, commitHash, selectedIds, withAssets, callback) {
            var command = {};
            command.command = 'exportSelectionToFile';
            command.projectId = projectId;
            command.commitHash = commitHash;
            command.withAssets = withAssets;
            command.paths = selectedIds;

            logger.debug('exportSelectionToFile, command', command);
            if (command.projectId && commitHash && selectedIds && selectedIds.length > 0) {
                storage.simpleRequest(command, function (err, result) {
                    if (err && !result) {
                        logger.error('exportSelectionToFile failed with error', err);
                        callback(err);
                    } else {
                        callback(err, result);
                    }
                });
            } else {
                callback(new Error('invalid parameters!'));
            }
        };

        this.importSelectionFromFile = function (projectId, branchName, parentId, blobHash, callback) {
            var parameters = {
                command: 'importSelectionFromFile',
                projectId: projectId,
                blobHash: blobHash,
                parentPath: parentId,
                branchName: branchName
            };

            logger.debug('import selection from package', parameters);

            storage.simpleRequest(parameters, function (err, result) {
                if (err) {
                    logger.error(err);
                }
                callback(err, result);
            });
        };

        this.emitStateNotification = function () {
            var data = {
                type: CONSTANTS.STORAGE.CLIENT_STATE_NOTIFICATION,
                state: null,
                projectId: self.getActiveProjectId(),
                branchName: self.getActiveBranchName()
            };

            if (!data.projectId || !data.branchName) {
                // No need to send event if we're not a branch.
                return;
            }

            if (typeof self.uiStateGetter === 'function') {
                data.state = self.uiStateGetter();
            }
            logger.info('Sending state notification...');
            storage.sendNotification(data, function (err) {
                if (err) {
                    logger.error('Sending state notification failed', data, err);
                }

                logger.info('Sending state notification succeeded');
            });
        };

        this.dispatchConnectedUsersChanged = function (eventData) {
            self.dispatchEvent(CONSTANTS.CONNECTED_USERS_CHANGED, eventData);
        };

        this.registerUIStateGetter = function (uiStateGetter) {
            self.uiStateGetter = uiStateGetter;
        };

        //generic notification
        this.notifyUser = function (notification) {
            notification.severity = notification.severity || 'info';

            if (notification.message) {
                logger.debug('generic notification', notification);
                self.dispatchEvent(self.CONSTANTS.NOTIFICATION, notification);
            } else {
                logger.debug('cannot set empty notification');
            }
        };
        
        this.gmeConfig = gmeConfig;

        window.addEventListener('error', function (evt) {
            state.exception = {};
            if (evt.error) {
                state.exception.message = evt.error.message;
                state.exception.stack = evt.error.stack;
            } else {
                state.exception = 'No error on event - check browser';
            }

            self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, CONSTANTS.UNCAUGHT_EXCEPTION);
        });
    }

    // Inherit from the EventDispatcher
    Client.prototype = Object.create(EventDispatcher.prototype);
    Client.prototype.constructor = Client;

    return Client;
});
/*globals define*/
/*jshint browser: true, node:true*/

/**
 * Client module for creating, monitoring executor jobs.
 *
 * @author lattmann / https://github.com/lattmann
 * @author ksmyth / https://github.com/ksmyth
 * @author pmeijer / https://github.com/pmeijer
 */


define('executor/ExecutorClient',['superagent', 'q'], function (superagent, Q) {
    'use strict';

    /**
     * Client for creating, monitoring, and receiving output executor jobs.
     * This client is used by the Executor Workers and some of the API calls are not
     * meant to be used by "end users".
     *
     * @param {object} parameters
     * @param {object} parameters.logger
     * @constructor
     * @alias ExecutorClient
     */
    var ExecutorClient = function (parameters) {
        parameters = parameters || {};
        if (parameters.logger) {
            this.logger = parameters.logger;
        } else {
            var doLog = function () {
                console.log.apply(console, arguments);
            };
            this.logger = {
                debug: doLog,
                log: doLog,
                info: doLog,
                warn: doLog,
                error: doLog
            };
            console.warn('Since v1.3.0 ExecutorClient requires a logger, falling back on console.log.');
        }

        this.logger.debug('ctor', {metadata: parameters});

        this.isNodeJS = (typeof window === 'undefined') && (typeof process === 'object');
        this.isNodeWebkit = (typeof window === 'object') && (typeof process === 'object');
        //console.log(isNode);
        if (this.isNodeJS) {
            this.logger.debug('Running under node');
            this.server = '127.0.0.1';
            this.httpsecure = false;
        }

        this.server = parameters.server || this.server;
        this.serverPort = parameters.serverPort || this.serverPort;
        this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;
        if (this.isNodeJS) {
            this.http = this.httpsecure ? require('https') : require('http');
        }

        this.origin = '';
        if (this.httpsecure !== undefined && this.server && this.serverPort) {
            this.origin = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;
        }
        this.relativeUrl = '/rest/executor/';
        this.executorUrl = this.origin + this.relativeUrl;

        // TODO: TOKEN???
        // TODO: any ways to ask for this or get it from the configuration?
        if (parameters.executorNonce) {
            this.executorNonce = parameters.executorNonce;
        }

        this.logger.debug('origin', this.origin);
        this.logger.debug('executorUrl', this.executorUrl);
    };

    /**
     * Creates a new configuration object for the job execution.
     *
     * To make the worker post output either the outputInterval and/or outputSegmentSize must be specified.
     * <br> - If both are negative (or falsy) no output will be given.
     * <br> - When both are specified a timeout will be set at start (and after each posted output). If the number of lines
     *  exceeds outputSegmentSize during that timeout, the output will be posted and a new timeout will be triggered.
     * <br>
     * N.B. even though a short outputInterval is set, the worker won't post new output until the responses from
     * previous posts have returned. Before the job returns with a "completed" status code, all queued outputs will be
     * posted (and the responses will be ensured to have returned).
     *
     * @param {string} cmd - command to execute.
     * @param {string[]} [args] - command arguments.
     * @param {number} [outputInterval=-1] - max time [ms] between (non-empty) output posts from worker.
     * @param {number} [outputSegmentSize=-1] - number of lines before new output is posted from worker. (N.B. posted
     * segments can still contain more number of lines).
     * @return {object}
     */
    ExecutorClient.prototype.getNewExecutorConfig = function (cmd, args, outputInterval, outputSegmentSize) {
        var config = {
            cmd: cmd,
            resultArtifacts: [],
            outputSegmentSize: typeof outputSegmentSize === 'number' ? outputSegmentSize : -1,
            outputInterval: typeof outputInterval === 'number' ? outputInterval : -1
        };

        if (args) {
            config.args = args;
        }

        /**
         *
         * @param {string} name - name of the artifact.
         * @param {string[]} [patterns=[]] - inclusive pattern for files to be returned in this artifact.
         */
        config.defineResultArtifact = function (name, patterns) {
            this.resultArtifacts.push({
                name: name,
                resultPatterns: patterns || []
            });
        };

        return config;
    };

    /**
     * Creates a new job.
     *
     * @param {object} jobInfo - initial information about the job must contain the hash.
     * @param {object} jobInfo.hash - a unique id for the job (e.g. the hash of the artifact containing the executor_config.json).
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {@link JobInfo} <b>result</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    ExecutorClient.prototype.createJob = function (jobInfo, callback) {
        var deferred = Q.defer(),
            self = this;
        if (typeof jobInfo === 'string') {
            jobInfo = { hash: jobInfo }; // old API
        }

        this.logger.debug('createJob', {metadata: jobInfo});
        this.sendHttpRequestWithData('POST', this.getCreateURL(jobInfo.hash), jobInfo, function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('createJob - result', response);

            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.cancelJob = function (jobInfoOrHash, secret, callback) {
        var deferred = Q.defer(),
            hash = typeof jobInfoOrHash === 'string' ? jobInfoOrHash : jobInfoOrHash.hash,

            self = this;

        this.logger.debug('cancel', hash);
        this.sendHttpRequestWithData('POST', this.executorUrl + 'cancel/' + hash, {secret: secret},
            function (err, response) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                self.logger.debug('cancel - result', response);
                deferred.resolve(response);
            }
        );

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.updateJob = function (jobInfo, callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('updateJob', {metadata: jobInfo});
        this.sendHttpRequestWithData('POST', this.executorUrl + 'update/' + jobInfo.hash, jobInfo,
            function (err, response) {
                if (err) {
                    deferred.reject(err);
                    return;
                }

                self.logger.debug('updateJob - result', response);
                deferred.resolve(response);
            }
        );

        return deferred.promise.nodeify(callback);
    };

    /**
     * Retrieves the current state of the job in form of a {@link JobInfo}
     * @param {string} hash - unique id for the job (e.g. the hash of the artifact containing the executor_config.json).
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {@link JobInfo} <b>jobInfo</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    ExecutorClient.prototype.getInfo = function (hash, callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getInfo', hash);
        this.sendHttpRequest('GET', this.getInfoURL(hash), function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('getInfo - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.getAllInfo = function (callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getAllInfo');
        this.sendHttpRequest('GET', this.executorUrl, function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }

            self.logger.debug('getAllInfo - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.getInfoByStatus = function (status, callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getInfoByStatus', status);
        this.sendHttpRequest('GET', this.executorUrl + '?status=' + status, function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }
            self.logger.debug('getInfoByStatus - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.getWorkersInfo = function (callback) {
        var deferred = Q.defer(),
            self = this;
        this.logger.debug('getWorkersInfo');
        this.sendHttpRequest('GET', this.executorUrl + 'worker', function (err, response) {
            if (err) {
                deferred.reject(err);
                return;
            }
            self.logger.debug('getWorkersInfo - result', response);
            deferred.resolve(JSON.parse(response));
        });

        return deferred.promise.nodeify(callback);
    };

    /**
     * Retrieves the output associated with jobHash, to limit the output pass start and/or end.
     * The outputs are identified by 0, 1, 2, ...
     * @param {string} hash - hash of job related to output.
     * @param {number} [start] - number/id of the output segment to start from (inclusive).
     * @param {number} [end] - number/id of segment to end at (exclusive).
     * @param {function} [callback] - if provided no promise will be returned.
     *
     * @return {external:Promise}  On success the promise will be resolved with {@link OutputInfo} <b>result</b>.<br>
     * On error the promise will be rejected with {@link Error} <b>error</b>.
     */
    ExecutorClient.prototype.getOutput = function (hash, start, end, callback) {
        var deferred = Q.defer(),
            url = this.executorUrl + 'output/' + hash,
            query = '';

        if (typeof start === 'number') {
            query += '?start=' + start;
        }

        if (typeof end === 'number') {
            if (query) {
                query += '&end=' + end;
            } else {
                query += '?end=' + end;
            }
        }

        url += query;

        this.logger.debug('getOutput, url=', url);

        this.sendHttpRequest('GET', url, function (err, response) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve(JSON.parse(response));
            }
        });

        return deferred.promise.nodeify(callback);
    };

    ExecutorClient.prototype.sendOutput = function (outputInfo, callback) {
        var deferred = Q.defer(),
            url = this.executorUrl + 'output/' + outputInfo.hash;

        this.logger.debug('sendOutput', outputInfo._id);

        this.sendHttpRequestWithData('POST', url, outputInfo, function (err) {
            if (err) {
                deferred.reject(err);
            } else {
                deferred.resolve();
            }
        });

        return deferred.promise.nodeify(callback);
    };

    //<editor-fold desc="Helper methods">
    ExecutorClient.prototype.getInfoURL = function (hash) {
        return this.origin + this.getRelativeInfoURL(hash);
    };

    ExecutorClient.prototype.getRelativeInfoURL = function (hash) {
        var metadataBase = this.relativeUrl + 'info';
        if (hash) {
            return metadataBase + '/' + hash;
        } else {
            return metadataBase;
        }
    };

    ExecutorClient.prototype.getCreateURL = function (hash) {
        return this.origin + this.getRelativeCreateURL(hash);
    };

    ExecutorClient.prototype.getRelativeCreateURL = function (hash) {
        var metadataBase = this.relativeUrl + 'create';
        if (hash) {
            return metadataBase + '/' + hash;
        } else {
            return metadataBase;
        }
    };

    ExecutorClient.prototype.sendHttpRequest = function (method, url, callback) {
        return this.sendHttpRequestWithData(method, url, null, callback);
    };

    ExecutorClient.prototype.sendHttpRequestWithData = function (method, url, data, callback) {
        var req = new superagent.Request(method, url);
        if (this.executorNonce) {
            req.set('x-executor-nonce', this.executorNonce);
        }
        if (data) {
            req.send(data);
        }
        req.end(function (err, res) {
            if (err) {
                callback(err);
                return;
            }
            if (res.status > 399) {
                callback(res.status, res.text);
            } else {
                callback(null, res.text);
            }
        });
    };

    ExecutorClient.prototype._ensureAuthenticated = function (options, callback) {
        //this function enables the session of the client to be authenticated
        //TODO currently this user does not have a session, so it has to upgrade the options always!!!
//        if (options.headers) {
//            options.headers.webgmeclientsession = this._clientSession;
//        } else {
//            options.headers = {
//                'webgmeclientsession': this._clientSession
//            }
//        }
        callback(null, options);
    };
    //</editor-fold>

    return ExecutorClient;
});

/*globals define*/
define('js/Dialogs/PluginConfig/PluginConfigDialog',[], function () {
    'use strict';
});

/*globals define*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('common/util/util',[], function () {
    'use strict';

    function isTrueObject(value) {
        return typeof value === 'object' && value !== null && value instanceof Array === false;
    }

    /**
     * Overwrites/augments values in toData with values from fromData.
     *
     * @param {object} toData - Object that will be updated with matched keys from toData.
     * @param {object} fromData - Object that will overwrite the keys of toData.
     */
    function updateFieldsRec(toData, fromData) {
        var keys = Object.keys(fromData),
            i;

        for (i = 0; i < keys.length; i += 1) {
            if (isTrueObject(fromData[keys[i]]) && isTrueObject(toData[keys[i]])) {
                updateFieldsRec(toData[keys[i]], fromData[keys[i]]);
            } else {
                toData[keys[i]] = fromData[keys[i]];
            }
        }
    }

    function orderStringArrayByElementLength(strArray) {
        var ordered = [],
            i, j, index;

        for (i = 0; i < strArray.length; i += 1) {
            index = -1;
            j = 0;
            while (index === -1 && j < ordered.length) {
                if (ordered[j].length > strArray[i].length) {
                    index = j;
                }

                j += 1;
            }

            if (index === -1) {
                ordered.push(strArray[i]);
            } else {
                ordered.splice(index, 0, strArray[i]);
            }
        }

        return ordered;
    }

    function indexOfUntil(items, item, maxIndex) {
        var len = items.length > maxIndex ? maxIndex : items.length;
        while (len--) {
            if (items[len] === item) {
                return len;
            }
        }

        return -1;
    }

    function indexOfUntilInObjectArray(items, item, maxIndex, key) {
        var len = items.length > maxIndex ? maxIndex : items.length;
        while (len--) {
            if (items[len][key] === item[key]) {
                return len;
            }
        }

        return -1;
    }

    function extendArrayUnique(base, extension) {
        var originalLength = base.length,
            extensionLen = extension.length,
            item;

        while (extensionLen--) {
            item = extension[extensionLen];
            if (indexOfUntil(base, item, originalLength) === -1) {
                base.push(item);
            }
        }

    }

    function extendObjectArrayUnique(base, extension, key) {
        var originalLength = base.length,
            extensionLen = extension.length,
            item;

        while (extensionLen--) {
            item = extension[extensionLen];
            if (indexOfUntilInObjectArray(base, item, originalLength, key) === -1) {
                base.push(item);
            }
        }

    }

    return {
        isTrueObject: isTrueObject,
        updateFieldsRec: updateFieldsRec,
        orderStringArrayByElementLength: orderStringArrayByElementLength,
        extendArrayUnique: extendArrayUnique,
        extendObjectArrayUnique: extendObjectArrayUnique
    };
});
/*globals define, WebGMEGlobal*/

/**
 * @author pmeijer / https://github.com/pmeijer
 */

define('js/Utils/ComponentSettings',['common/util/util', 'superagent'], function (UTIL, superagent) {

    'use strict';

    /**
     * Updates the defaultSettings based on passed settings.
     *
     * @param {object} defaultSettings - hardcoded in the component.
     * @param {object} [deploymentSettings] - defined on the server at config/components.json.
     * @param {object} [userSettings] - defined for the specific user.
     */
    function resolveSettings(defaultSettings, deploymentSettings, userSettings) {
        if (deploymentSettings && typeof deploymentSettings === 'object') {
            UTIL.updateFieldsRec(defaultSettings, deploymentSettings);
        }

        if (userSettings && typeof userSettings === 'object') {
            UTIL.updateFieldsRec(defaultSettings, userSettings);
        }

        return defaultSettings;
    }

    /**
     * Updates the defaultSettings trying ot extract values from WebGMEGlobal.
     *
     * @param {object} defaultSettings - hardcoded in the component.
     * @param {string} componentID - UniqueId for component.
     */
    function resolveWithWebGMEGlobal(defaultSettings, componentId) {
        var deploymentSettings,
            userSettings;

        if (typeof WebGMEGlobal === 'undefined') {
            throw new Error('WebGMEGlobal must be defined for this function, use resolveSettings');
        }

        deploymentSettings = WebGMEGlobal.componentSettings && WebGMEGlobal.componentSettings[componentId];
        userSettings = WebGMEGlobal.userInfo && WebGMEGlobal.userInfo.settings &&
            WebGMEGlobal.userInfo.settings[componentId];

        return resolveSettings(defaultSettings, deploymentSettings, userSettings);
    }


    function updateComponentSettings(componentId, newSettings, callback) {
        superagent.patch('api/user/settings/' + componentId)
            .send(newSettings)
            .end(function (err, res) {
                if (err || res.status !== 200) {
                    callback(err || new Error('Did not return status 200: ' + res.status));
                    return;
                }

                callback(null, res.body);
            });
    }

    function overwriteComponentSettings(componentId, newSettings, callback) {
        superagent.put('api/user/settings/' + componentId)
            .send(newSettings)
            .end(function (err, res) {
                if (err || res.status !== 200) {
                    callback(err || new Error('Did not return status 200: ' + res.status));
                    return;
                }

                callback(null, res.body);
            });
    }

    return {
        resolveSettings: resolveSettings,
        resolveWithWebGMEGlobal: resolveWithWebGMEGlobal,
        updateComponentSettings: updateComponentSettings,
        overwriteComponentSettings: overwriteComponentSettings
    };
});
/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * @author rkereskenyi / https://github.com/rkereskenyi
 * @author lattmann / https://github.com/lattmann
 * @author pmeijer / https://github.com/pmeijer
 */

define('js/Utils/InterpreterManager',[
    'plugin/PluginResult',
    'plugin/PluginMessage',
    'js/Dialogs/PluginConfig/PluginConfigDialog',
    'js/logger',
    'js/Utils/ComponentSettings'
], function (PluginResult, PluginMessage, PluginConfigDialog, Logger, ComponentSettings) {

    'use strict';

    var InterpreterManager = function (client, gmeConfig) {
        this._client = client;
        //this._manager = new PluginManagerBase();
        this.gmeConfig = gmeConfig;
        this._savedConfigs = {};
        this.logger = Logger.create('gme:InterpreterManager', gmeConfig.client.log);
        this.logger.debug('InterpreterManager ctor');
    };

    InterpreterManager.prototype.GLOBAL_OPTIONS = 'Global Options';

    InterpreterManager.prototype.getPluginErrorResult = function (pluginName, message, startTime, projectId) {
        var pluginResult = new PluginResult(),
            pluginMessage = new PluginMessage();
        pluginMessage.severity = 'error';
        pluginMessage.message = message;
        pluginResult.setSuccess(false);
        pluginResult.setPluginName(pluginName);
        pluginResult.setProjectId(projectId || this._client.getActiveProjectId() || 'N/A');
        pluginResult.addMessage(pluginMessage);
        pluginResult.setStartTime(startTime);
        pluginResult.setFinishTime((new Date()).toISOString());
        pluginResult.setError(pluginMessage.message);

        return pluginResult;
    }

    /**
     *
     * @param {object} metadata - metadata of plugin to be executed.
     * @param {function(PluginResult|boolean)} callback - If canceled from dialog returns with false.
     */
    InterpreterManager.prototype.configureAndRun = function (metadata, callback) {
        var self = this,
            configDialog = new PluginConfigDialog({client: this._client}),
            context = self._client.getCurrentPluginContext(metadata.id),
            globalOptions = this.getGlobalOptions(metadata, {namespace: context.managerConfig.namespace});

        if (globalOptions instanceof PluginResult) {
            callback(globalOptions);
            return;
        }

        configDialog.show(globalOptions, metadata, this.getStoredConfiguration(metadata),
            function (globalConfig, pluginConfig, storeInUser) {
                var startTime = (new Date()).toISOString();

                function execCallback(err, result) {
                    if (err) {
                        self.logger.error(err);
                        if (result) {
                            callback(new PluginResult(result));
                        } else {
                            callback(self.getPluginErrorResult(metadata.id, err.message, startTime,
                                context.managerConfig.project.projectId));
                        }
                    } else {
                        callback(new PluginResult(result));
                    }
                }

                if (globalConfig === false) {
                    // Canceled from dialog..
                    callback(false);
                    return;
                }

                // Store the config in memory for this session.
                self._savedConfigs[metadata.id] = pluginConfig;

                if (storeInUser === true) {
                    self.saveSettingsInUser(metadata, pluginConfig);
                }

                context.pluginConfig = pluginConfig;
                context.managerConfig.namespace = globalConfig.namespace;

                // Before executing the plugin - make sure the client is in SYNC.
                // This can be skipped if the plugin is read-only and executed on
                // the client.
                var readOnlyClient = !globalConfig.runOnServer && !metadata.writeAccessRequired,
                    isOutOfSync = self._client.getBranchStatus() &&
                        self._client.getBranchStatus() !== self._client.CONSTANTS.BRANCH_STATUS.SYNC;

                if (!readOnlyClient && isOutOfSync) {
                    callback(self.getPluginErrorResult(metadata.id, 'Not allowed ' +
                        'to invoke server plugin while local branch is AHEAD or ' +
                        'PULLING changes from server.', startTime));
                    return;
                }

                if (globalConfig.runOnServer === true) {
                    self._client.runServerPlugin(metadata.id, context, execCallback);
                } else {
                    self._client.runBrowserPlugin(metadata.id, context, execCallback);
                }
            }
        );
    };

    InterpreterManager.prototype.getGlobalOptions = function (pluginMetadata, defaults) {
        var runOption = {
                name: 'runOnServer',
                displayName: 'Execute on Server',
                description: '',
                value: defaults.hasOwnProperty('runOnServer') ? defaults.runOnServer : false,
                valueType: 'boolean',
                readOnly: false
            },
            namespace = {
                name: 'namespace',
                displayName: 'Used Namespace',
                description: 'The namespace the plugin should run under.',
                value: defaults.hasOwnProperty('namespace') ? defaults.namespace : '',
                valueType: 'string',
                valueItems: [],
                readOnly: false
            },
            result = [],
            serverAllowedGlobal = this.gmeConfig.plugin.allowServerExecution === true,
            serverAllowedPlugin = !(pluginMetadata.disableServerSideExecution),
            browserAllowedGlobal = this.gmeConfig.plugin.allowBrowserExecution === true,
            browserAllowedPlugin = !(pluginMetadata.disableBrowserSideExecution),
            errorMessage;

        if (serverAllowedGlobal === false && browserAllowedGlobal === false) {
            errorMessage = 'Plugin execution is disabled!';
        } else if (serverAllowedPlugin === false && browserAllowedPlugin === false) {
            errorMessage = 'This plugin cannot run on the server nor in the browser!?';
        } else if (browserAllowedGlobal) {
            if (serverAllowedGlobal) {
                if (browserAllowedPlugin) {
                    if (serverAllowedPlugin) {
                        // This is the default
                    } else {
                        runOption.readOnly = true;
                        runOption.description = 'This plugin can not run on the server.';
                    }
                } else {
                    runOption.readOnly = true;
                    runOption.value = true;
                    runOption.description = 'This plugin can not run in the browser.';
                }
            } else {
                if (browserAllowedPlugin) {
                    runOption.readOnly = true;
                    runOption.description = 'Server execution is disabled.';
                } else {
                    errorMessage = 'This plugin can only run on the server which is disabled!';
                }
            }
        } else {
            if (browserAllowedPlugin) {
                runOption.readOnly = true;
                runOption.value = true;
                runOption.description = 'Browser execution is disabled.';
            } else {
                errorMessage = 'This plugin can only run on the server which is disabled!';
            }
        }

        if (errorMessage) {
            return this.getPluginErrorResult(pluginMetadata.id, errorMessage, (new Date()).toISOString());
        } else {
            result.push(runOption);
            namespace.valueItems = this._client.getLibraryNames();

            if (namespace.valueItems.length > 0) {
                namespace.valueItems.unshift('');
                result.push(namespace);
            }

            return result;
        }
    };

    InterpreterManager.prototype.getStoredConfiguration = function (pluginMetadata) {
        var config,
            componentId = this.getPluginComponentId(pluginMetadata);

        // Always use the configuration stored from a previous run if it's available.
        if (this._savedConfigs.hasOwnProperty(pluginMetadata.id)) {
            config = this._savedConfigs[pluginMetadata.id];
        } else if (typeof WebGMEGlobal !== 'undefined') {
            config = {};
            ComponentSettings.resolveWithWebGMEGlobal(config, componentId);
        }

        return config;
    };

    InterpreterManager.prototype.saveSettingsInUser = function (pluginMetadata, pluginConfig, callback) {
        var self = this,
            componentId = this.getPluginComponentId(pluginMetadata.id);

        this.logger.debug('Saving plugin config in user', componentId, pluginConfig);

        ComponentSettings.overwriteComponentSettings(componentId, pluginConfig, function (err, newSettings) {
            if (callback) {
                if (err) {
                    callback(err);
                } else {
                    callback(null, newSettings);
                }
            } else {
                if (err) {
                    self.logger.error(new Error('Failed storing settings for user'), err);
                } else {
                    self.logger.debug('Stored new settings for plugin at', componentId, newSettings);
                }
            }
        });
    };

    InterpreterManager.prototype.getPluginComponentId = function (pluginMetadata) {
        var componentId = 'Plugin_' + pluginMetadata.id + '__' + pluginMetadata.version.split('.').join('_');
        this.logger.debug('Resolved componentId for plugin "' + componentId + '"');
        return componentId;
    };

    //TODO: Somehow it would feel more right if we do run in async mode, but if not then we should provide getState and
    //TODO: getResult synchronous functions as well.

    return InterpreterManager;
});

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('lib/superagent/superagent',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.superagent = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;

},{}],2:[function(require,module,exports){
/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = require('./is-object');

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

exports.clearTimeout = function _clearTimeout(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

exports.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

exports.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

exports.timeout = function timeout(ms){
  this._timeout = ms;
  return this;
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} reject
 * @return {Request}
 */

exports.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject){
      self.end(function(err, res){
        if (err) innerReject(err); else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
}

/**
 * Allow for extension
 */

exports.use = function use(fn) {
  fn(this);
  return this;
}


/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

exports.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

exports.getHeader = exports.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

exports.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
exports.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
exports.field = function(name, val) {
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
exports.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

exports.withCredentials = function(){
  // This is browser-only functionality. Node side is no-op.
  this._withCredentials = true;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

exports.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

exports.toJSON = function(){
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

exports._isHost = function _isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

exports.send = function(data){
  var obj = isObject(data);
  var type = this._header['content-type'];

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj || this._isHost(data)) return this;

  // default to json
  if (!type) this.type('json');
  return this;
};

},{"./is-object":1}],3:[function(require,module,exports){
// The node and browser modules expose versions of this with the
// appropriate constructor function bound as first argument
/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(RequestConstructor, method, url) {
  // callback
  if ('function' == typeof url) {
    return new RequestConstructor('GET', method).end(url);
  }

  // url first
  if (2 == arguments.length) {
    return new RequestConstructor('GET', method);
  }

  return new RequestConstructor(method, url);
}

module.exports = request;

},{}],4:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],5:[function(require,module,exports){
/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = require('emitter');
var requestBase = require('./request-base');
var isObject = require('./is-object');

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = module.exports = require('./request').bind(null, Request);

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only verison of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  return /[\/+]json\b/.test(mime);
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */),
        key = parts.shift(),
        val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  this._setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this._parseBody(this.text ? this.text : this.xhr.response)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype._setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str){
  var parse = request.parse[this.type];
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype._setStatusProperties = function(status){
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }

  var type = status / 100 | 0;

  // status / class
  this.status = this.statusCode = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
      // issue #876: return the http status code if the response parsing fails
      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (res.status < 200 || res.status >= 300) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
        new_err.original = err;
        new_err.response = res;
        new_err.status = res.status;
      }
    } catch(e) {
      new_err = e; // #985 touching res may cause INVALID_STATE_ERR on old Android
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `requestBase`.
 */

Emitter(Request.prototype);
for (var key in requestBase) {
  Request.prototype[key] = requestBase[key];
}

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set responseType to `val`. Presently valid responseTypes are 'blob' and
 * 'arraybuffer'.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (!options) {
    options = {
      type: 'basic'
    }
  }

  switch (options.type) {
    case 'basic':
      var str = btoa(user + ':' + pass);
      this.set('Authorization', 'Basic ' + str);
    break;

    case 'auto':
      this.username = user;
      this.password = pass;
    break;
  }
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  this._getFormData().append(field, file, filename || file.name);
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype._timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */

Request.prototype._appendQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (0 == status) {
      if (self.timedout) return self._timeoutError();
      if (self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(e){
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = 'download';
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    xhr.onprogress = handleProgress;
  }
  try {
    if (xhr.upload && this.hasListeners('progress')) {
      xhr.upload.onprogress = handleProgress;
    }
  } catch(e) {
    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
    // Reported here:
    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.timedout = true;
      self.abort();
    }, timeout);
  }

  // querystring
  this._appendQueryString();

  // initiate request
  if (this.username && this.password) {
    xhr.open(this.method, this.url, true, this.username, this.password);
  } else {
    xhr.open(this.method, this.url, true);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};


/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn){
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

},{"./is-object":1,"./request":3,"./request-base":2,"emitter":4}]},{},[5])(5)
});
/*globals define*/
/*jshint browser: true*/
/**
 * @author pmeijer / https://github.com/pmeijer
 */
var CREATE_BRANCH = false;
//PROJECT_NAME = 'IBug',
//BRANCH_NAME = 'master',
//NEW_BRANCH_HASH = '#d2d00cdd50a1ca144666a52a471af59d280ac751';

define('teststorage/teststorage',[
    'js/logger',
    'common/storage/browserstorage',
    'common/core/core',
    'common/storage/constants'
], function (Logger, Storage, Core, CONSTANTS) {
    'use strict';
    function Client(gmeConfig, projectName, branchName) {
        var logger = Logger.create('gme:client', gmeConfig.client.log),
            storage = Storage.getStorage(logger, gmeConfig),
            currRootNode,
            currCommitObject,
            intervalId,
            core,
            PROJECT_NAME = projectName,
            BRANCH_NAME = branchName;

        logger.debug('ctor');
        function loadChildrenAndSetAttribute(rootNode, commitObject) {
            core.loadChildren(rootNode, function (err, children) {
                if (err) {
                    throw new Error(err);
                }
                logger.debug('children loaded', children);
                //children.map(function (child) {
                var newPos;
                logger.debug('child name', core.getAttribute(children[0], 'name'));
                //if (core.getAttribute(children[0], 'name') === 'newName') {
                newPos = {x: 70 + getRandomInt(0, 100), y: 70 + getRandomInt(0, 100)};
                core.setRegistry(children[0], 'position', newPos);
                logger.debug('setting new position', newPos);
                //}
                //});
                currRootNode = rootNode;
                core.persist(rootNode, function (err, persisted) {
                    if (err) {
                        throw new Error(err);
                    }
                    logger.debug('cb persist data', persisted);
                    currCommitObject = storage.makeCommit(PROJECT_NAME, BRANCH_NAME,
                        [commitObject._id],
                        persisted.rootHash,
                        persisted.objects,
                        'First commit from new storage'
                    );

                });
                //logger.debug('persistData', persistData);
                //core.loadChildren(rootNode, function (err, children) {
                //    if (err) {
                //        throw new Error(err);
                //    }
                //    logger.debug('children loaded again (should come from cache)', children);
                //});
            });
        }

        storage.open(function (status) {
            logger.debug('storage is open');
            if (status === CONSTANTS.CONNECTED) {
                storage.getProjectNames({}, function (err, projectNames) {
                    if (err) {
                        throw new Error(err);
                    }
                    if (projectNames.indexOf(projectName) < 0) {
                        throw new Error('Project does not exist');
                    }
                    logger.debug(projectNames);
                    storage.watchProject(PROJECT_NAME, function (_ws, data) {
                        logger.debug('watchProject event', data);
                    });
                    storage.openProject(PROJECT_NAME, function (err, project, branches) {
                        if (err) {
                            throw new Error(err);
                        }
                        var updateHandler = function (newCommitData) {
                            logger.debug('updateHandler invoked', newCommitData);
                            logger.debug('would call loadNodes...');
                            currCommitObject = newCommitData.commitObject;
                            core.loadRoot(newCommitData.commitObject.root, function (err, rootNode) {
                                if (err) {
                                    throw new Error(err);
                                }
                                logger.debug('rootNode loaded', rootNode);
                                currRootNode = rootNode;
                                core.loadChildren(rootNode, function (err, children) {
                                    if (err) {
                                        throw new Error(err);
                                    }
                                    logger.debug('children loaded', children);
                                    children.map(function (child) {
                                        logger.debug('child name', core.getAttribute(child, 'name'));
                                        if (core.getAttribute(child, 'name') === 'newName') {
                                            logger.debug('Got new position', core.getRegistry(child, 'position'));
                                        }
                                    });
                                });
                            });
                        };
                        var commitHandler = function (commitQueue, result, callback) {
                            logger.debug('commitHandler', result);
                            if (result.status === CONSTANTS.SYNCH) {
                                callback(true); // All is fine, continue with the commitQueue..
                            } else if (result.status === CONSTANTS.FORKED) {
                                logger.debug('You got forked, queued commits', commitQueue);
                                callback(false);
                            } else {
                                throw new Error('Unexpected result', result);
                            }
                        };
                        logger.debug('openProject project', project);
                        logger.debug('openProject returned branches', branches);
                        storage.openBranch(PROJECT_NAME, BRANCH_NAME, updateHandler, commitHandler,
                            function (err, latestCommit) {
                                if (err) {
                                    throw new Error(err);
                                }
                                logger.debug('latestCommit', latestCommit);
                                currCommitObject = latestCommit.commitObject;
                                core = new Core(project, {
                                    globConf: gmeConfig,
                                    logger: logger.fork('core')
                                });
                                logger.debug('core instantiated');
                                core.loadRoot(latestCommit.commitObject.root, function (err, rootNode) {
                                    if (err) {
                                        throw new Error(err);
                                    }
                                    logger.debug('rootNode loaded', rootNode);
                                    loadChildrenAndSetAttribute(rootNode, latestCommit.commitObject);
                                });
                            }
                        );
                        //storage.deleteBranch(PROJECT_NAME, 'b535', branches['b535'], function () {
                        //    logger.debug('branch deleted', arguments);
                        //});
                    });
                    if (CREATE_BRANCH) {
                        storage.getBranches(PROJECT_NAME, {}, function (err, data) {
                            if (err) {
                                throw new Error(err);
                            }
                            logger.debug('getBranches return', data);
                        });
                        var newBranchName = 'br' + getRandomInt(2, 9999);
                        logger.debug('will create', newBranchName);
                        setTimeout(function () {
                            storage.createBranch(PROJECT_NAME,
                                newBranchName,
                                NEW_BRANCH_HASH,
                                function (err) {
                                    if (err) {
                                        throw new Error(err);
                                    }
                                    storage.getBranches(PROJECT_NAME, {}, function (err, data) {
                                        if (err) {
                                            throw new Error(err);
                                        }
                                        logger.debug('getBranches after create returned', data);
                                    });
                                });
                        }, 2000);
                    }
                });
            } else if (status === CONSTANTS.RECONNECTED) {
                logger.debug('Reconnected!');
                clearInterval(intervalId);
            } else if (status === CONSTANTS.DISCONNECTED) {
                logger.debug('Got disconnect, waiting for reconnect...');
                intervalId = setInterval(function () {
                    loadChildrenAndSetAttribute(currRootNode, currCommitObject);
                }, 2000);
            } else if (status === CONSTANTS.ERROR) {
                throw new Error('Could not connect');
            }
        });

        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
    }

    return Client;
});
/*globals define, document, console, window, GME, docReady, setTimeout*/
/*jshint browser:true, evil:true*/

/**
 * @author kecso / https://github.com/kecso
 * @author lattmann / https://github.com/lattmann
 * @author nabana / https://github.com/nabana
 * @author ksmyth / https://github.com/ksmyth
 * @author pmeijer / https://github.com/pmeijer
 */

define('webgme.classes', [
    'client/js/client',
    'blob/BlobClient',
    'executor/ExecutorClient',
    'js/Utils/InterpreterManager',
    'common/core/core',
    'common/storage/browserstorage',
    'js/logger',
    'lib/superagent/superagent',
    'teststorage/teststorage'
], function (Client,
             BlobClient,
             ExecutorClient,
             InterpreterManager,
             Core,
             Storage,
             Logger,
             superagent,
             TestStorage) {

    'use strict';
    // Setting global classes

    GME.classes.Client = Client;
    GME.classes.BlobClient = BlobClient;
    GME.classes.ExecutorClient = ExecutorClient;
    GME.classes.InterpreterManager = InterpreterManager;
    GME.classes.Core = Core;
    GME.classes.Storage = Storage;
    GME.classes.Logger = Logger;
    GME.classes.TestStorage = TestStorage;

    // Exposing built in libraries
    GME.utils.superagent = superagent;

    // Pure JavaScript equivalent to jQuery's $.ready() from https://github.com/jfriend00/docReady

    (function (funcName, baseObj) {
        // The public function name defaults to window.docReady
        // but you can pass in your own object and own function name and those will be used
        // if you want to put them in a different namespace
        funcName = funcName || 'docReady';
        baseObj = baseObj || window;
        var readyList = [];
        var readyFired = false;
        var readyEventHandlersInstalled = false;

        // call this when the document is ready
        // this function protects itself against being called more than once
        function ready() {
            if (!readyFired) {
                // this must be set to true before we start calling callbacks
                readyFired = true;
                for (var i = 0; i < readyList.length; i++) {
                    // if a callback here happens to add new ready handlers,
                    // the docReady() function will see that it already fired
                    // and will schedule the callback to run right after
                    // this event loop finishes so all handlers will still execute
                    // in order and no new ones will be added to the readyList
                    // while we are processing the list
                    readyList[i].fn.call(window, readyList[i].ctx);
                }
                // allow any closures held by these functions to free
                readyList = [];
            }
        }

        function readyStateChange() {
            if (document.readyState === 'complete') {
                ready();
            }
        }

        // This is the one public interface
        // docReady(fn, context);
        // the context argument is optional - if present, it will be passed
        // as an argument to the callback
        baseObj[funcName] = function (callback, context) {
            // if ready has already fired, then just schedule the callback
            // to fire asynchronously, but right away
            if (readyFired) {
                setTimeout(function () {
                    callback(context);
                }, 1);
                return;
            } else {
                // add the function and context to the list
                readyList.push({fn: callback, ctx: context});
            }
            // if document already ready to go, schedule the ready function to run
            if (document.readyState === 'complete') {
                setTimeout(ready, 1);
            } else if (!readyEventHandlersInstalled) {
                // otherwise if we don't have event handlers installed, install them
                if (document.addEventListener) {
                    // first choice is DOMContentLoaded event
                    document.addEventListener('DOMContentLoaded', ready, false);
                    // backup is window load event
                    window.addEventListener('load', ready, false);
                } else {
                    // must be IE
                    document.attachEvent('onreadystatechange', readyStateChange);
                    window.attachEvent('onload', ready);
                }
                readyEventHandlersInstalled = true;
            }
        };
    })('docReady', window);

    // See if there is handler attached to body tag when ready

    var evalOnGmeInit = function () {
        if (document.body.getAttribute('on-gme-init')) {
            eval(document.body.getAttribute('on-gme-init'));
        } else {
            console.warn('To use GME, define a javascript function and set the body ' +
            'element\'s on-gme-init property.');
        }
    };

    // wait for document.readyState !== 'loading' and getGmeConfig
    var stillLoading = 2;
    var somethingFinishedLoading = function () {
        if (--stillLoading === 0) {
            evalOnGmeInit();
        }
    };

    if (document.readyState === 'loading') {
        docReady(function () {
            somethingFinishedLoading();
        });
    } else {
        somethingFinishedLoading();
    }


    (function getGmeConfig() {
        var http = new XMLHttpRequest(),
            configUrl = window.location.origin + '/gmeConfig.json';
        http.onreadystatechange = function () {
            if (http.readyState === 4 && http.status === 200) {
                GME.gmeConfig = JSON.parse(http.responseText);
                somethingFinishedLoading();
            } else if (http.readyState === 4 && http.status !== 200) {
                console.warn('Could not load gmeConfig at', configUrl);
                somethingFinishedLoading();
            }
        };
        http.open('GET', configUrl, true);
        http.send();
    })();
});


require(["webgme.classes"]);
}());
//# sourceMappingURL=webgme.classes.build.js.map