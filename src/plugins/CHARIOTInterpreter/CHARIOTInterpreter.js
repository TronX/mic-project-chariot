/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Mon Nov 21 2016 20:28:20 GMT-0600 (Central Standard Time).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */



define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of CHARIOTInterpreter.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CHARIOTInterpreter.
     * @constructor
     */
    var CHARIOTInterpreter = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    CHARIOTInterpreter.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    CHARIOTInterpreter.prototype = Object.create(PluginBase.prototype);
    CHARIOTInterpreter.prototype.constructor = CHARIOTInterpreter;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CHARIOTInterpreter.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        var nodeObject = self.activeNode;

        self.tree = {};

        self.extractNodes()
            .then(function (nodes) {
                self.tree = self.getTree(nodes);
                self.saveModelInDb(self.tree);

            }).then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);

            }).catch(function (err) {
                // Result success is false at invocation.
                self.logger.error(err.stack);
                callback(err, self.result);
            });
    };



    CHARIOTInterpreter.prototype.extractNodes = function () {
        var self = this;
        return self.core.loadSubTree(self.rootNode)
            .then(function (nodeArray) {
                var nodes = {},i;
                for (i = 0; i < nodeArray.length; i += 1) {
                    nodes[self.core.getPath(nodeArray[i])] = nodeArray[i];
                }

                return nodes;
            });
    };

    CHARIOTInterpreter.prototype.getTree = function (nodes) {
        var self = this,
            tree = {},
            childrenPaths,
            childNode,
            i,
            j;


        var exampleNode = nodes["/X/O"];
        childrenPaths = self.core.getChildrenPaths(exampleNode);

        var componentTypeList = [];
        var goalDescriptionModel = {};
        var nodeCategoryList = [];

        self.logger.error("\n\n");

        for (i = 0; i < childrenPaths.length; i += 1) {
            childNode = nodes[childrenPaths[i]];
            var metaType = self.core.getAttribute(self.getMetaType(childNode),'name');
            var children = self.core.getChildrenPaths(childNode);

            if("ComponentType" == metaType){
                //Component Types
                var componentTypeModel = {};
                componentTypeModel.name = self.core.getAttribute(childNode,'name');
                componentTypeModel.providedFunctionality = self.core.getAttribute(childNode,'providedFunctionality');
                componentTypeModel.requiredOS = self.core.getAttribute(childNode,'requiredOS');
                componentTypeModel.requiredMiddleware = self.core.getAttribute(childNode,'requiredMiddleware');
                componentTypeModel.requiredArtifacts = [];
                componentTypeModel.requiredDevices = [];
                componentTypeModel.startScript = self.core.getAttribute(childNode,'startScript');
                componentTypeModel.stopScript = self.core.getAttribute(childNode,'stopScript');

                componentTypeModel.period={};
                componentTypeModel.period.time = 0.0;
                componentTypeModel.period.unit = "";

                componentTypeModel.deadline={};
                componentTypeModel.deadline.time = 0.0;
                componentTypeModel.deadline.unit = "";

                componentTypeModel.stopScript = self.core.getAttribute(childNode,'stopScript');

                for (j = 0; j < children.length; j += 1) {
                    var node1 = nodes[children[j]];
                    var childMetaType = self.core.getAttribute(self.getMetaType(node1),'name');

                    if("Memory" == childMetaType){
                        componentTypeModel.requiredMemory = {};
                        componentTypeModel.requiredMemory.memory = self.core.getAttribute(node1,'memory');
                        componentTypeModel.requiredMemory.unit = self.core.getAttribute(node1,'unit');

                    }else if("Storage" == childMetaType){
                        componentTypeModel.requiredStorage = {};
                        componentTypeModel.requiredStorage.storage = self.core.getAttribute(node1,'storage');
                        componentTypeModel.requiredStorage.unit = self.core.getAttribute(node1,'unit');
                    }
                }
                componentTypeList.push(componentTypeModel);

            }else if("GoalDescription" == metaType){
                goalDescriptionModel.name = self.core.getAttribute(childNode,'name');
                goalDescriptionModel.replicationConstraints = [];
                goalDescriptionModel.objectives = [];

                for (j = 0; j < children.length; j += 1) {
                    var node1 = nodes[children[j]];
                    var childMetaType = self.core.getAttribute(self.getMetaType(node1),'name');

                    if("ReplicationConstraint" == childMetaType){
                        var replicationConstraintModel = {};
                        replicationConstraintModel.kind = self.core.getAttribute(node1,'kind');
                        replicationConstraintModel.functionality = self.core.getAttribute(node1,'functionality');
                        replicationConstraintModel.maxInstances = self.core.getAttribute(node1,'maxInstances');
                        replicationConstraintModel.minInstances = self.core.getAttribute(node1,'minInstances');
                        replicationConstraintModel.numInstances = self.core.getAttribute(node1,'numInstances');
                        replicationConstraintModel.serviceComponentType = self.core.getAttribute(node1,'serviceComponentType');
                        var nodeCategoriesString = self.core.getAttribute(node1,'nodeCategories');

                        var nodeCategoriesArr = [];
                        var nodeCategoriesArr = nodeCategoriesString.split(",");
                        replicationConstraintModel.nodeCategories = [];
                        var k;
                        for(k = 0; k < nodeCategoriesArr.length; k += 1){
                            if(nodeCategoriesArr[k] != ""){
                                replicationConstraintModel.nodeCategories.push(nodeCategoriesArr[k]);
                            }
                        }
                        goalDescriptionModel.replicationConstraints.push(replicationConstraintModel);

                    }else if("Objective" == childMetaType){
                        var objectiveModel = {};
                        objectiveModel.name = self.core.getAttribute(node1,'name');
                        objectiveModel.functionalities = [];

                        var grandChildrenPaths = self.core.getChildrenPaths(node1);
                        var k;
                        for(k=0; k < grandChildrenPaths.length; k += 1){
                            var grandChildNode = nodes[grandChildrenPaths[k]];

                            var functionalityModel = {};
                            functionalityModel.name = self.core.getAttribute(grandChildNode,'name');

                            var dependsOnString = self.core.getAttribute(grandChildNode,'dependsOn');
                            var dependsOnArr = [];
                            var dependsOnArr = dependsOnString.split(",");

                            functionalityModel.dependsOn = [];
                            var l;
                            for(l = 0; l < dependsOnArr.length; l += 1){
                                if(dependsOnArr[l] != ""){
                                    functionalityModel.dependsOn.push(dependsOnArr[l]);
                                }
                            }
                            objectiveModel.functionalities.push(functionalityModel);
                        }
                        goalDescriptionModel.objectives.push(objectiveModel);
                    }
                }


            }else if("NodeCategory" == metaType){
                var nodeCategoryModel = {};
                nodeCategoryModel.name = self.core.getAttribute(childNode,'name');
                nodeCategoryModel.nodeTemplates = [];

                for (j = 0; j < children.length; j += 1) {
                    var node1 = nodes[children[j]];
                    var grandChildrenPaths = self.core.getChildrenPaths(node1);

                    var nodeTemplateModel = {};
                    nodeTemplateModel.name = self.core.getAttribute(node1,'name');
                    nodeTemplateModel.OS = self.core.getAttribute(node1,'OS');
                    nodeTemplateModel.middleware = self.core.getAttribute(node1,'middleware');
                    nodeTemplateModel.artifacts = [];
                    nodeTemplateModel.devices = [];

                    var k;
                    for(k=0; k < grandChildrenPaths.length; k += 1){
                        var grandChildNode = nodes[grandChildrenPaths[k]];
                        var grandChildMetaType = self.core.getAttribute(self.getMetaType(grandChildNode),'name');

                        if("Memory" == grandChildMetaType){
                            nodeTemplateModel.availableMemory = {};
                            nodeTemplateModel.availableMemory.memory = self.core.getAttribute(grandChildNode,'memory');
                            nodeTemplateModel.availableMemory.unit = self.core.getAttribute(grandChildNode,'unit');

                        }else if("Storage" == grandChildMetaType){
                            nodeTemplateModel.availableStorage = {};
                            nodeTemplateModel.availableStorage.storage = self.core.getAttribute(grandChildNode,'storage');
                            nodeTemplateModel.availableStorage.unit = self.core.getAttribute(grandChildNode,'unit');
                        }
                    }
                    nodeCategoryModel.nodeTemplates.push(nodeTemplateModel);
                }
                nodeCategoryList.push(nodeCategoryModel);
            }


        }

        tree.ComponentTypes = componentTypeList;
        tree.GoalDescriptions = goalDescriptionModel;
        tree.NodeCategories = nodeCategoryList;

        return tree;

    };


    CHARIOTInterpreter.prototype.saveModelInDb = function(chariotModel){
        var mongodb = require('mongodb');
        var uri = 'mongodb://localhost:27017/ConfigSpace';
        var i,j;

        mongodb.MongoClient.connect(uri, function(error, db) {
            //ComponentTypes
            for(i = 0; i < chariotModel.ComponentTypes.length; i += 1){
                db.collection('ComponentTypes').insert(chariotModel.ComponentTypes[i],function(error,result){});
            }

            //GoalDescriptions
            db.collection('GoalDescriptions').insert(chariotModel.GoalDescriptions,function(error,result){});

            //NodeCategories
            for(j = 0; j < chariotModel.NodeCategories.length; j += 1){
                db.collection('NodeCategories').insert(chariotModel.NodeCategories[j],function(error,result){});
            }
        });
    };


    return CHARIOTInterpreter;
});
